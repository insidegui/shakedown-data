<div class="announce instapaper_body md" data-path="2013-07-01-enumerators.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSFastEnumeration / NSEnumerator</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>Enumeration is where computation gets interesting. It's one thing to encode logic that's executed once, but applying it across a collection—that's what makes programming so powerful.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>n/a</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Enumeration is where computation gets interesting. It's one thing to encode logic that's executed once, but applying it across a collection—that's what makes programming so powerful.</p>

<p>Each programming paradigm has its own way to iterate over a collection:</p>

<ul>
<li><strong>Procedural</strong> increments a pointer within a loop</li>
<li><strong>Object Oriented</strong> applies a function or block to each object in a collection</li>
<li><strong>Functional</strong> works through a data structure recursively</li>
</ul>

<p>Objective-C, to echo one of the central themes of this blog, plays a fascinating role as a bridge between the Procedural traditions of C and the Object Oriented model pioneered in Smalltalk. In many ways, enumeration is where the proverbial rubber hits the road.</p>

<p>This article will cover all of the different ways collections are enumerated in Objective-C &amp; Cocoa. How do I love thee? Let me count the ways.</p>

<hr>

<h2><a id="user-content-c-loops-forwhile" class="anchor" href="#c-loops-forwhile" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Loops (<code>for/while</code>)</h2>

<p><code>for</code> and <code>while</code> loops are the "classic" method of iterating over a collection. Anyone who's taken Computer Science 101 has written code like this before:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">for</span> (<span class="pl-c1">NSUInteger</span> i = <span class="pl-c1">0</span>; i &lt; [array <span class="pl-c1">count</span>]; i++) {
  <span class="pl-c1">id</span> object = array[i];
  <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, object)
}</pre></div>

<p>But as anyone who has used C-style loops knows, this method is prone to <a href="http://en.wikipedia.org/wiki/Off-by-one_error">off-by-one errors</a>—particularly when used in a non-standard way.</p>

<p>Fortunately, Smalltalk significantly improved this state of affairs with an idea called <a href="http://en.wikipedia.org/wiki/List_comprehension">list comprehensions</a>, which are commonly known today as <code>for/in</code> loops.</p>

<h2><a id="user-content-list-comprehension-forin" class="anchor" href="#list-comprehension-forin" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>List Comprehension (<code>for/in</code>)</h2>

<p>By using a higher level of abstraction, declaring the intention of iterating through all elements of a collection, not only are we less prone to error, but there's a lot less to type:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">for</span> (<span class="pl-c1">id</span> object in array) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, object);
}</pre></div>

<p>In Cocoa, comprehensions are available to any class that implements the <code>NSFastEnumeration</code> protocol, including <code>NSArray</code>, <code>NSSet</code>, and <code>NSDictionary</code>.</p>

<h3><a id="user-content-nsfastenumeration" class="anchor" href="#nsfastenumeration" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>&lt;NSFastEnumeration&gt;</code></h3>

<p><code>NSFastEnumeration</code> contains a single method:</p>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">NSUInteger</span>)countByEnumeratingWithState:(<span class="pl-c1">NSFastEnumerationState</span> *)state
                                  objects:(<span class="pl-c1">id</span> *)stackbuf
                                    count:(<span class="pl-c1">NSUInteger</span>)len</pre></div>

<blockquote>
<ul>
<li><code>state</code>: Context information that is used in the enumeration to, in addition to other possibilities, ensure that the collection has not been mutated.</li>
<li><code>stackbuf</code>: A C array of objects over which the sender is to iterate.</li>
<li><code>len</code>: The maximum number of objects to return in stackbuf.</li>
</ul>
</blockquote>

<p>One single, <em>deceptively complicated</em> method. There's that <code>stackbuf</code> out pointer parameter, and a <code>state</code> parameter of type <code>NSFastEnumerationState *</code>. Let's take a closer look at that...</p>

<h3><a id="user-content-nsfastenumerationstate" class="anchor" href="#nsfastenumerationstate" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSFastEnumerationState</code></h3>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-k">struct</span> {
      <span class="pl-k">unsigned</span> <span class="pl-k">long</span> state;
      <span class="pl-c1">id</span> *itemsPtr;
      <span class="pl-k">unsigned</span> <span class="pl-k">long</span> *mutationsPtr;
      <span class="pl-k">unsigned</span> <span class="pl-k">long</span> extra[<span class="pl-c1">5</span>];
} <span class="pl-c1">NSFastEnumerationState</span>;</pre></div>

<blockquote>
<ul>
<li><code>state</code>: Arbitrary state information used by the iterator. Typically this is set to 0 at the beginning of the iteration.</li>
<li><code>itemsPtr</code>: A C array of objects.</li>
<li><code>mutationsPtr</code>: Arbitrary state information used to detect whether the collection has been mutated.</li>
<li><code>extra</code>: A C array that you can use to hold returned values.</li>
</ul>
</blockquote>

<p>Under every elegant abstraction is an underlying implementation deserving to be hidden from the eyes of God. <code>itemsPtr</code>? <code>mutationsPtr</code>? <code>extra</code>‽ Seriously, what gives?</p>

<blockquote>
<p>For the curious, <a href="http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Mike Ash has a fantastic blog post</a> where he dives into the internals, providing several reference implementations of <code>NSFastEnumeration</code>.</p>
</blockquote>

<p>What you should know about <code>NSFastEnumeration</code> is that it is <em>fast</em>. At least as fast if not significantly faster than rolling your own <code>for</code> loop, in fact. The secret behind its speed is how <code>-countByEnumeratingWithState:objects:count:</code> buffers collection members, loading them in as necessary. Unlike a single-threaded <code>for</code> loop implementation, objects can be loaded concurrently, making better use of available system resources.</p>

<p>Apple recommends that you use <code>NSFastEnumeration</code> <code>for/in</code>-style enumeration for your collections wherever possible and appropriate. And to be honest, for how easy it is to use and how well it performs, that's a pretty easy sell. Seriously, use it.</p>

<h2><a id="user-content-nsenumerator" class="anchor" href="#nsenumerator" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSEnumerator</code></h2>

<p>But of course, before <code>NSFastEnumeration</code> (circa OS X Leopard / iOS 2.0), there was the venerable <code>NSEnumerator</code>.</p>

<p>For the uninitiated, <code>NSEnumerator</code> is an abstract class that implements two methods:</p>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">id</span>)nextObject
- (<span class="pl-c1">NSArray</span> *)allObjects</pre></div>

<p><code>nextObject</code> returns the next object in the collection, or <code>nil</code> if unavailable. <code>allObjects</code> returns all of the remaining objects, if any. <code>NSEnumerator</code>s can only go forward, and only in single increments.</p>

<p>To enumerate through all elements in a collection, one would use <code>NSEnumerator</code> thusly:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">id</span> object = <span class="pl-c1">nil</span>;
<span class="pl-c1">NSEnumerator</span> *enumerator = ...;
<span class="pl-k">while</span> ((object = [enumerator <span class="pl-c1">nextObject</span>])) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, object);
}</pre></div>

<p>...or because <code>NSEnumerator</code> itself conforms to <code>&lt;NSFastEnumeration&gt;</code> in an attempt to stay hip to the way kids do things these days:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">for</span> (<span class="pl-c1">id</span> object in enumerator) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, object);
}</pre></div>

<p>If you're looking for a convenient way to add fast enumeration to your own non-collection-class-backed objects, <code>NSEnumerator</code> is likely a much more palatable option than getting your hands messy with <code>NSFastEnumeration</code>'s implementation details.</p>

<p>Some quick points of interest about <code>NSEnumeration</code>:</p>

<ul>
<li>Reverse an array in one line of code with (and excuse the excessive dot syntax) <code>array.reverseObjectEnumerator.allObjects</code>.</li>
<li>Add LINQ-style operations with <a href="https://github.com/k06a/NSEnumeratorLinq"><code>NSEnumeratorLinq</code></a>, a third-party library using chained <code>NSEnumerator</code> subclasses.</li>
<li>Shake things up with your collection classes in style with <a href="https://github.com/mattt/TTTRandomizedEnumerator"><code>TTTRandomizedEnumerator</code></a>, another third-party library, which iterates through elements in a random order.</li>
</ul>

<h2><a id="user-content-enumerate-with-blocks" class="anchor" href="#enumerate-with-blocks" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enumerate With Blocks</h2>

<p>Finally, with the introduction of blocks in OS X Snow Leopard / iOS 4, came a new block-based way to enumerate collections:</p>

<div class="highlight highlight-source-objc"><pre>[array <span class="pl-c1">enumerateObjectsUsingBlock:</span>^(<span class="pl-c1">id</span> object, <span class="pl-c1">NSUInteger</span> idx, <span class="pl-c1">BOOL</span> *stop) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, object);
}];</pre></div>

<p>Collection classes like <code>NSArray</code>, <code>NSSet</code>, <code>NSDictionary</code>, and <code>NSIndexSet</code> include a similar set of block enumeration methods.</p>

<p>One of the advantages of this approach is that the current object index (<code>idx</code>) is passed along with the object itself. The <code>BOOL</code> pointer allows for early returns, equivalent to a <code>break</code> statement in a regular C loop.</p>

<p>Unless you actually need the numerical index while iterating, it's almost always faster to use a <code>for/in</code> <code>NSFastEnumeration</code> loop instead.</p>

<p>One last thing to be aware of are the expanded method variants with an <code>options</code> parameter:</p>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-k">void</span>)enumerateObjectsWithOptions:(<span class="pl-c1">NSEnumerationOptions</span>)opts
                         usingBlock:(<span class="pl-k">void</span> (^)(<span class="pl-c1">id</span> obj, <span class="pl-c1">NSUInteger</span> idx, <span class="pl-c1">BOOL</span> *stop))block</pre></div>

<h3><a id="user-content-nsenumerationoptions" class="anchor" href="#nsenumerationoptions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSEnumerationOptions</code></h3>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">enum</span> {
   NSEnumerationConcurrent = (<span class="pl-c1">1UL</span> &lt;&lt; <span class="pl-c1">0</span>),
   NSEnumerationReverse = (<span class="pl-c1">1UL</span> &lt;&lt; <span class="pl-c1">1</span>),
};
<span class="pl-k">typedef</span> <span class="pl-c1">NSUInteger</span> <span class="pl-c1">NSEnumerationOptions</span>;</pre></div>

<blockquote>
<ul>
<li><code>NSEnumerationConcurrent</code>: Specifies that the Block enumeration should be concurrent. The order of invocation is nondeterministic and undefined; this flag is a hint and may be ignored by the implementation under some circumstances; the code of the Block must be safe against concurrent invocation.</li>
<li><code>NSEnumerationReverse</code>: Specifies that the enumeration should be performed in reverse. This option is available for <code>NSArray</code> and <code>NSIndexSet</code> classes; its behavior is undefined for <code>NSDictionary</code> and <code>NSSet</code> classes, or when combined with the <code>NSEnumerationConcurrent</code> flag.</li>
</ul>
</blockquote>

<p>Again, fast enumeration is almost certain to be much faster than block enumeration, but these options may be useful if you're resigned to using blocks.</p>

<hr>

<p>So there you have all of the conventional forms of enumeration in Objective-C and Cocoa.</p>

<p>What's especially interesting is that in looking at these approaches, we learn a lesson about the power of abstraction. Higher levels of abstraction are not just easier to write and comprehend, but can often be much faster than doing it the "hard way".</p>

<p>High-level commands that declare intention, like "iterate through all of the elements of this collection" lend themselves to high-level compiler optimization in a way that just isn't possible with pointer arithmetic in a loop. Context is a powerful thing, and designing APIs and functionality accordingly ultimately fulfill that great promise of abstraction: to solve larger problems more easily.</p>
</article></div>