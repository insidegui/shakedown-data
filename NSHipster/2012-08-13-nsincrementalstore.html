<div class="announce instapaper_body md" data-path="2012-08-13-nsincrementalstore.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSIncrementalStore</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>Even for a blog dedicated to obscure APIs, `NSIncrementalStore` sets a new standard. It was introduced in iOS 5, with no more fanfare than the requisite entry in the SDK changelog. Ironically, it is arguably the most important thing to come out of iOS 5, which will completely change the way we build apps from here on out.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.1</div></td>

  <td><div>September 8, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Even for a blog dedicated to obscure APIs, <code>NSIncrementalStore</code> brings a new meaning to the word "obscure".</p>

<p>It was introduced in iOS 5, with no more fanfare than the requisite entry in the SDK changelog.</p>

<p>Its <a href="https://developer.apple.com/library/mac/#documentation/DataManagement/Conceptual/IncrementalStorePG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010706">programming guide</a> weighs in at a paltry 82 words, making it the shortest by an order of magnitude.</p>

<p>If it weren't for an offhand remark during <a href="https://deimos.apple.com/WebObjects/Core.woa/BrowsePrivately/adc.apple.com.8266478284.08266478290.8365294535?i=2068798830">WWDC 2011 Session 303</a>, it may have gone completely unnoticed.</p>

<p>And yet, <code>NSIncrementalStore</code> is arguably the most important thing to come out of iOS 5.</p>

<h2><a id="user-content-at-last-a-foothold-into-core-data" class="anchor" href="#at-last-a-foothold-into-core-data" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>At Last, A Foothold Into Core Data</h2>

<p><code>NSIncrementalStore</code> is an abstract subclass of <code>NSPersistentStore</code> designed to "create persistent stores which load and save data incrementally, allowing for the management of large and/or shared datasets". And while that may not sound like much, consider that nearly all of the database adapters we rely on load incrementally from large, shared data stores. What we have here is a goddamned miracle.</p>

<p>For those of you not as well-versed in Core Data, here's some background:</p>

<p><a href="http://developer.apple.com/library/mac/#documentation/cocoa/Conceptual/CoreData/cdProgrammingGuide.html">Core Data</a> is Apple's framework for object relational mapping. It's used in at least half of all of the first-party apps on Mac and iOS, as well as thousands of other third-party apps. Core Data is complex, but that's because it solves complex problems, covering a decades-worth of one-offs and edge cases.</p>

<p>This is all to say that Core Data is something you should probably use in your application.</p>

<p>Persistent stores in Core Data are comparable to database adapters in other ORMs, such as <a href="http://ar.rubyonrails.org">Active Record</a>. They respond to changes within <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/NSManagedObjectContext.html">managed object contexts</a> and handle <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/CoreDataFramework/Classes/NSFetchRequest_Class/NSFetchRequest.html">fetch requests</a> by reading and writing data to some persistence layer. For most applications, that persistent layer has been a local SQLite database.</p>

<p>With <code>NSIncrementalStore</code>, developers now have a sanctioned, reasonable means to create a store that connects to whatever underlying backend you like--and rather simply, too. All it takes is to implement a few required methods:</p>

<h2><a id="user-content-implementing-an-nsincrementalstore-subclass" class="anchor" href="#implementing-an-nsincrementalstore-subclass" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing an NSIncrementalStore Subclass</h2>

<h3><a id="user-content-type-and-initialize" class="anchor" href="#type-and-initialize" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>+type</code> and <code>+initialize</code></h3>

<p><code>NSPersistentStore</code> instances are not created directly. Instead, they follow a factory pattern similar to <code>NSURLProtocol</code> or <code>NSValueTransformer</code>, in that they register their classes with the <code>NSPersistentStoreCoordinator</code>, which then constructs persistent store instances as necessary when <code>-addPersistentStoreWithType:configuration:URL:options:error:</code> is called. The registered persistent store classes are identified by a unique "store type" string (<code>NSStringFromClass</code> is sufficient, but you could be pedantic by specifying a string that follows the convention of ending in <code>-Type</code>, like <code>NSSQLiteStoreType</code>).</p>

<p><code>+initialize</code> is automatically called the first time a class is loaded, so this is a good place to register with <code>NSPersistentStoreCoordinator</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> CustomIncrementalStore: NSIncrementalStore {
    <span class="pl-k">override</span> <span class="pl-k">class</span> <span class="pl-k">func</span> <span class="pl-en">initialize</span>() {
        NSPersistentStoreCoordinator<span class="pl-k">.</span>registerStoreClass(<span class="pl-k">self</span>, forStoreType:<span class="pl-k">self</span><span class="pl-k">.</span>type)
    }

    <span class="pl-k">class</span> <span class="pl-k">var</span> type: <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> NSStringFromClass(<span class="pl-k">self</span>)
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>+ (<span class="pl-k">void</span>)initialize {
  [NSPersistentStoreCoordinator <span class="pl-c1">registerStoreClass:</span><span class="pl-v">self</span> <span class="pl-c1">forStoreType:</span>[<span class="pl-v">self</span> <span class="pl-c1">type</span>]];
}

+ (<span class="pl-c1">NSString</span> *)type {
  <span class="pl-k">return</span> <span class="pl-c1">NSStringFromClass</span>(self);
}</pre></div>

<h3><a id="user-content--loadmetadata" class="anchor" href="#-loadmetadata" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-loadMetadata:</code></h3>

<p><code>loadMetadata:</code> is where the incremental store has a chance to configure itself. There is, however, a bit of Kabuki theater boilerplate that's necessary to get everything set up. Specifically, you need to set a UUID for the store, as well as the store type. Here's what that looks like:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">loadMetadata</span>(error: NSErrorPointer) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">self</span><span class="pl-k">.</span>metadata <span class="pl-k">=</span> [
        NSStoreUUIDKey: NSProcessInfo()<span class="pl-k">.</span>globallyUniqueString,
        NSStoreTypeKey: <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-k">dynamicType</span><span class="pl-k">.</span>type
    ]

    <span class="pl-k">return</span> <span class="pl-c1">true</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSMutableDictionary</span> *mutableMetadata = [<span class="pl-c1">NSMutableDictionary</span> <span class="pl-c1">dictionary</span>];
[mutableMetadata <span class="pl-c1">setValue:</span>[[<span class="pl-c1">NSProcessInfo</span> <span class="pl-c1">processInfo</span>] <span class="pl-c1">globallyUniqueString</span>] <span class="pl-c1">forKey:</span>NSStoreUUIDKey];
[mutableMetadata <span class="pl-c1">setValue:</span>[[<span class="pl-v">self</span> <span class="pl-c1">class</span>] <span class="pl-c1">type</span>] <span class="pl-c1">forKey:</span>NSStoreTypeKey];
[<span class="pl-v">self</span> <span class="pl-c1">setMetadata:</span>mutableMetadata];</pre></div>

<h3><a id="user-content--executerequestwithcontexterror" class="anchor" href="#-executerequestwithcontexterror" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-executeRequest:withContext:error:</code></h3>

<p>Here's where things get interesting, from an implementation standpoint. (And where it all goes to hell, from an API design standpoint)</p>

<p><code>executeRequest:withContext:error:</code> passes an <code>NSPersistentStoreRequest</code>, an <code>NSManagedObjectContext</code> and an <code>NSError</code> pointer.</p>

<p><code>NSPersistentStoreRequest</code>'s role here is as a sort of abstract subclass. The request parameter will either be of type <code>NSFetchRequestType</code> or an <code>NSSaveRequestType</code>. If it has a <em>fetch</em> request type, the request parameter will actually be an instance of <code>NSFetchRequest</code>, which is a subclass of <code>NSPersistentStoreRequest</code>. Likewise, if it has a <em>save</em> request type, it will be an instance of <code>NSSaveChangesRequest</code> (this article was originally mistaken by stating that there was no such a class).</p>

<p>This method requires very specific and very different return values depending on the request parameter (and the <code>resultType</code>, if it's an <code>NSFetchRequest</code>). The only way to explain it is to run through all of the possibilities:</p>

<h4><a id="user-content-request-type-nsfetchrequesttype" class="anchor" href="#request-type-nsfetchrequesttype" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Request Type: <code>NSFetchRequestType</code></h4>

<ul>
<li>Result Type: <code>NSManagedObjectResultType</code>, <code>NSManagedObjectIDResultType</code>, or <code>NSDictionaryResultType</code></li>
</ul>

<blockquote>
<p><strong>Return</strong>: <code>NSArray</code> of objects matching request</p>
</blockquote>

<ul>
<li>Result Type: <code>NSCountResultType</code></li>
</ul>

<blockquote>
<p><strong>Return</strong>: <del><tt>NSNumber</tt></del><ins><tt>NSArray</tt> containing one <tt>NSNumber</tt> of count of objects matching request</ins></p>
</blockquote>

<h4><a id="user-content-request-type-nssaverequesttype" class="anchor" href="#request-type-nssaverequesttype" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Request Type: <code>NSSaveRequestType</code></h4>

<blockquote>
<p><strong>Return</strong>: Empty <code>NSArray</code></p>
</blockquote>

<p>So, one method to do all read <em>and</em> write operations with a persistence backend. At least all of the heavy lifting goes to the same place, right?</p>

<h3><a id="user-content--newvaluesforobjectwithidwithcontexterror" class="anchor" href="#-newvaluesforobjectwithidwithcontexterror" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-newValuesForObjectWithID:withContext:error:</code></h3>

<p>This method is called when an object faults, or has its values refreshed by the managed object context.</p>

<p>It returns an <code>NSIncrementalStoreNode</code>, which is a container for the ID and current values for a particular managed object. The node should include all of the attributes, as well as the managed object IDs of any to-one relationships. There is also a <code>version</code> property of the node that can be used to determine the current state of an object, but this may not be applicable to all storage implementations.</p>

<p>If an object with the specified <code>objectID</code> cannot be found, this method should return <code>nil</code>.</p>

<h3><a id="user-content--newvalueforrelationshipforobjectwithid-withcontexterror" class="anchor" href="#-newvalueforrelationshipforobjectwithid-withcontexterror" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-newValueForRelationship:forObjectWithID: withContext:error:</code></h3>

<p>This one is called when a relationship needs to be refreshed, either from a fault or by the managed object context.</p>

<p>Unlike the previous method, the return value will be just the current value for a single relationship. The expected return type depends on the nature of the relationship:</p>

<ul>
<li><strong>to-one</strong>: <code>NSManagedObjectID</code></li>
<li><strong>to-many</strong>: <code>NSSet</code> or <code>NSOrderedSet</code></li>
<li><strong>non-existent</strong>: <code>nil</code></li>
</ul>

<h3><a id="user-content--obtainpermanentidsforobjectserror" class="anchor" href="#-obtainpermanentidsforobjectserror" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-obtainPermanentIDsForObjects:error:</code></h3>

<p>Finally, this method is called before <code>executeRequest:withContext:error:</code> with a save request, where permanent IDs should be assigned to newly-inserted objects. As you might expect, the array of permanent IDs should match up with the array of objects passed into this method.</p>

<p>This usually corresponds with a write to the persistence layer, such as an <code>INSERT</code> statement in SQL. If, for example, the row corresponding to the object had an auto-incrementing <code>id</code> column, you could generate an objectID with:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">self</span><span class="pl-k">.</span>newObjectIDForEntity(entity, referenceObject: rowID)</pre></div>

<div class="highlight highlight-source-objc"><pre>[<span class="pl-v">self</span> <span class="pl-c1">newObjectIDForEntity:</span>entity <span class="pl-c1">referenceObject:</span>[<span class="pl-c1">NSNumber</span> <span class="pl-c1">numberWithUnsignedInteger:</span>rowID]];</pre></div>

<h2><a id="user-content-roll-your-own-core-data-backend" class="anchor" href="#roll-your-own-core-data-backend" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Roll Your Own Core Data Backend</h2>

<p>Going through all of the necessary methods to override in an <code>NSIncrementalStore</code> subclass, you may have found your mind racing with ideas about how you might implement a SQL or NoSQL store, or maybe something new altogether.</p>

<p>What makes <code>NSIncrementalStore</code> so exciting is that you <em>can</em> build a store on your favorite technology, and drop that into any existing Core Data stack with little to no additional configuration.</p>

<p>So imagine if, instead SQL or NoSQL, we wrote a Core Data store that connected to a webservice. Allow me to introduce <a href="https://github.com/AFNetworking/AFIncrementalStore">AFIncrementalStore</a>.</p>

<h2><a id="user-content-afincrementalstore" class="anchor" href="#afincrementalstore" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AFIncrementalStore</h2>

<p><a href="https://github.com/AFNetworking/AFIncrementalStore"><code>AFIncrementalStore</code></a> is an NSIncrementalStore subclass that uses <a href="https://github.com/afnetworking/afnetworking">AFNetworking</a> to automatically request resources as properties and relationships are needed.</p>

<p>What this means is that you can now write apps that communicate with a webservice <em>without exposing any of the details about the underlying API</em>. Any time a fetch request is made or an attribute or relationship faults, an asynchronous network request will fetch that information from the webservice.</p>

<p>Since the store abstracts all of the implementation details of the API away, you can write expressive fetch requests and object relationships from the start. No matter how bad or incomplete an API may be, you can change all of that mapping independently of the business logic of the client.</p>

<hr>

<p>Even though <code>NSIncrementalStore</code> has been around since iOS 5, we're still a long way from even beginning to realize its full potential. The future is insanely bright, so you best don your aviators, grab an iced latte and start coding something amazing.</p>
</article></div>