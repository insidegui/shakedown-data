<div class="announce instapaper_body md" data-path="2015-06-01-mirrortype.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>MirrorType</div></td>

  <td><div>Nate Cook</div></td>

  <td><div>Swift</div></td>

  <td><div>Reflection in Swift is a limited affair, providing read-only access to a subset of type metadata. While far from the rich array of run-time hackery familiar to seasoned Objective-C developers, Swift's tools enable the immediate feedback and sense of exploration offered by Xcode Playgrounds. This week, we'll reflect on reflection in Swift, its mirror types, and `MirrorType`, the protocol that binds them together.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.2</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Reflection in Swift is a limited affair, providing read-only access to a subset of type metadata. While far from the rich array of run-time hackery familiar to seasoned Objective-C developers, Swift's tools enable the immediate feedback and sense of exploration offered by Xcode Playgrounds.</p>

<p>Perhaps Swift's strict type checking obviates the need for reflection. With variable types typically known at compile time, there might not be cause for further examination or branching. Then again, a hefty number of Cocoa APIs dole out <code>AnyObject</code> instances at the drop of a hat, leaving us to cast about for the matching type.</p>

<p>This week, we'll reflect on reflection in Swift, its mirror types, and <code>MirrorType</code>, the protocol that binds them together.</p>

<hr>

<h2><a id="user-content-mirrortype" class="anchor" href="#mirrortype" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>MirrorType</code></h2>

<p>The entry point for reflection is the <code>reflect</code> function, which can take an instance of any type as its single parameter and returns a <code>MirrorType</code>. Now, <code>MirrorType</code> is something of an oddity for the Swift standard libary: a protocol used as a type. Other than the ubiquitous <code>AnyObject</code>, to date no other protocol is used this way. The particular <code>MirrorType</code>-conforming instance that you receive depends on the type passed to <code>reflect</code>—Swift's internals define mirrors for types such as <code>Array</code>, <code>Dictionary</code>, <code>Optional</code>, and <code>Range</code>, along with more generic mirrors for structs, classes, tuples, and metatypes.</p>

<p><code>MirrorType</code> provides the nascent reflection API that Swift offers, wrapping a value along with its type information, information about its children, and different representations of the instance. Mirrors have the following properties:</p>

<blockquote>
<ul>
<li><code>value</code>: access to the original reflected value, but with type <code>Any</code>.</li>
<li><code>valueType</code>: the <code>Type</code> of the original reflected value—equivalent to <code>value.dynamicType</code>.</li>
<li><code>count</code>: the number of logical children. For a collection, like <code>Array</code> or <code>Set</code>, this is the number of elements; for a struct, this is the number of stored properties.</li>
<li><code>disposition</code>: a value from the <code>MirrorDisposition</code> enumeration, intended to help the IDE choose how to display the value. <code>MirrorDisposition</code> has eleven cases:

<ul>
<li><code>IndexContainer</code>, <code>KeyContainer</code>, <code>MembershipContainer</code>, <code>Container</code>: used for collections.</li>
<li><code>Optional</code>: used for optional values. Implicitly unwrapped optionals are skipped over by <code>reflect()</code> to fetch the reflection of the unwrapped value.</li>
<li><code>Aggregate</code>: used for Swift types that bridge to Objective-C and for Objective-C types that have been augmented for use with Swift. For example, <code>Float</code> has an <code>Aggregate</code> disposition while the non-bridged <code>Float80</code> returns <code>Struct</code>, and <code>UIView</code> (extended for <code>Reflectable</code> conformance), has an <code>Aggregate</code> disposition while the unadorned <code>UIBarButtonItem</code> returns <code>ObjCObject</code>.</li>
<li><code>ObjCObject</code>: by contrast with <code>Aggregate</code>, used for unextended Objective-C classes.</li>
<li><code>Tuple</code>: used for tuple values.</li>
<li><code>Struct</code>, <code>Class</code>, <code>Enum</code>: used as fallback cases for types that don't fall into any of the above categories.</li>
</ul></li>
<li><code>objectIdentifier</code>: the unique object identifier for a class or metatype instance.</li>
<li><code>summary</code>: a string description of the value.</li>
<li><code>quickLookObject</code>: a <a href="http://swiftdoc.org/type/QuickLookObject/"><code>QuickLookObject</code></a> instance holding a visual or text representation of the value. Its behavior is similar to the <code>debugQuickLookObject</code> <a href="/quick-look-debugging/">we covered a few weeks back</a>.</li>
</ul>
</blockquote>

<p>Additionally, a mirror has an <code>Int</code>-based subscript that returns a <code>(String, MirrorType)</code> tuple for each child. That's the <em>name</em> of the property/key/index and a <em>mirror</em> of the value.</p>

<p>So how can we put <code>MirrorType</code> to use? Let's suppose we have a group of numbers in a tuple that we want to use for a lottery ticket, but we need to convert them to an <code>[Int]</code> array first:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> lotteryTuple <span class="pl-k">=</span> (<span class="pl-c1">4</span>, <span class="pl-c1">8</span>, <span class="pl-c1">15</span>, <span class="pl-c1">16</span>, <span class="pl-c1">23</span>, <span class="pl-c1">42</span>)</pre></div>

<p>Rather than extracting the pieces of the tuple one by one (i.e., <code>lotteryType.0</code>, <code>lotteryTuple.1</code>, etc.), we can use <code>reflect()</code> to iterate over the elements:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// create a mirror of the tuple</span>
<span class="pl-k">let</span> lotteryMirror <span class="pl-k">=</span> <span class="pl-c1">reflect</span>(lotteryTuple)

<span class="pl-c">// loop over the elements of the mirror to build an array</span>
<span class="pl-k">var</span> lotteryArray: [<span class="pl-c1">Int</span>] <span class="pl-k">=</span> []
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span>lotteryMirror<span class="pl-k">.</span><span class="pl-c1">count</span> {
    <span class="pl-k">let</span> (index, mirror) <span class="pl-k">=</span> lotteryMirror[i]
    <span class="pl-k">if</span> <span class="pl-k">let</span> number <span class="pl-k">=</span> mirror<span class="pl-k">.</span><span class="pl-c1">value</span> <span class="pl-k">as?</span> <span class="pl-c1">Int</span> {
        lotteryArray<span class="pl-k">.</span>append(number)
    }
}
println(lotteryArray)   <span class="pl-c">// [4, 8, 15, 16, 23, 42]</span></pre></div>

<p>Not bad.</p>

<h3><a id="user-content-mapping-a-mirror" class="anchor" href="#mapping-a-mirror" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mapping a Mirror</h3>

<p>If we could map over the elements in a mirror, reflecting over an instance's properties or elements would be a bit easier. Let's write a <code>mapReflection</code> function that takes an instance of any type and a transforming closure:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">mapReflection</span>&lt;T, U&gt;(x: T, <span class="pl-k">@noescape</span> transform: (<span class="pl-c1">String</span>, <span class="pl-c1">MirrorType</span>) <span class="pl-k">-&gt;</span> U) -&gt; [U] {
    <span class="pl-k">var</span> result: [U] <span class="pl-k">=</span> []
    <span class="pl-k">let</span> mirror <span class="pl-k">=</span> <span class="pl-c1">reflect</span>(x)
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span>mirror<span class="pl-k">.</span><span class="pl-c1">count</span> {
        result<span class="pl-k">.</span>append(transform(mirror[i]))
    }
    <span class="pl-k">return</span> result
}</pre></div>

<p>Now we can quite simply print all the logical children of any instance:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> printChild: (<span class="pl-c1">String</span>, <span class="pl-c1">MirrorType</span>) <span class="pl-k">-&gt;</span> () <span class="pl-k">=</span> {
    println(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">$<span class="pl-c1">0</span></span><span class="pl-pse">)</span>: <span class="pl-pse">\(</span><span class="pl-s1">$<span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">value</span></span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
}

mapReflection(lotteryTuple, printChild)
<span class="pl-c">// .0: 4</span>
<span class="pl-c">// .1: 8</span>
<span class="pl-c">// ...</span>

mapReflection(lotteryArray, printChild)
<span class="pl-c">// [0]: 4</span>
<span class="pl-c">// [1]: 8</span>
<span class="pl-c">// ...</span>

mapReflection(CGRect<span class="pl-k">.</span>zeroRect, printChild)
<span class="pl-c">// origin: (0.0, 0.0)</span>
<span class="pl-c">// size: (0.0, 0.0)</span></pre></div>

<p>That output might look familiar to those who have used Swift's <code>dump</code> function before. <code>dump</code> uses reflection recursively to print out an instance's children, their children, and so on:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c1">dump</span>(CGRect<span class="pl-k">.</span>zeroRect)
<span class="pl-c">// ▿ (0.0, 0.0, 0.0, 0.0)</span>
<span class="pl-c">//   ▿ origin: (0.0, 0.0)</span>
<span class="pl-c">//     - x: 0.0</span>
<span class="pl-c">//     - y: 0.0</span>
<span class="pl-c">//   ▿ size: (0.0, 0.0)</span>
<span class="pl-c">//     - width: 0.0</span>
<span class="pl-c">//     - height: 0.0</span></pre></div>

<h2><a id="user-content-custom-cut-mirrors" class="anchor" href="#custom-cut-mirrors" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom-Cut Mirrors</h2>

<p>Beyond <code>dump</code>, Xcode also uses mirrors extensively for the display of values in a <a href="/xcplayground/">Playground</a>, both in the results pane on the right side of a Playground window and in captured value displays. Custom types don't start out with a custom mirror, so their display can leave something to be desired. Let's look at the default behavior of a custom type in a Playground and then see how a custom <code>MirrorType</code> can improve that display.</p>

<p>For our custom type, we'll use a simple struct to hold information about a WWDC session:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">/// Information for a single WWDC session.</span>
<span class="pl-k">struct</span> WWDCSession {
    <span class="pl-c">/// An enumeration of the different WWDC tracks.</span>
    <span class="pl-k">enum</span> Track <span class="pl-k">:</span> <span class="pl-c1">String</span> {
        <span class="pl-k">case</span> Featured         <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Featured<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> AppFrameworks    <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>App Frameworks<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> Distribution     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Distribution<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> DeveloperTools   <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Developer Tools<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> Media            <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Media<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> GraphicsAndGames <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Graphics &amp; Games<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> SystemFrameworks <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>System Frameworks<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> Design           <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Design<span class="pl-pds">"</span></span>
    }

    <span class="pl-k">let</span> number: <span class="pl-c1">Int</span>
    <span class="pl-k">let</span> title: <span class="pl-c1">String</span>
    <span class="pl-k">let</span> track: Track
    <span class="pl-k">let</span> summary: <span class="pl-c1">String</span>?
}

<span class="pl-k">let</span> session801 <span class="pl-k">=</span> WWDCSession(number: <span class="pl-c1">801</span>,
    title: <span class="pl-s"><span class="pl-pds">"</span>Designing for Future Hardware<span class="pl-pds">"</span></span>,
    track: <span class="pl-k">.</span>Design,
    summary: <span class="pl-s"><span class="pl-pds">"</span>Design for tomorrow's products today. See examples...<span class="pl-pds">"</span></span>)</pre></div>

<p>By default, reflection on a <code>WWDCSession</code> instance uses the built-in <code>_StructMirror</code> type. This provides a property-based summary on the right (useful) but only the class name in a captured value pane (not so useful):</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/mirrortype-default.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/mirrortype-default.gif" alt="Default WWDCSession Representation" style="max-width:100%;"></a></p>

<p>To provide a richer representation of a <code>WWDCSession</code>, we'll implement a new type, <code>WWDCSessionMirror</code>. This type must conform to <code>MirrorType</code>,  including all the properties listed above:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> WWDCSessionMirror: <span class="pl-c1">MirrorType</span> {
    <span class="pl-k">private</span> <span class="pl-k">let</span> _value: WWDCSession

    <span class="pl-k">init</span>(_ value: WWDCSession) {
        _value <span class="pl-k">=</span> value
    }

    <span class="pl-k">var</span> value: <span class="pl-c1">Any</span> { <span class="pl-k">return</span> _value }

    <span class="pl-k">var</span> valueType: <span class="pl-c1">Any</span><span class="pl-k">.</span><span class="pl-k">Type</span> { <span class="pl-k">return</span> WWDCSession<span class="pl-k">.</span><span class="pl-k">self</span> }

    <span class="pl-k">var</span> objectIdentifier: <span class="pl-c1">ObjectIdentifier</span>? { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }

    <span class="pl-k">var</span> disposition: <span class="pl-c1">MirrorDisposition</span> { <span class="pl-k">return</span> <span class="pl-k">.</span>Struct }

    <span class="pl-c">// MARK: Child properties</span>

    <span class="pl-k">var</span> count: <span class="pl-c1">Int</span> { <span class="pl-k">return</span> <span class="pl-c1">4</span> }

    <span class="pl-k">subscript</span>(index: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> (<span class="pl-c1">String</span>, <span class="pl-c1">MirrorType</span>) {
        <span class="pl-k">switch</span> index {
        <span class="pl-k">case</span> <span class="pl-c1">0</span>:
            <span class="pl-k">return</span> (<span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>, <span class="pl-c1">reflect</span>(_value<span class="pl-k">.</span>number))
        <span class="pl-k">case</span> <span class="pl-c1">1</span>:
            <span class="pl-k">return</span> (<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>, <span class="pl-c1">reflect</span>(_value<span class="pl-k">.</span>title))
        <span class="pl-k">case</span> <span class="pl-c1">2</span>:
            <span class="pl-k">return</span> (<span class="pl-s"><span class="pl-pds">"</span>track<span class="pl-pds">"</span></span>, <span class="pl-c1">reflect</span>(_value<span class="pl-k">.</span>track))
        <span class="pl-k">case</span> <span class="pl-c1">3</span>:
            <span class="pl-k">return</span> (<span class="pl-s"><span class="pl-pds">"</span>summary<span class="pl-pds">"</span></span>, <span class="pl-c1">reflect</span>(_value<span class="pl-k">.</span><span class="pl-c1">summary</span>))
        <span class="pl-k">default</span>:
            fatalError(<span class="pl-s"><span class="pl-pds">"</span>Index out of range<span class="pl-pds">"</span></span>)
        }
    }

    <span class="pl-c">// MARK: Custom representation</span>

    <span class="pl-k">var</span> summary: <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>WWDCSession <span class="pl-pse">\(</span><span class="pl-s1">_value<span class="pl-k">.</span>number</span><span class="pl-pse">)</span> [<span class="pl-pse">\(</span><span class="pl-s1">_value<span class="pl-k">.</span>track<span class="pl-k">.</span><span class="pl-c1">rawValue</span></span><span class="pl-pse">)</span>]: <span class="pl-pse">\(</span><span class="pl-s1">_value<span class="pl-k">.</span>title</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>
    }

    <span class="pl-k">var</span> quickLookObject: <span class="pl-c1">QuickLookObject</span>? {
        <span class="pl-k">return</span> <span class="pl-k">.</span>Text(summary)
    }
}</pre></div>

<p>In the <code>summary</code> and <code>quickLookObject</code> properties, we provide our custom representation of a <code>WWDCSession</code>—a nicely formatted string. Note, in particular, that the implementation of <code>count</code> and the subscript are completely manual. The default mirror types ignore <code>private</code> and <code>internal</code> access modifiers, so a custom mirror <em>could</em> be used to hide implementation details, even from reflection.</p>

<p>Lastly, we must link <code>WWDCSession</code> to its custom mirror by adding conformance to the <code>Reflectable</code> protocol. Conformance only requires a single new method, <code>getMirror()</code>, which returns a <code>MirrorType</code>—in this case, our shiny new <code>WWDCSessionMirror</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> WWDCSession <span class="pl-k">:</span> Reflectable {
    <span class="pl-k">func</span> <span class="pl-en">getMirror</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">MirrorType</span> {
        <span class="pl-k">return</span> WWDCSessionMirror(<span class="pl-k">self</span>)
    }
}</pre></div>

<p>That's it! The Playground now uses our custom representation instead of the default:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/mirrortype-custom.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/mirrortype-custom.gif" alt="Custom WWDCSession Representation" style="max-width:100%;"></a></p>

<blockquote>
<p>In the absence of <code>Printable</code> conformance, <code>println()</code> and <code>toString()</code> will also pull the string representation from an instance's mirror.</p>
</blockquote>

<hr>

<p>In its current form, Swift reflection is more novelty than powerful feature. With new Swift functionality surely right around the corner at WWDC, this article may prove to have a very short shelf life indeed. But in the mean time, should you find the need for introspection, you'll know just where to look.</p>
</article></div>