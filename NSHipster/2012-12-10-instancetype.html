<div class="announce instapaper_body md" data-path="2012-12-10-instancetype.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>instancetype</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Objective-C</div></td>

  <td><div>Objective-C is a rapidly evolving language, in a way that you just don't see in established programming languages. Developments range from the mundane to paradigm-changing, but telling the difference takes practice. Because we're talking about low-level language features, it's difficult to understand what implications they may have higher up with API design.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>n/a</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Want to know what's coming next in Objective-C? <a href="http://clang.llvm.org/docs/LanguageExtensions.html">Keep your ear to the ground</a>.</p>

<p>Objective-C is a rapidly evolving language, in a way that you just don't see in established programming languages. ARC, object literals, subscripting, blocks: in the span of just three years, so much of how we program in Objective-C has been changed (for the better).</p>

<p>All of this innovation is a result of Apple's philosophy of vertical integration. Just as Apple's investment in designing <a href="http://en.wikipedia.org/wiki/Apple_A4">its own chipsets</a> gave them leverage to compete aggressively with their mobile hardware, so too has their investment in <a href="http://llvm.org">LLVM</a> allowed their software to keep pace.</p>

<p>Clang developments range from the mundane to paradigm-changing, but telling the difference takes practice. Because we're talking about low-level language features, it's difficult to understand what implications they may have higher up with API design.</p>

<p>One such example is <code>instancetype</code>, the subject of this week's article.</p>

<hr>

<p>In Objective-C, conventions aren't just a matter of coding best-practices, they are implicit instructions to the compiler.</p>

<p>For example, <code>alloc</code> and <code>init</code> both have return types of <code>id</code>, yet in Xcode, the compiler makes all of the correct type checks. How is this possible?</p>

<p>In Cocoa, there is a convention that methods with names like <code>alloc</code>, or <code>init</code> always return objects that are an instance of the receiver class. These methods are said to have a <strong>related result type</strong>.</p>

<p>Class constructor methods, although they similarly return <code>id</code>, don't get the same type-checking benefit, because they don't follow that naming convention.</p>

<p>You can try this out for yourself:</p>

<div class="highlight highlight-source-objc"><pre>[[[<span class="pl-c1">NSArray</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>] <span class="pl-c1">mediaPlaybackAllowsAirPlay</span>]; <span class="pl-c">// ‚ùó "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"</span>

[[<span class="pl-c1">NSArray</span> <span class="pl-c1">array</span>] <span class="pl-c1">mediaPlaybackAllowsAirPlay</span>]; <span class="pl-c">// (No error)</span></pre></div>

<p>Because <code>alloc</code> and <code>init</code> follow the naming convention for being a related result type, the correct type check against <code>NSArray</code> is performed. However, the equivalent class constructor <code>array</code> does not follow that convention, and is interpreted as <code>id</code>.</p>

<p><code>id</code> is useful for opting-out of type safety, but losing it when you <em>do</em> want it sucks.</p>

<p>The alternative, of explicitly declaring the return type (<code>(NSArray *)</code> in the previous example) is a slight improvement, but is annoying to write, and doesn't play nicely with subclasses.</p>

<p>This is where the compiler steps in to resolve this timeless edge case to the Objective-C type system:</p>

<p><code>instancetype</code> is a contextual keyword that can be used as a result type to signal that a method returns a related result type. For example:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">@interface</span> <span class="pl-en">Person</span>
+ (<span class="pl-k">instancetype</span>)<span class="pl-en">personWithName</span><span class="pl-en">:</span>(<span class="pl-c1">NSString</span> *)<span class="pl-smi">name</span>;
<span class="pl-k">@end</span></pre></div>

<blockquote>
<p><code>instancetype</code>, unlike <code>id</code>, can only be used as the result type in a method declaration.</p>
</blockquote>

<p>With <code>instancetype</code>, the compiler will correctly infer that the result of <code>+personWithName:</code> is an instance of a <code>Person</code>.</p>

<p>Look for class constructors in Foundation to start using <code>instancetype</code> in the near future. New APIs, such as <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UICollectionViewLayoutAttributes_class/Reference/Reference.html">UICollectionViewLayoutAttributes</a> are using <code>instancetype</code> already.</p>

<h2><a id="user-content-further-implications" class="anchor" href="#further-implications" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Further Implications</h2>

<p>Language features are particularly interesting because, again, it's often unclear of what impact they'll have on higher-level aspects of software design.</p>

<p>While <code>instancetype</code> may seem to be a rather mundane, albeit welcome addition to the compiler, it can be used to some rather clever ends.</p>

<p><a href="https://twitter.com/jonsterling">Jonathan Sterling</a> wrote <a href="http://www.jonmsterling.com/posts/2012-02-05-typed-collections-with-self-types-in-objective-c.html">this quite interesting article</a>, detailing how <code>instancetype</code> could be used to encode statically-typed collections, without <a href="http://en.wikipedia.org/wiki/Generic_programming">generics</a>:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSURL</span> &lt;MapCollection&gt; *sites = (<span class="pl-c1">id</span>)[<span class="pl-c1">NSURL</span> <span class="pl-c1">mapCollection</span>];
[sites <span class="pl-c1">put:</span>[<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>http://www.jonmsterling.com/<span class="pl-pds">"</span></span>]
        <span class="pl-c1">at:</span><span class="pl-s"><span class="pl-pds">@"</span>jon<span class="pl-pds">"</span></span>];
[sites <span class="pl-c1">put:</span>[<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>http://www.nshipster.com/<span class="pl-pds">"</span></span>]
        <span class="pl-c1">at:</span><span class="pl-s"><span class="pl-pds">@"</span>nshipster<span class="pl-pds">"</span></span>];

<span class="pl-c1">NSURL</span> *jonsSite = [sites <span class="pl-c1">at:</span><span class="pl-s"><span class="pl-pds">@"</span>jon<span class="pl-pds">"</span></span>]; <span class="pl-c">// =&gt; http://www.jonmsterling.com/</span></pre></div>

<p>Statically-typed collections would make APIs more expressive--no longer would a developer be unsure about what kinds of objects are allowed in a collection parameter.</p>

<p>Whether or not this becomes an accepted convention in Objective-C, it's fascinating to how a low-level feature like <code>instancetype</code> can be used to change shape of the language (in this case, making it look more like <a href="http://en.wikipedia.org/wiki/C_Sharp_(programming_language)">C#</a>).</p>

<hr>

<p><code>instancetype</code> is just one of the many language extensions to Objective-C, with more being added with each new release.</p>

<p>Know it, love it.</p>

<p>And take it as an example of how paying attention to the low-level details can give you insights into powerful new ways to transform Objective-C.</p>
</article></div>