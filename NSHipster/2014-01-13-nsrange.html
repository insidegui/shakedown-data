<div class="announce instapaper_body md" data-path="2014-01-13-nsrange.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSRange</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>NSRange is one of the essential types of Foundation. Passed around and returned in methods throughout the framework, being well-versed in this struct has a range of benefits.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>n/a</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p><code>NSRange</code> is one of the essential types of Foundation. Passed around and returned in methods throughout the framework, being well-versed in this struct has a range of benefits, which this week's article will help you locate.</p>

<hr>

<p>Ranges are data types used to describe a contiguous interval of integers. They are most commonly used with strings, arrays, and similarly-ordered collections.</p>

<p>For Objective-C programs, the Foundation type <code>NSRange</code> is used. In other languages, ranges are often encoded as a two-element array, containing the start and end indexes. In Foundation, <code>NSRange</code> instead encodes a range as struct containing the location and length. By command-clicking (<code>⌘-ʘ</code>) on the <code>NSRange</code> symbol in Xcode, we can jump directly to its declaration in <code>Foundation/NSRange.h</code>:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-k">struct</span> _NSRange {
    <span class="pl-c1">NSUInteger</span> location;
    <span class="pl-c1">NSUInteger</span> length;
} <span class="pl-c1">NSRange</span>;</pre></div>

<p>In practice, this approach helps mitigate common off-by-one errors when working with ranges. For example, compare the equivalent Javascript and Objective-C code for creating a range of characters for a given string:</p>

<h4><a id="user-content-rangejs" class="anchor" href="#rangejs" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>range.js</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> string <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello, world<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> range <span class="pl-k">=</span> [<span class="pl-c1">0</span>, <span class="pl-smi">string</span>.<span class="pl-c1">length</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>];</pre></div>

<p>Forgetting to subtract <code>1</code> for the end index in Javascript would result in an out-of-bounds error later.</p>

<h4><a id="user-content-rangem" class="anchor" href="#rangem" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>range.m</h4>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *string = <span class="pl-s"><span class="pl-pds">@"</span>hello, world<span class="pl-pds">"</span></span>;
<span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">0</span>, [string <span class="pl-c1">length</span>]);</pre></div>

<p><code>NSRange</code>'s approach is clearer and less prone to error—especially when it comes to more complex arithmetic operations on ranges.</p>

<h2><a id="user-content-usage" class="anchor" href="#usage" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>

<h3><a id="user-content-strings" class="anchor" href="#strings" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strings</h3>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *string = <span class="pl-s"><span class="pl-pds">@"</span>lorem ipsum dolor sit amet<span class="pl-pds">"</span></span>;
<span class="pl-c1">NSRange</span> range = [string <span class="pl-c1">rangeOfString:</span><span class="pl-s"><span class="pl-pds">@"</span>ipsum<span class="pl-pds">"</span></span>];
<span class="pl-c">// {.location=6, .length=5}</span>

<span class="pl-c1">NSString</span> *substring = [string <span class="pl-c1">substringWithRange:</span>range];
<span class="pl-c">// @"ipsum"</span></pre></div>

<p><code>NSString</code> does not have a method like <code>containsString:</code>. Instead, <code>rangeOfString:</code> can be used to check for an <code>NSNotFound</code> location value:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *input = ...;
<span class="pl-k">if</span> ([input <span class="pl-c1">rangeOfString:</span><span class="pl-s"><span class="pl-pds">@"</span>keyword<span class="pl-pds">"</span></span>].location != <span class="pl-c1">NSNotFound</span>) {
    <span class="pl-c">// ...</span>
}</pre></div>

<h3><a id="user-content-arrays" class="anchor" href="#arrays" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arrays</h3>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSArray</span> *array = @[<span class="pl-s"><span class="pl-pds">@"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>c<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>d<span class="pl-pds">"</span></span>];
<span class="pl-c1">NSArray</span> *subarray = [array <span class="pl-c1">subarrayWithRange:</span><span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)];
<span class="pl-c">// @[@"b", @"c"]</span></pre></div>

<h3><a id="user-content-index-sets" class="anchor" href="#index-sets" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Index Sets</h3>

<p><a href="http://nshipster.com/nsindexset/">NSIndexSet</a> is a Foundation collection class that is similar to <code>NSRange</code>, with the notable exception of being able to support non-contiguous series. An <code>NSIndexSet</code> can be created from a range using the <code>indexSetWithIndexesInRange:</code> class constructor:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">0</span>, <span class="pl-c1">10</span>);
<span class="pl-c1">NSIndexSet</span> *indexSet = [<span class="pl-c1">NSIndexSet</span> <span class="pl-c1">indexSetWithIndexesInRange:</span>range];</pre></div>

<h2><a id="user-content-functions" class="anchor" href="#functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functions</h2>

<p>Because <code>NSRange</code> is not a class, creating and using instances is done through function calls, rather than, say, instance methods.</p>

<blockquote>
<p>Many of the NSRange functions are named counter to the modern conventions of Foundation and CoreFoundation wherein the relevant type of the function immediately follows the two-letter namespace. For example, <code>NSMakeRange</code> should instead be named <code>NSRangeMake</code>, following the example of <code>CGRectMake</code> and <code>CGSizeMake</code>,  et al. Similarly,  a better name for <code>NSEqualRanges</code> would be <code>NSRangeEqualToRange</code>, just like <code>CGPointEqualToPoint</code>.</p>

<p>Although consistency in itself is likely not sufficient reason to go through the trouble of replacing existing usage, <a href="https://gist.github.com/mattt/8402537">this gist</a> shows how one could make their own code base a little more OCD-friendly.</p>
</blockquote>

<h3><a id="user-content-creating-an-nsrange" class="anchor" href="#creating-an-nsrange" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating an NSRange</h3>

<blockquote>
<ul>
<li><code>NSMakeRange</code>:  Creates a new NSRange from the specified values.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSArray</span> *array = @[@<span class="pl-c1">1</span>, @<span class="pl-c1">2</span>, @<span class="pl-c1">3</span>];
<span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">0</span>, [array <span class="pl-c1">count</span>]);
<span class="pl-c">// {.location=0, .length=3}</span></pre></div>

<h3><a id="user-content-querying-information" class="anchor" href="#querying-information" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Querying Information</h3>

<blockquote>
<ul>
<li><code>NSEqualRanges</code>: Returns a Boolean value that indicates whether two given ranges are equal.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range1 = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">0</span>, <span class="pl-c1">6</span>);
<span class="pl-c1">NSRange</span> range2 = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">2</span>, <span class="pl-c1">7</span>);
<span class="pl-c1">BOOL</span> equal = <span class="pl-c1">NSEqualRanges</span>(range1, range2); <span class="pl-c">// NO</span></pre></div>

<blockquote>
<ul>
<li><code>NSLocationInRange</code>:  Returns a Boolean value that indicates whether a specified position is in a given range.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>);
<span class="pl-c1">BOOL</span> contained = <span class="pl-c1">NSLocationInRange</span>(<span class="pl-c1">5</span>, range); <span class="pl-c">// YES</span></pre></div>

<blockquote>
<ul>
<li><code>NSMaxRange</code>: Returns the sum of the location and length of the range.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>);
<span class="pl-c1">NSUInteger</span> max = <span class="pl-c1">NSMaxRange</span>(range); <span class="pl-c">// 7</span></pre></div>

<h3><a id="user-content-set-operations" class="anchor" href="#set-operations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Set Operations</h3>

<blockquote>
<ul>
<li><code>NSIntersectionRange</code>: Returns the intersection of the specified ranges. If the returned range’s length field is <code>0</code>, then the two ranges don’t intersect, and the value of the location field is undefined.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range1 = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">0</span>, <span class="pl-c1">6</span>);
<span class="pl-c1">NSRange</span> range2 = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">2</span>, <span class="pl-c1">7</span>);
<span class="pl-c1">NSRange</span> intersectionRange = <span class="pl-c1">NSIntersectionRange</span>(range1, range2);
<span class="pl-c">// {.location=2, .length=4}</span></pre></div>

<blockquote>
<ul>
<li><code>NSUnionRange</code>: Returns the union of the specified ranges. A range covering all indices in and between range1 and range2. If one range is completely contained in the other, the returned range is equal to the larger range.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range1 = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">0</span>, <span class="pl-c1">6</span>);
<span class="pl-c1">NSRange</span> range2 = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">2</span>, <span class="pl-c1">7</span>);
<span class="pl-c1">NSRange</span> unionRange = <span class="pl-c1">NSUnionRange</span>(range1, range2);
<span class="pl-c">// {.location=0, .length=9}</span></pre></div>

<h3><a id="user-content-converting-between-nsstring---nsrange" class="anchor" href="#converting-between-nsstring---nsrange" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Converting Between NSString * &amp; NSRange</h3>

<blockquote>
<ul>
<li><code>NSStringFromRange</code>: Returns a string representation of a range.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>);
<span class="pl-c1">NSString</span> *string = <span class="pl-c1">NSStringFromRange</span>(range); <span class="pl-c">// @"{3,4}"</span></pre></div>

<blockquote>
<ul>
<li><code>NSRangeFromString</code>: Returns a range from a textual representation.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *string = <span class="pl-s"><span class="pl-pds">@"</span>{1,5}<span class="pl-pds">"</span></span>;
<span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSRangeFromString</span>(string);
<span class="pl-c">// {.location=1, .length=5}</span></pre></div>

<p>If the string passed into <code>NSRangeFromString</code> does not represent a valid range, it will return a range with its location and length set to <code>0</code>.</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *string = <span class="pl-s"><span class="pl-pds">@"</span>invalid<span class="pl-pds">"</span></span>;
<span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSRangeFromString</span>(string);
<span class="pl-c">// {.location=0, .length=0}</span></pre></div>

<p>While one might be tempted to use <code>NSStringFromRange</code> to box <code>NSRange</code> for inclusion within an <code>NSArray</code>, <code>NSValue +valueWithRange:</code> is the way to go:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSRange</span> range = <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>);
<span class="pl-c1">NSValue</span> *value = [<span class="pl-c1">NSValue</span> <span class="pl-c1">valueWithRange:</span>range];</pre></div>

<hr>

<p><code>NSRange</code> is one of the few cases where some of the underlying implementation of its functions are actually exposed and inlined in the public headers:</p>

<h4><a id="user-content-foundationnsrangeh" class="anchor" href="#foundationnsrangeh" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Foundation/NSRange.h</h4>

<div class="highlight highlight-source-objc"><pre>NS_INLINE <span class="pl-c1">NSRange</span> <span class="pl-c1">NSMakeRange</span>(<span class="pl-c1">NSUInteger</span> loc, <span class="pl-c1">NSUInteger</span> len) {
    <span class="pl-c1">NSRange</span> r;
    r.<span class="pl-smi">location</span> = loc;
    r.<span class="pl-smi">length</span> = len;
    <span class="pl-k">return</span> r;
}

NS_INLINE <span class="pl-c1">NSUInteger</span> <span class="pl-c1">NSMaxRange</span>(<span class="pl-c1">NSRange</span> range) {
    <span class="pl-k">return</span> (range.<span class="pl-smi">location</span> + range.<span class="pl-smi">length</span>);
}

NS_INLINE <span class="pl-c1">BOOL</span> <span class="pl-c1">NSLocationInRange</span>(<span class="pl-c1">NSUInteger</span> loc, <span class="pl-c1">NSRange</span> range) {
    <span class="pl-k">return</span> (!(loc &lt; range.<span class="pl-smi">location</span>) &amp;&amp; (loc - range.<span class="pl-smi">location</span>) &lt; range.<span class="pl-smi">length</span>) ? <span class="pl-c1">YES</span> : <span class="pl-c1">NO</span>;
}

NS_INLINE <span class="pl-c1">BOOL</span> <span class="pl-c1">NSEqualRanges</span>(<span class="pl-c1">NSRange</span> range1, <span class="pl-c1">NSRange</span> range2) {
    <span class="pl-k">return</span> (range1.<span class="pl-smi">location</span> == range2.<span class="pl-smi">location</span> &amp;&amp; range1.<span class="pl-smi">length</span> == range2.<span class="pl-smi">length</span>);
}</pre></div>

<h2><a id="user-content-nsrangepointer" class="anchor" href="#nsrangepointer" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NSRangePointer</h2>

<p>One oddity worth mentioning with <code>NSRange</code> is the existence of <code>NSRangePointer</code>. "What the what?", you might exclaim in panicked confusion. Jumping to the source confirms our darkest fears:</p>

<h4><a id="user-content-foundationnsrangeh-1" class="anchor" href="#foundationnsrangeh-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Foundation/NSRange.h</h4>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-c1">NSRange</span> *<span class="pl-c1">NSRangePointer</span>;</pre></div>

<p>So. Without a definitive origin story, one would have to assume that this type was created by a well-meaning framework engineer who noted the confusion around <code>NSRange</code> being a struct and not a class. <code>NSRange *</code> is equivalent to <code>NSRangePointer</code>, though the latter can be found in out parameters for various methods throughout Foundation. <code>NSAttributedString</code>, for instance, has an <code>NSRangePointer</code> parameter for returning the effective range of an attribute at a particular index (since the attribute likely starts and ends before outside of the specified index):</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSMutableAttributedString</span> *mutableAttributedString = ...;
<span class="pl-c1">NSRange</span> range;
<span class="pl-k">if</span> ([mutableAttributedString <span class="pl-c1">attribute:</span><span class="pl-c1">NSUnderlineStyleAttributeName</span>
                               <span class="pl-c1">atIndex:</span><span class="pl-c1">0</span>
                        <span class="pl-c1">effectiveRange:</span>&amp;range])
{
    <span class="pl-c">// Make underlined text blue as well</span>
    [mutableAttributedString <span class="pl-c1">addAttribute:</span><span class="pl-c1">NSForegroundColorAttributeName</span>
                                    <span class="pl-c1">value:</span>[UIColor <span class="pl-c1">blueColor</span>]
                                    <span class="pl-c1">range:</span>range];
}</pre></div>

<h2><a id="user-content-cfrange" class="anchor" href="#cfrange" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CFRange</h2>

<p>One final caveat: Core Foundation also defines a <code>CFRange</code> type, which differs from <code>NSRange</code> in using <code>CFIndex</code> types for its members, and having only the function <code>CFRangeMake</code>:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-k">struct</span> {
    <span class="pl-c1">CFIndex</span> location;
    <span class="pl-c1">CFIndex</span> length;
} <span class="pl-c1">CFRange</span>;</pre></div>

<p>Anyone working with CoreText or another low-level C API is likely to encounter <code>CFRange</code> in place of <code>NSRange</code>.</p>
</article></div>