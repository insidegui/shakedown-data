<div class="announce instapaper_body md" data-path="2012-11-19-ns_enum-ns_options.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NS_ENUM &amp; NS_OPTIONS</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>nshipster, popular</div></td>

  <td><div>A skilled Objective-C developer is able to gracefully switch between Objective and Procedural paradigms, and use each to their own advantage.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>n/a</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>When everything is an object, nothing is.</p>

<p>So, there are a few ways you could parse that, but for the purposes of this article, this is all to say: sometimes it's nice to be able to drop down to the C layer of things.</p>

<p>Yes--that non-objective part of our favorite Smalltalk-inspired hybrid language, C can be a great asset. It's fast, it's battle-tested, it's the very foundation of modern computing. But more than that, C is the escape hatch for when the Object-Oriented paradigm cracks under its own cognitive weight.</p>

<p>Static functions are nicer than shoe-horned class methods.
Enums are nicer than string constants.
Bitmasks are nicer than arrays of string constants.
Preprocessor directives are nicer than runtime hacks.</p>

<p>A skilled Objective-C developer is able to gracefully switch between Objective and Procedural paradigms, and use each to their own advantage.</p>

<p>And on that note, this week's topic has to do with two simple-but-handy macros: <code>NS_ENUM</code> and <code>NS_OPTIONS</code>.</p>

<hr>

<p>Introduced in Foundation with iOS 6 / OS X Mountain Lion, the <code>NS_ENUM</code> and <code>NS_OPTIONS</code> macros are the new, preferred way to declare <code>enum</code> types.</p>

<blockquote>
<p>If you'd like to use either macro when targeting a previous version of iOS or OS X, you can simply inline like so:</p>
</blockquote>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">ifndef</span> NS_ENUM
#<span class="pl-k">define</span> <span class="pl-en">NS_ENUM</span>(<span class="pl-v">_type, _name</span>) <span class="pl-k">enum</span> _name : _type _name; <span class="pl-k">enum</span> _name : _type
#<span class="pl-k">endif</span></pre></div>

<p><code>enum</code>, or enumerated value types, are the C way to define constants for fixed values, like days of the week, or available styles of table view cells. In an <code>enum</code> declaration, constants without explicit values will automatically be assigned values sequentially, starting from <code>0</code>.</p>

<p>There are several legal ways that <code>enum</code>s can be defined. What's confusing is that there are subtle functional differences between each approach, and without knowing any better, someone is just as likely to use them interchangeably.</p>

<p>For instance:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">enum</span> {
    UITableViewCellStyleDefault,
    UITableViewCellStyleValue1,
    UITableViewCellStyleValue2,
    UITableViewCellStyleSubtitle
};</pre></div>

<p>...declares integer values, but no type.</p>

<p>Whereas:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-k">enum</span> {
    UITableViewCellStyleDefault,
    UITableViewCellStyleValue1,
    UITableViewCellStyleValue2,
    UITableViewCellStyleSubtitle
} UITableViewCellStyle;</pre></div>

<p>...defines the <code>UITableViewCellStyle</code> type, suitable for specifying the type of method parameters.</p>

<p>However, Apple had previously defined all of their <code>enum</code> types as:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-k">enum</span> {
    UITableViewCellStyleDefault,
    UITableViewCellStyleValue1,
    UITableViewCellStyleValue2,
    UITableViewCellStyleSubtitle
};

<span class="pl-k">typedef</span> <span class="pl-c1">NSInteger</span> UITableViewCellStyle;</pre></div>

<p>...which ensures a fixed size for <code>UITableViewCellStyle</code>, but does nothing to hint the relation between the aforementioned <code>enum</code> and the new type to the compiler.</p>

<p>Thankfully, Apple has decided on "One Macro To Rule Them All" with <code>NS_ENUM</code>.</p>

<h2><a id="user-content-ns_enum" class="anchor" href="#ns_enum" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NS_ENUM</code></h2>

<p>Now, <code>UITableViewCellStyle</code> is declared with:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-en">NS_ENUM</span>(<span class="pl-c1">NSInteger</span>, UITableViewCellStyle) {
    UITableViewCellStyleDefault,
    UITableViewCellStyleValue1,
    UITableViewCellStyleValue2,
    UITableViewCellStyleSubtitle
};</pre></div>

<p>The first argument for <code>NS_ENUM</code> is the type used to store the new type. In a 64-bit environment, <code>UITableViewCellStyle</code> will be 8 bytes long--same as <code>NSInteger</code>. Make sure that the specified size can fit all of the defined values, or else an error will be generated. The second argument is the name of the new type (as you probably guessed). Inside the block, the values are defined as usual.</p>

<p>This approach combines the best of all of the aforementioned approaches, and even provides hints to the compiler for type-checking and <code>switch</code> statement completeness.</p>

<h2><a id="user-content-ns_options" class="anchor" href="#ns_options" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NS_OPTIONS</code></h2>

<p><code>enum</code> can also be used to define a <a href="http://en.wikipedia.org/wiki/Mask_(computing)">bitmask</a>. Using a convenient property of binary math, a single integer value can encode a combination of values all at once using the bitwise <code>OR</code> (<code>|</code>), and decoded with bitwise <code>AND</code> (<code>&amp;</code>). Each subsequent value, rather than automatically being incremented by 1 from 0, are manually given a value with a bit offset: <code>1 &lt;&lt; 0</code>, <code>1 &lt;&lt; 1</code>, <code>1 &lt;&lt; 2</code>, and so on. If you imagine the binary representation of a number, like <code>10110</code> for 22, each bit can be thought to represent a single boolean. In UIKit, for example, <code>UIViewAutoresizing</code> is a bitmask that can represent any combination of flexible top, bottom, left, and right margins, or width and height.</p>

<p>Rather than <code>NS_ENUM</code>, bitmasks should now use the <code>NS_OPTIONS</code> macro.</p>

<p>The syntax is exactly the same as <code>NS_ENUM</code>, but this macro alerts the compiler to how values can be combined with bitmask <code>|</code>. Again, you must be careful that all of the enumerated values fit within the specified type.</p>

<hr>

<p><code>NS_ENUM</code> and <code>NS_OPTIONS</code> are handy additions to the Objective-C development experience, and reaffirm the healthy dialectic between its objective and procedural nature. Keep this in mind as you move forward in your own journey to understand the logical tensions that underpin everything around us.</p>
</article></div>