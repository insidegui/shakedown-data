<div class="announce instapaper_body md" data-path="2014-10-28-cmdevicemotion.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>CMDeviceMotion</div></td>

  <td><div>Nate Cook</div></td>

  <td><div>Cocoa</div></td>

  <td><div>Beneath the smooth glass of each shiny iPhone, nestled on a logic board between touch screen controllers and Apple-designed SoCs, the gyroscope and accelerometer sit largely neglected.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.2</div></td>

  <td><div>April 10, 2016</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Beneath the smooth glass of each shiny iPhone, nestled on a logic board between touch screen controllers and Apple-designed SoCs, the gyroscope and accelerometer sit largely neglected.</p>

<p>Need it be so? The <em><a href="https://developer.apple.com/library/ios/documentation/coremotion/reference/coremotion_reference/index.html">Core Motion framework</a></em> makes it surprisingly easy to harness these sensors, opening the door to user interactions above and beyond the tapping and swiping we do every day.</p>

<blockquote>
<p>For devices that include the M7 or M8 motion processor, the Core Motion framework also provides access to stored motion activity, such as step counts, stairs climbed, and movement type (walking, cycling, etc.).</p>
</blockquote>

<hr>

<p>Core Motion allows a developer to observe and respond to the motion and orientation of an iOS device by inspecting the raw and processed data from a combination of built-in sensors, including the accelerometer, gyroscope, and magnetometer.</p>

<p>Both accelerometer and gyroscope data are presented in terms of three axes that run through the iOS device. For an iPhone held in portrait orientation, the X-axis runs through the device from left (negative values) to right (positive values), the Y-axis through the device from bottom (-) to top (+), and the Z-axis runs perpendicularly through the screen from the back (-) to the front (+).</p>

<p>The composited device motion data are presented in a few different ways, each with their own uses, as we'll see below.</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/cmdm-axes.png" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/cmdm-axes.png" alt="Device X-, Y-, and Z-axes" style="max-width:100%;"></a></p>

<h2><a id="user-content-cmmotionmanager" class="anchor" href="#cmmotionmanager" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CMMotionManager</h2>

<p>The <code>CMMotionManager</code> class provides access to all the motion data on an iOS device. Interestingly, Core Motion provides both "pull" and "push" access to motion data. To "pull" motion data, you can access the current status of any sensor or the composited data as read-only properties of <code>CMMotionManager</code>. To receive "pushed" data, you start the collection of your desired data with a block or closure that receives updates at a specified interval.</p>

<p>To keep performance at the highest level, Apple recommends using a single shared <code>CMMotionManager</code> instance throughout your app.</p>

<p><code>CMMotionManager</code> provides a consistent interface for each of the four motion data types: <code>accelerometer</code>, <code>gyro</code>, <code>magnetometer</code>, and <code>deviceMotion</code>. As an example, here are the ways you can interact with the gyroscope—simply replace <code>gyro</code> with the motion data type you need.</p>

<h4><a id="user-content-checking-for-availability" class="anchor" href="#checking-for-availability" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Checking for Availability</h4>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> manager <span class="pl-k">=</span> CMMotionManager()
<span class="pl-k">if</span> manager<span class="pl-k">.</span>gyroAvailable {
     <span class="pl-c">// ...</span>
}</pre></div>

<blockquote>
<p>To make things simpler and equivalent between Swift and Objective-C, assume we've declared a <code>manager</code> instance as a view controller property for all the examples to come.</p>
</blockquote>

<h4><a id="user-content-setting-the-update-interval" class="anchor" href="#setting-the-update-interval" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting the Update Interval</h4>

<div class="highlight highlight-source-swift"><pre>manager<span class="pl-k">.</span>gyroUpdateInterval <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">1</span></pre></div>

<p>This is an <code>NSTimeInterval</code>, so specify your update time in seconds: lower for smoother responsiveness, higher for less CPU usage.</p>

<h4><a id="user-content-starting-updates-to-pull-data" class="anchor" href="#starting-updates-to-pull-data" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Starting Updates to "pull" Data</h4>

<div class="highlight highlight-source-swift"><pre>manager<span class="pl-k">.</span>startGyroUpdates()</pre></div>

<p>After this call, <code>manager.gyroData</code> is accessible at any time with the device's current gyroscope data.</p>

<h4><a id="user-content-starting-updates-to-push-data" class="anchor" href="#starting-updates-to-push-data" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Starting Updates to "push" Data</h4>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> queue <span class="pl-k">=</span> NSOperationQueue<span class="pl-k">.</span>mainQueue()
manager<span class="pl-k">.</span>startGyroUpdatesToQueue(queue) {
    (data, error) <span class="pl-k">in</span>
    <span class="pl-c">// ...</span>
}</pre></div>

<p>The handler closure will be called at the frequency given by the update interval.</p>

<h4><a id="user-content-stopping-updates" class="anchor" href="#stopping-updates" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stopping Updates</h4>

<div class="highlight highlight-source-swift"><pre>manager<span class="pl-k">.</span>stopGyroUpdates()</pre></div>

<h2><a id="user-content-using-the-accelerometer" class="anchor" href="#using-the-accelerometer" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using the Accelerometer</h2>

<p>Let's say we want to give the splash page of our app a fun effect, with the background image staying level no matter how the phone is tilted.</p>

<p>Consider the following code:</p>

<p>First, we check to make sure our device makes accelerometer data available, next we specify a very high update rate, and then we begin updates to a closure that will rotate a <code>UIImageView</code> property:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">if</span> manager<span class="pl-k">.</span>accelerometerAvailable {
    manager<span class="pl-k">.</span>accelerometerUpdateInterval <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">01</span>
    manager<span class="pl-k">.</span>startAccelerometerUpdatesToQueue(NSOperationQueue<span class="pl-k">.</span>mainQueue()) {
        [<span class="pl-k">weak</span> <span class="pl-k">self</span>] (data: CMAccelerometerData?, error: NSError?) <span class="pl-k">in</span>
        <span class="pl-k">if</span> <span class="pl-k">let</span> acceleration <span class="pl-k">=</span> data?<span class="pl-k">.</span>acceleration {
            <span class="pl-k">let</span> rotation <span class="pl-k">=</span> atan2(acceleration<span class="pl-k">.</span>x, acceleration<span class="pl-k">.</span>y) <span class="pl-k">-</span> M_PI
            <span class="pl-k">self</span>?<span class="pl-k">.</span>imageView<span class="pl-k">.</span>transform <span class="pl-k">=</span> CGAffineTransformMakeRotation(CGFloat(rotation))
        }
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>RotationViewController * __weak weakSelf = self;
<span class="pl-k">if</span> (manager.accelerometerAvailable) {
    manager.<span class="pl-smi">accelerometerUpdateInterval</span> = <span class="pl-c1">0</span>.<span class="pl-c1">01f</span>;
    [manager <span class="pl-c1">startAccelerometerUpdatesToQueue:</span>[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">mainQueue</span>]
                              <span class="pl-c1">withHandler:</span>^(CMAccelerometerData *data, <span class="pl-c1">NSError</span> *error) {
        <span class="pl-k">double</span> rotation = <span class="pl-c1">atan2</span>(data.<span class="pl-smi">acceleration</span>.<span class="pl-smi">x</span>, data.<span class="pl-smi">acceleration</span>.<span class="pl-smi">y</span>) - M_PI;
        weakSelf.<span class="pl-smi">imageView</span>.<span class="pl-smi">transform</span> = <span class="pl-c1">CGAffineTransformMakeRotation</span>(rotation);
    }];
}</pre></div>

<p>Each packet of <code>CMAccelerometerData</code> includes an <code>x</code>, <code>y</code>, and <code>z</code> value—each of these shows the amount of acceleration in Gs (where G is one unit of gravity) for that axis. That is, if your device were stationary and straight up in portrait orientation, it would have acceleration <code>(0, -1, 0)</code>; laying flat on its back on the table would be <code>(0, 0, -1)</code>; and tilted forty-five degrees to the right would be something like <code>(0.707, -0.707, 0)</code>.</p>

<p>We're calculating the rotation by computing the <a href="http://en.wikipedia.org/wiki/Atan2"><code>arctan2</code></a> of the <code>x</code> and <code>y</code> components from the accelerometer data and then using that rotation in a <code>CGAffineTransform</code>. Our image should stay right-side up no matter how the phone is turned—here it is in a hypothetical app for the <em>National Air &amp; Space Museum</em> (my favorite museum as a kid):</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/cmdm-accelerometer.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/cmdm-accelerometer.gif" alt="Rotation with accelerometer" style="max-width:100%;"></a></p>

<p>The results are not terribly satisfactory—the image movement is jittery, and moving the device in space affects the accelerometer as much as or even more than rotating. These issues <em>could</em> be mitigated by sampling multiple readings and averaging them together, but instead let's look at what happens when we involve the gyroscope.</p>

<h2><a id="user-content-adding-the-gyroscope" class="anchor" href="#adding-the-gyroscope" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding the Gyroscope</h2>

<p>Rather than use the raw gyroscope data that we would get with <code>startGyroUpdates...</code>, let's get composited gyroscope <em>and</em> accelerometer data from the <code>deviceMotion</code> data type. Using the gyroscope, Core Motion separates user movement from gravitational acceleration and presents each as its own property of the <code>CMDeviceMotion</code> instance that we receive in our handler. The code is very similar to our first example:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">if</span> manager<span class="pl-k">.</span>deviceMotionAvailable {
    manager<span class="pl-k">.</span>deviceMotionUpdateInterval <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">01</span>
    manager<span class="pl-k">.</span>startDeviceMotionUpdatesToQueue(NSOperationQueue<span class="pl-k">.</span>mainQueue()) {
        [<span class="pl-k">weak</span> <span class="pl-k">self</span>] (data: CMDeviceMotion?, error: NSError?) {
        <span class="pl-k">if</span> <span class="pl-k">let</span> gravity <span class="pl-k">=</span> data?<span class="pl-k">.</span>gravity {
            <span class="pl-k">let</span> rotation <span class="pl-k">=</span> atan2(data<span class="pl-k">.</span>gravity<span class="pl-k">.</span>x, data<span class="pl-k">.</span>gravity<span class="pl-k">.</span>y) <span class="pl-k">-</span> M_PI
            <span class="pl-k">self</span>?<span class="pl-k">.</span>imageView<span class="pl-k">.</span>transform <span class="pl-k">=</span> CGAffineTransformMakeRotation(CGFloat(rotation))
        }
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>RotationViewController * __weak weakSelf = self;
<span class="pl-k">if</span> (manager.deviceMotionAvailable) {
    manager.<span class="pl-smi">deviceMotionUpdateInterval</span> = <span class="pl-c1">0</span>.<span class="pl-c1">01f</span>;
    [manager <span class="pl-c1">startDeviceMotionUpdatesToQueue:</span>[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">mainQueue</span>]
                                       <span class="pl-c1">withHandler:</span>^(CMDeviceMotion *data, <span class="pl-c1">NSError</span> *error) {
        <span class="pl-k">double</span> rotation = <span class="pl-c1">atan2</span>(data.<span class="pl-smi">gravity</span>.<span class="pl-smi">x</span>, data.<span class="pl-smi">gravity</span>.<span class="pl-smi">y</span>) - M_PI;
        weakSelf.<span class="pl-smi">imageView</span>.<span class="pl-smi">transform</span> = <span class="pl-c1">CGAffineTransformMakeRotation</span>(rotation);
    }];
}</pre></div>

<p>Much better!</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/cmdm-gravity.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/cmdm-gravity.gif" alt="Rotation with gravity" style="max-width:100%;"></a></p>

<h2><a id="user-content-uiclunkcontroller" class="anchor" href="#uiclunkcontroller" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UIClunkController</h2>

<p>We can also use the other, non-gravity portion of this composited gyro/acceleration data to add new methods of interaction. In this case, let's use the <code>userAcceleration</code> property of <code>CMDeviceMotion</code> to navigate backward whenever a user taps the left side of her device against her hand.</p>

<p>Remember that the X-axis runs laterally through the device in our hand, with negative values to the left. If we sense a <em>user</em> acceleration to the left of more than 2.5 Gs, that will be the cue to pop our view controller from the stack. The implementation is only a couple lines different from our previous example:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">if</span> manager<span class="pl-k">.</span>deviceMotionAvailable {
    manager<span class="pl-k">.</span>deviceMotionUpdateInterval <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">02</span>
    manager<span class="pl-k">.</span>startDeviceMotionUpdatesToQueue(NSOperationQueue<span class="pl-k">.</span>mainQueue()) {
        [<span class="pl-k">weak</span> <span class="pl-k">self</span>] (data: CMDeviceMotion?, error: NSError?) <span class="pl-k">in</span>

        <span class="pl-k">if</span> data?<span class="pl-k">.</span>userAcceleration<span class="pl-k">.</span>x <span class="pl-k">&lt;</span> <span class="pl-c1">-2</span><span class="pl-k">.</span><span class="pl-c1">5</span> {
            <span class="pl-k">self</span>?<span class="pl-k">.</span>navigationController?<span class="pl-k">.</span>popViewControllerAnimated(<span class="pl-c1">true</span>)
        }
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>ClunkViewController * __weak weakSelf = self;
<span class="pl-k">if</span> (manager.deviceMotionAvailable) {
    manager.<span class="pl-smi">deviceMotionUpdateInterval</span> = <span class="pl-c1">0</span>.<span class="pl-c1">01f</span>;
    [manager <span class="pl-c1">startDeviceMotionUpdatesToQueue:</span>[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">mainQueue</span>]
                                       <span class="pl-c1">withHandler:</span>^(CMDeviceMotion *data, <span class="pl-c1">NSError</span> *error) {
        <span class="pl-k">if</span> (data.<span class="pl-smi">userAcceleration</span>.<span class="pl-smi">x</span> &lt; -<span class="pl-c1">2</span>.<span class="pl-c1">5f</span>) {
            [weakSelf.navigationController <span class="pl-c1">popViewControllerAnimated:</span><span class="pl-c1">YES</span>];
        }
    }];
}</pre></div>

<p>And it works like a charm—tapping the device in a detail view immediately takes us back to the list of exhibits:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/cmdm-clunk.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/cmdm-clunk.gif" alt="Clunk to go back" style="max-width:100%;"></a></p>

<h2><a id="user-content-getting-an-attitude" class="anchor" href="#getting-an-attitude" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting an Attitude</h2>

<p>Better acceleration data isn't the only thing we gain by including gyroscope data—we now also know the device's true orientation in space. We find this data in the <code>attitude</code> property of <code>CMDeviceMotion</code>, an instance of <code>CMAttitude</code>. <code>CMAttitude</code> contains three different representations of the device's orientation: Euler angles, a quaternion, and a rotation matrix. Each of these is in relation to a given reference frame.</p>

<h3><a id="user-content-finding-a-frame-of-reference" class="anchor" href="#finding-a-frame-of-reference" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Finding a Frame of Reference</h3>

<p>You can think of a reference frame as the resting orientation of the device from which an attitude is calculated. All four possible reference frames describe the device laying flat on a table, with increasing specificity about the direction it's pointing.</p>

<ul>
<li><code>CMAttitudeReferenceFrameXArbitraryZVertical</code> describes a device laying flat (vertical Z-axis) with an "arbitrary" X-axis. In practice, the X-axis is fixed to the orientation of the device when you <em>first</em> start device motion updates.</li>
<li><code>CMAttitudeReferenceFrameXArbitraryCorrectedZVertical</code> is essentially the same but uses the magnetometer to correct possible variation in the gyroscope's measurement over time. Using the magnetometer adds a CPU (and therefore battery) cost.</li>
<li><code>CMAttitudeReferenceFrameXMagneticNorthZVertical</code> describes a device laying flat, with its X-axis (i.e., the right side of the device) pointed toward magnetic north. This setting may require your user to perform that figure-eight motion with their device to calibrate the magnetometer.</li>
<li><code>CMAttitudeReferenceFrameXTrueNorthZVertical</code> is the same as the last, but this adjusts for the magnetic/true north discrepancy and therefore requires location data in addition to the magnetometer.</li>
</ul>

<p>For our purposes, the default "arbitrary" reference frame will be fine - you'll see why in a moment.</p>

<h3><a id="user-content-euler-angles" class="anchor" href="#euler-angles" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Euler Angles</h3>

<p>Of the three attitude representations, Euler angles are the most readily understood, as they simply describe rotation around each of the axes we've already been working with. <code>pitch</code> is rotation around the X-axis, increasing as the device tilts toward you, decreasing as it tilts away; <code>roll</code> is rotation around the Y-axis, decreasing as the device rotates to the left, increasing to the right; and <code>yaw</code> is rotation around the (vertical) Z-axis, decreasing clockwise, increasing counter-clockwise.</p>

<blockquote>
<p>Each of these values follows what's called the "right hand rule": make a cupped hand with your thumb pointing up and point your thumb in the direction of any of the three axes. Turns that move toward your fingertips are positive, turns away are negative.</p>
</blockquote>

<h3><a id="user-content-keep-it-to-yourself" class="anchor" href="#keep-it-to-yourself" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Keep It To Yourself</h3>

<p>Lastly, let's try using the device's attitude to enable a new interaction for a flash-card app, designed to be used by two study buddies. Instead of manually switching between the prompt and the answer, we'll automatically switch the view as the device turns around, so the quizzer sees the answer while the person being quizzed only sees the prompt.</p>

<p>Figuring out this switch from the reference frame would be tricky. To know which angles to monitor, we would somehow need to take into account the starting orientation of the device and then determine which direction the device is pointing. Instead, we can save a <code>CMAttitude</code> instance and use it as the "zero point" for an adjusted set of Euler angles, calling the <code>multiplyByInverseOfAttitude()</code> method to translate all future attitude updates.</p>

<p>When the quizzer taps the button to begin the quiz, we first configure the interaction—note the "pull" of the deviceMotion for <code>initialAttitude</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// get magnitude of vector via Pythagorean theorem</span>
<span class="pl-k">func</span> <span class="pl-en">magnitudeFromAttitude</span>(attitude: CMAttitude) <span class="pl-k">-&gt;</span> <span class="pl-c1">Double</span> {
    <span class="pl-k">return</span> sqrt(pow(attitude<span class="pl-k">.</span>roll, <span class="pl-c1">2</span>) <span class="pl-k">+</span> pow(attitude<span class="pl-k">.</span>yaw, <span class="pl-c1">2</span>) <span class="pl-k">+</span> pow(attitude<span class="pl-k">.</span>pitch, <span class="pl-c1">2</span>))
}

<span class="pl-c">// initial configuration</span>
<span class="pl-k">var</span> initialAttitude <span class="pl-k">=</span> manager<span class="pl-k">.</span>deviceMotion<span class="pl-k">!.</span>attitude
<span class="pl-k">var</span> showingPrompt <span class="pl-k">=</span> <span class="pl-c1">false</span>

<span class="pl-c">// trigger values - a gap so there isn't a flicker zone</span>
<span class="pl-k">let</span> showPromptTrigger <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">0</span>
<span class="pl-k">let</span> showAnswerTrigger <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">8</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// --- class method to get magnitude of vector via Pythagorean theorem</span>
+ (<span class="pl-k">double</span>)magnitudeFromAttitude:(CMAttitude *)attitude {
    <span class="pl-k">return</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">pow</span>(attitude.<span class="pl-smi">roll</span>, <span class="pl-c1">2</span>.<span class="pl-c1">0f</span>) + <span class="pl-c1">pow</span>(attitude.<span class="pl-smi">yaw</span>, <span class="pl-c1">2</span>.<span class="pl-c1">0f</span>) + <span class="pl-c1">pow</span>(attitude.<span class="pl-smi">pitch</span>, <span class="pl-c1">2</span>.<span class="pl-c1">0f</span>));
}

<span class="pl-c">// --- In @IBAction handler</span>
<span class="pl-c">// initial configuration</span>
CMAttitude *initialAttitude = manager.deviceMotion.attitude;
__block <span class="pl-c1">BOOL</span> showingPrompt = <span class="pl-c1">NO</span>;

<span class="pl-c">// trigger values - a gap so there isn't a flicker zone</span>
<span class="pl-k">double</span> showPromptTrigger = <span class="pl-c1">1</span>.<span class="pl-c1">0f</span>;
<span class="pl-k">double</span> showAnswerTrigger = <span class="pl-c1">0</span>.<span class="pl-c1">8f</span>;</pre></div>

<p>Then, in our now familiar call to <code>startDeviceMotionUpdates</code>, we calculate the magnitude of the vector described by the three Euler angles and use that as a trigger to show or hide the prompt view:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">if</span> manager<span class="pl-k">.</span>deviceMotionAvailable {
    manager<span class="pl-k">.</span>startDeviceMotionUpdatesToQueue(NSOperationQueue<span class="pl-k">.</span>mainQueue()) {
        [<span class="pl-k">weak</span> <span class="pl-k">self</span>] (data: CMDeviceMotion?, error: NSError?) <span class="pl-k">in</span>

        <span class="pl-k">guard</span> <span class="pl-k">let</span> data <span class="pl-k">=</span> data <span class="pl-k">else</span> { <span class="pl-k">return</span> }

        <span class="pl-c">// translate the attitude</span>
        data<span class="pl-k">.</span>attitude<span class="pl-k">.</span>multiplyByInverseOfAttitude(initialAttitude)

        <span class="pl-c">// calculate magnitude of the change from our initial attitude</span>
        <span class="pl-k">let</span> magnitude <span class="pl-k">=</span> magnitudeFromAttitude(data<span class="pl-k">.</span>attitude) <span class="pl-k">??</span> <span class="pl-c1">0</span>

        <span class="pl-c">// show the prompt</span>
        <span class="pl-k">if</span> <span class="pl-k">!</span>showingPrompt <span class="pl-k">&amp;&amp;</span> magnitude <span class="pl-k">&gt;</span> showPromptTrigger {
            <span class="pl-k">if</span> <span class="pl-k">let</span> promptViewController <span class="pl-k">=</span> <span class="pl-k">self</span>?<span class="pl-k">.</span>storyboard?<span class="pl-k">.</span>instantiateViewControllerWithIdentifier(<span class="pl-s"><span class="pl-pds">"</span>PromptViewController<span class="pl-pds">"</span></span>) <span class="pl-k">as?</span> PromptViewController {
                showingPrompt <span class="pl-k">=</span> <span class="pl-c1">true</span>

                promptViewController<span class="pl-k">.</span>modalTransitionStyle <span class="pl-k">=</span> UIModalTransitionStyle<span class="pl-k">.</span>CrossDissolve
                <span class="pl-k">self</span>?<span class="pl-k">.</span>presentViewController(promptViewController, animated: <span class="pl-c1">true</span>, completion: <span class="pl-c1">nil</span>)
            }
        }

        <span class="pl-c">// hide the prompt</span>
        <span class="pl-k">if</span> showingPrompt <span class="pl-k">&amp;&amp;</span> magnitude <span class="pl-k">&lt;</span> showAnswerTrigger {
            showingPrompt <span class="pl-k">=</span> <span class="pl-c1">false</span>
            <span class="pl-k">self</span>?<span class="pl-k">.</span>dismissViewControllerAnimated(<span class="pl-c1">true</span>, completion: <span class="pl-c1">nil</span>)
        }
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>FacingViewController * __weak weakSelf = self;
<span class="pl-k">if</span> (manager.deviceMotionAvailable) {
    [manager <span class="pl-c1">startDeviceMotionUpdatesToQueue:</span>[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">mainQueue</span>]
                                       <span class="pl-c1">withHandler:</span>^(CMDeviceMotion *data, <span class="pl-c1">NSError</span> *error) {

        <span class="pl-c">// translate the attitude</span>
        [data.attitude <span class="pl-c1">multiplyByInverseOfAttitude:</span>initialAttitude];

        <span class="pl-c">// calculate magnitude of the change from our initial attitude</span>
        <span class="pl-k">double</span> magnitude = [FacingViewController <span class="pl-c1">magnitudeFromAttitude:</span>data.attitude];

        <span class="pl-c">// show the prompt</span>
        <span class="pl-k">if</span> (!showingPrompt &amp;&amp; (magnitude &gt; showPromptTrigger)) {
            showingPrompt = <span class="pl-c1">YES</span>;

            PromptViewController *promptViewController = [weakSelf.storyboard <span class="pl-c1">instantiateViewControllerWithIdentifier:</span><span class="pl-s"><span class="pl-pds">@"</span>PromptViewController<span class="pl-pds">"</span></span>];
            promptViewController.<span class="pl-smi">modalTransitionStyle</span> = UIModalTransitionStyleCrossDissolve;
            [weakSelf <span class="pl-c1">presentViewController:</span>promptViewController <span class="pl-c1">animated:</span><span class="pl-c1">YES</span> <span class="pl-c1">completion:</span><span class="pl-c1">nil</span>];
        }

        <span class="pl-c">// hide the prompt</span>
        <span class="pl-k">if</span> (showingPrompt &amp;&amp; (magnitude &lt; showAnswerTrigger)) {
            showingPrompt = <span class="pl-c1">NO</span>;
            [weakSelf <span class="pl-c1">dismissViewControllerAnimated:</span><span class="pl-c1">YES</span> <span class="pl-c1">completion:</span><span class="pl-c1">nil</span>];
        }
    }];
}</pre></div>

<p>Having implemented all that, let's take a look at the interaction. As the device rotates, the display automatically switches views and the quizee never sees the answer:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/cmdm-prompt.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/cmdm-prompt.gif" alt="Prompt by turning the device" style="max-width:100%;"></a></p>

<h3><a id="user-content-further-reading" class="anchor" href="#further-reading" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Further Reading</h3>

<p>I skimmed over the <a href="http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">quaternion</a> and <a href="http://en.wikipedia.org/wiki/Rotation_matrix">rotation matrix</a> components of <code>CMAttitude</code> earlier, but they are not without intrigue. The quaternion, in particular, has <a href="http://en.wikipedia.org/wiki/History_of_quaternions">an interesting history</a>, and will bake your noodle if you think about it long enough.</p>

<h2><a id="user-content-queueing-up" class="anchor" href="#queueing-up" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Queueing Up</h2>

<p>To keep the code examples readable, we've been sending all our <code>CoreMotionManager</code> updates to the main queue. As a best practice, it would be better to have these updates on their own queue so they can't slow down user interaction, but then we'll need to get back on the main queue to update user interface elements. <a href="http://nshipster.com/nsoperation/"><code>NSOperationQueue</code></a> makes this easy with its <code>addOperationWithBlock</code> method:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> queue <span class="pl-k">=</span> NSOperationQueue()
manager<span class="pl-k">.</span>startDeviceMotionUpdatesToQueue(queue) {
    [<span class="pl-k">weak</span> <span class="pl-k">self</span>] (data: CMDeviceMotion?, error: NSError?) <span class="pl-k">in</span>

    <span class="pl-c">// motion processing here</span>

    NSOperationQueue<span class="pl-k">.</span>mainQueue()<span class="pl-k">.</span>addOperationWithBlock {
        <span class="pl-c">// update UI here</span>
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSOperationQueue</span> *queue = [[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
[manager <span class="pl-c1">startDeviceMotionUpdatesToQueue:</span>queue
                             <span class="pl-c1">withHandler:</span>
^(CMDeviceMotion *data, <span class="pl-c1">NSError</span> *error) {
    <span class="pl-c">// motion processing here</span>

    [[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">mainQueue</span>] <span class="pl-c1">addOperationWithBlock:</span>^{
        <span class="pl-c">// update UI here</span>
    }];
}];</pre></div>

<hr>

<p>As a final note, clearly not all interactions made possible by Core Motion are good ones. Navigation through motion can be fun but also hard to discover or easy to accidentally trigger; purposeless animations can make it harder to focus on the task at hand. Prudent developers will skip over gimmicks that distract and find ways to use device motion that enrich their apps and delight their users.</p>
</article></div>