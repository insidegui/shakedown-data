<div class="announce instapaper_body md" data-path="2013-07-15-nspredicate.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSPredicate</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>nshipster, popular</div></td>

  <td><div>NSPredicate is a Foundation class that specifies how data should be fetched or filtered. Its query language, which is like a cross between a SQL WHERE clause and a regular expression, provides an expressive, natural language interface to define logical conditions on which a collection is searched.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>September 19, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p><code>NSPredicate</code> is a Foundation class that specifies how data should be fetched or filtered. Its query language, which is like a cross between a SQL <code>WHERE</code> clause and a regular expression, provides an expressive, natural language interface to define logical conditions on which a collection is searched.</p>

<p>It's easier to show <code>NSPredicate</code> in use, rather than talk about it in the abstract, so we're going to revisit the example data set used in the <a href="http://nshipster.com/nssortdescriptor/"><code>NSSortDescriptor</code> article</a>:</p>

<table><thead>
<tr>
<th><code>firstName</code></th>
<th><code>lastName</code></th>
<th><code>age</code></th>
</tr>
</thead><tbody>
<tr>
<td>Alice</td>
<td>Smith</td>
<td>24</td>
</tr>
<tr>
<td>Bob</td>
<td>Jones</td>
<td>27</td>
</tr>
<tr>
<td>Charlie</td>
<td>Smith</td>
<td>33</td>
</tr>
<tr>
<td>Quentin</td>
<td>Alberts</td>
<td>31</td>
</tr>
</tbody></table>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> Person: NSObject {
    <span class="pl-k">let</span> firstName: <span class="pl-c1">String</span>
    <span class="pl-k">let</span> lastName: <span class="pl-c1">String</span>
    <span class="pl-k">let</span> age: <span class="pl-c1">Int</span>

    <span class="pl-k">init</span>(firstName: <span class="pl-c1">String</span>, lastName: <span class="pl-c1">String</span>, age: <span class="pl-c1">Int</span>) {
        <span class="pl-k">self</span><span class="pl-k">.</span>firstName <span class="pl-k">=</span> firstName
        <span class="pl-k">self</span><span class="pl-k">.</span>lastName <span class="pl-k">=</span> lastName
        <span class="pl-k">self</span><span class="pl-k">.</span>age <span class="pl-k">=</span> age
    }

    <span class="pl-k">override</span> <span class="pl-k">var</span> description: <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">firstName</span><span class="pl-pse">)</span> <span class="pl-pse">\(</span><span class="pl-s1">lastName</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>
    }
}

<span class="pl-k">let</span> alice <span class="pl-k">=</span> Person(firstName: <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>, lastName: <span class="pl-s"><span class="pl-pds">"</span>Smith<span class="pl-pds">"</span></span>, age: <span class="pl-c1">24</span>)
<span class="pl-k">let</span> bob <span class="pl-k">=</span> Person(firstName: <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>, lastName: <span class="pl-s"><span class="pl-pds">"</span>Jones<span class="pl-pds">"</span></span>, age: <span class="pl-c1">27</span>)
<span class="pl-k">let</span> charlie <span class="pl-k">=</span> Person(firstName: <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span>, lastName: <span class="pl-s"><span class="pl-pds">"</span>Smith<span class="pl-pds">"</span></span>, age: <span class="pl-c1">33</span>)
<span class="pl-k">let</span> quentin <span class="pl-k">=</span> Person(firstName: <span class="pl-s"><span class="pl-pds">"</span>Quentin<span class="pl-pds">"</span></span>, lastName: <span class="pl-s"><span class="pl-pds">"</span>Alberts<span class="pl-pds">"</span></span>, age: <span class="pl-c1">31</span>)
<span class="pl-k">let</span> people <span class="pl-k">=</span> [alice, bob, charlie, quentin]

<span class="pl-k">let</span> bobPredicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>firstName = 'Bob'<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> smithPredicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>lastName = %@<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Smith<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> thirtiesPredicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>age &gt;= 30<span class="pl-pds">"</span></span>)

(people <span class="pl-k">as</span> NSArray)<span class="pl-k">.</span>filteredArrayUsingPredicate(bobPredicate)
<span class="pl-c">// ["Bob Jones"]</span>

(people <span class="pl-k">as</span> NSArray)<span class="pl-k">.</span>filteredArrayUsingPredicate(smithPredicate)
<span class="pl-c">// ["Alice Smith", "Charlie Smith"]</span>

(people <span class="pl-k">as</span> NSArray)<span class="pl-k">.</span>filteredArrayUsingPredicate(thirtiesPredicate)
<span class="pl-c">// ["Charlie Smith", "Quentin Alberts"]</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">@interface</span> <span class="pl-en">Person</span> : <span class="pl-e">NSObject</span>
<span class="pl-k">@property</span> <span class="pl-c1">NSString</span> *firstName;
<span class="pl-k">@property</span> <span class="pl-c1">NSString</span> *lastName;
<span class="pl-k">@property</span> <span class="pl-c1">NSNumber</span> *age;
<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">Person</span>

- (<span class="pl-c1">NSString</span> *)<span class="pl-en">description</span> {
    <span class="pl-k">return</span> [<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span> <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, <span class="pl-v">self</span>.firstName, <span class="pl-v">self</span>.lastName];
}

<span class="pl-k">@end</span>

#<span class="pl-k">pragma mark</span> -

<span class="pl-c1">NSArray</span> *firstNames = @[ <span class="pl-s"><span class="pl-pds">@"</span>Alice<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Bob<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Charlie<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Quentin<span class="pl-pds">"</span></span> ];
<span class="pl-c1">NSArray</span> *lastNames = @[ <span class="pl-s"><span class="pl-pds">@"</span>Smith<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Jones<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Smith<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Alberts<span class="pl-pds">"</span></span> ];
<span class="pl-c1">NSArray</span> *ages = @[ @<span class="pl-c1">24</span>, @<span class="pl-c1">27</span>, @<span class="pl-c1">33</span>, @<span class="pl-c1">31</span> ];

<span class="pl-c1">NSMutableArray</span> *people = [<span class="pl-c1">NSMutableArray</span> <span class="pl-c1">array</span>];
[firstNames <span class="pl-c1">enumerateObjectsUsingBlock:</span>^(<span class="pl-c1">id</span> obj, <span class="pl-c1">NSUInteger</span> idx, <span class="pl-c1">BOOL</span> *stop) {
    Person *person = [[Person <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
    person.<span class="pl-smi">firstName</span> = firstNames[idx];
    person.<span class="pl-smi">lastName</span> = lastNames[idx];
    person.<span class="pl-smi">age</span> = ages[idx];
    [people <span class="pl-c1">addObject:</span>person];
}];

<span class="pl-c1">NSPredicate</span> *bobPredicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>firstName = 'Bob'<span class="pl-pds">"</span></span>];
<span class="pl-c1">NSPredicate</span> *smithPredicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>lastName = %@<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Smith<span class="pl-pds">"</span></span>];
<span class="pl-c1">NSPredicate</span> *thirtiesPredicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>age &gt;= 30<span class="pl-pds">"</span></span>];

<span class="pl-c">// ["Bob Jones"]</span>
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Bobs: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [people <span class="pl-c1">filteredArrayUsingPredicate:</span>bobPredicate]);

<span class="pl-c">// ["Alice Smith", "Charlie Smith"]</span>
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Smiths: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [people <span class="pl-c1">filteredArrayUsingPredicate:</span>smithPredicate]);

<span class="pl-c">// ["Charlie Smith", "Quentin Alberts"]</span>
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>30's: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [people <span class="pl-c1">filteredArrayUsingPredicate:</span>thirtiesPredicate]);</pre></div>

<h2><a id="user-content-using-nspredicate-with-collections" class="anchor" href="#using-nspredicate-with-collections" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using <code>NSPredicate</code> with Collections</h2>

<p>Foundation provides methods to filter <code>NSArray</code> / <code>NSMutableArray</code> &amp; <code>NSSet</code> / <code>NSMutableSet</code> with predicates.</p>

<p>Immutable collections, <code>NSArray</code> &amp; <code>NSSet</code>, have the methods <code>filteredArrayUsingPredicate:</code> and <code>filteredSetUsingPredicate:</code> which return an immutable collection by evaluating a predicate on the receiver.</p>

<p>Mutable collections, <code>NSMutableArray</code> &amp; <code>NSMutableSet</code> have the method <code>filterUsingPredicate:</code>, which removes any objects that evaluate to <code>FALSE</code> when running the predicate on the receiver.</p>

<p><code>NSDictionary</code> can use predicates by filtering its keys or values (both <code>NSArray</code> objects). <code>NSOrderedSet</code> can either create new ordered sets from a filtered <code>NSArray</code> or <code>NSSet</code>, or alternatively, <code>NSMutableSet</code> can simply <code>removeObjectsInArray:</code>, passing objects filtered with the <em>negated</em> predicate.</p>

<h2><a id="user-content-using-nspredicate-with-core-data" class="anchor" href="#using-nspredicate-with-core-data" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using <code>NSPredicate</code> with Core Data</h2>

<p><code>NSFetchRequest</code> has a <code>predicate</code> property, which specifies the logical conditions under which managed objects should be retrieved. The same rules apply, except that predicates are evaluated by the persistent store coordinator within a managed object context, rather than collections being filtered in-memory.</p>

<h2><a id="user-content-predicate-syntax" class="anchor" href="#predicate-syntax" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Predicate Syntax</h2>

<h3><a id="user-content-substitutions" class="anchor" href="#substitutions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Substitutions</h3>

<blockquote>
<ul>
<li><code>%@</code> is a var arg substitution for an object value—often a string, number, or date.</li>
<li><code>%K</code> is a var arg substitution for a key path.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> ageIs33Predicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>%K = %@<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>33<span class="pl-pds">"</span></span>)

(people <span class="pl-k">as</span> NSArray)<span class="pl-k">.</span>filteredArrayUsingPredicate(ageIs33Predicate)
<span class="pl-c">// ["Charlie Smith"]</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSPredicate</span> *ageIs33Predicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>%K = %@<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>age<span class="pl-pds">"</span></span>, @<span class="pl-c1">33</span>];

<span class="pl-c">// ["Charlie Smith"]</span>
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Age 33: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [people <span class="pl-c1">filteredArrayUsingPredicate:</span>ageIs33Predicate]);</pre></div>

<blockquote>
<ul>
<li><code>$VARIABLE_NAME</code> is a value that can be substituted with <code>NSPredicate -predicateWithSubstitutionVariables:</code>.</li>
</ul>
</blockquote>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> namesBeginningWithLetterPredicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>(firstName BEGINSWITH[cd] $letter) OR (lastName BEGINSWITH[cd] $letter)<span class="pl-pds">"</span></span>)

(people <span class="pl-k">as</span> NSArray)<span class="pl-k">.</span>filteredArrayUsingPredicate(namesBeginningWithLetterPredicate<span class="pl-k">.</span>predicateWithSubstitutionVariables([<span class="pl-s"><span class="pl-pds">"</span>letter<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>]))
<span class="pl-c">// ["Alice Smith", "Quentin Alberts"]</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSPredicate</span> *namesBeginningWithLetterPredicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>(firstName <span class="pl-k">BEGINSWITH</span>[cd] $letter) <span class="pl-k">OR</span> (lastName <span class="pl-k">BEGINSWITH</span>[cd] $letter)<span class="pl-pds">"</span></span>];

<span class="pl-c">// ["Alice Smith", "Quentin Alberts"]</span>
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>'A' Names: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [people <span class="pl-c1">filteredArrayUsingPredicate:</span>[namesBeginningWithLetterPredicate <span class="pl-c1">predicateWithSubstitutionVariables:</span>@{<span class="pl-s"><span class="pl-pds">@"</span>letter<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">@"</span>A<span class="pl-pds">"</span></span>}]]);</pre></div>

<h3><a id="user-content-basic-comparisons" class="anchor" href="#basic-comparisons" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basic Comparisons</h3>

<blockquote>
<ul>
<li><code>=</code>, <code>==</code>: The left-hand expression is equal to the right-hand expression.</li>
<li><code>&gt;=</code>, <code>=&gt;</code>: The left-hand expression is greater than or equal to the right-hand expression.</li>
<li><code>&lt;=</code>, <code>=&lt;</code>: The left-hand expression is less than or equal to the right-hand expression.</li>
<li><code>&gt;</code>: The left-hand expression is greater than the right-hand expression.</li>
<li><code>&lt;</code>: The left-hand expression is less than the right-hand expression.</li>
<li><code>!=</code>, <code>&lt;&gt;</code>: The left-hand expression is not equal to the right-hand expression.</li>
<li><code>BETWEEN</code>: The left-hand expression is between, or equal to either of, the values specified in the right-hand side. The right-hand side is a two value array (an array is required to specify order) giving upper and lower bounds. For example, <code>1 BETWEEN { 0 , 33 }</code>, or <code>$INPUT BETWEEN { $LOWER, $UPPER }</code>.</li>
</ul>
</blockquote>

<h3><a id="user-content-basic-compound-predicates" class="anchor" href="#basic-compound-predicates" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basic Compound Predicates</h3>

<blockquote>
<ul>
<li><code>AND</code>, <code>&amp;&amp;</code>: Logical <code>AND</code>.</li>
<li><code>OR</code>, <code>||</code>: Logical <code>OR</code>.</li>
<li><code>NOT</code>, <code>!</code>: Logical <code>NOT</code>.</li>
</ul>
</blockquote>

<h3><a id="user-content-string-comparisons" class="anchor" href="#string-comparisons" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>String Comparisons</h3>

<blockquote>
<p>String comparisons are by default case and diacritic sensitive. You can modify an operator using the key characters c and d within square braces to specify case and diacritic insensitivity respectively, for example firstName BEGINSWITH[cd] $FIRST_NAME.</p>

<ul>
<li><code>BEGINSWITH</code>: The left-hand expression begins with the right-hand expression.</li>
<li><code>CONTAINS</code>: The left-hand expression contains the right-hand expression.</li>
<li><code>ENDSWITH</code>: The left-hand expression ends with the right-hand expression.</li>
<li><code>LIKE</code>: The left hand expression equals the right-hand expression: <code>?</code> and <code>*</code> are allowed as wildcard characters, where <code>?</code> matches 1 character and <code>*</code> matches 0 or more characters.</li>
<li><code>MATCHES</code>:  The left hand expression equals the right hand expression using a regex-style comparison according to ICU v3 (for more details see the <a href="http://userguide.icu-project.org/strings/regexp">ICU User Guide for Regular Expressions</a>).</li>
</ul>
</blockquote>

<h3><a id="user-content-aggregate-operations" class="anchor" href="#aggregate-operations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aggregate Operations</h3>

<h4><a id="user-content-relational-operations" class="anchor" href="#relational-operations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Relational Operations</h4>

<blockquote>
<ul>
<li><code>ANY</code>, <code>SOME</code>: Specifies any of the elements in the following expression. For example, <code>ANY children.age &lt; 18</code>.</li>
<li><code>ALL</code>: Specifies all of the elements in the following expression. For example, <code>ALL children.age &lt; 18</code>.</li>
<li><code>NONE</code>: Specifies none of the elements in the following expression. For example, <code>NONE children.age &lt; 18</code>. This is logically equivalent to <code>NOT (ANY ...)</code>.</li>
<li><code>IN</code>: Equivalent to an SQL <code>IN</code> operation, the left-hand side must appear in the collection specified by the right-hand side. For example, <code>name IN { 'Ben', 'Melissa', 'Nick' }</code>.</li>
</ul>
</blockquote>

<h4><a id="user-content-array-operations" class="anchor" href="#array-operations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array Operations</h4>

<blockquote>
<ul>
<li><code>array[index]</code>: Specifies the element at the specified index in <code>array</code>.</li>
<li><code>array[FIRST]</code>: Specifies the first element in <code>array</code>.</li>
<li><code>array[LAST]</code>: Specifies the last element in <code>array</code>.</li>
<li><code>array[SIZE]</code>: Specifies the size of <code>array</code>.</li>
</ul>
</blockquote>

<h3><a id="user-content-boolean-value-predicates" class="anchor" href="#boolean-value-predicates" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Boolean Value Predicates</h3>

<blockquote>
<ul>
<li><code>TRUEPREDICATE</code>: A predicate that always evaluates to <code>TRUE</code>.</li>
<li><code>FALSEPREDICATE</code>: A predicate that always evaluates to <code>FALSE</code>.</li>
</ul>
</blockquote>

<h2><a id="user-content-nscompoundpredicate" class="anchor" href="#nscompoundpredicate" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSCompoundPredicate</code></h2>

<p>We saw that <code>AND</code> &amp; <code>OR</code> can be used in predicate format strings to create compound predicates. However, the same can be accomplished using an <code>NSCompoundPredicate</code>.</p>

<p>For example, the following predicates are equivalent:</p>

<div class="highlight highlight-source-swift"><pre>NSCompoundPredicate(type: <span class="pl-k">.</span>AndPredicateType, subpredicates: [NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>age &gt; 25<span class="pl-pds">"</span></span>), NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>firstName = %@<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Quentin<span class="pl-pds">"</span></span>)])

NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>(age &gt; 25) AND (firstName = %@)<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Quentin<span class="pl-pds">"</span></span>)</pre></div>

<div class="highlight highlight-source-objc"><pre>[<span class="pl-c1">NSCompoundPredicate</span> <span class="pl-c1">andPredicateWithSubpredicates:</span>@[[<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>age &gt; 25<span class="pl-pds">"</span></span>], [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>firstName = %@<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Quentin<span class="pl-pds">"</span></span>]]];

[<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>(age &gt; 25) <span class="pl-k">AND</span> (firstName = %@)<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Quentin<span class="pl-pds">"</span></span>];</pre></div>

<p>While the syntax string literal is certainly easier to type, there are occasions where you may need to combine existing predicates. In these cases, <code>NSCompoundPredicate -andPredicateWithSubpredicates:</code> &amp; <code>-orPredicateWithSubpredicates:</code> is the way to go.</p>

<h2><a id="user-content-nscomparisonpredicate" class="anchor" href="#nscomparisonpredicate" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSComparisonPredicate</code></h2>

<p>Similarly, if after reading <a href="http://nshipster.com/nsexpression/">last week's article</a> you now find yourself with more <code>NSExpression</code> objects than you know what to do with, <code>NSComparisonPredicate</code> can help you out.</p>

<p>Like <code>NSCompoundPredicate</code>, <code>NSComparisonPredicate</code> constructs an <code>NSPredicate</code> from subcomponents—in this case, <code>NSExpression</code>s on the left and right hand sides.
Analyzing its class constructor provides a glimpse into the way <code>NSPredicate</code> format strings are parsed:</p>

<div class="highlight highlight-source-objc"><pre>+ (<span class="pl-c1">NSPredicate</span> *)predicateWithLeftExpression:(<span class="pl-c1">NSExpression</span> *)lhs
                             rightExpression:(<span class="pl-c1">NSExpression</span> *)rhs
                                    modifier:(<span class="pl-c1">NSComparisonPredicateModifier</span>)modifier
                                        type:(<span class="pl-c1">NSPredicateOperatorType</span>)type
                                     options:(<span class="pl-c1">NSUInteger</span>)options</pre></div>

<h4><a id="user-content-parameters" class="anchor" href="#parameters" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parameters</h4>

<blockquote>
<ul>
<li><code>lhs</code>: The left hand expression.</li>
<li><code>rhs</code>: The right hand expression.</li>
<li><code>modifier</code>: The modifier to apply. (<code>ANY</code> or <code>ALL</code>)</li>
<li><code>type</code>: The predicate operator type.</li>
<li><code>options</code>: The options to apply. For no options, pass <code>0</code>.</li>
</ul>
</blockquote>

<h3><a id="user-content-nscomparisonpredicate-types" class="anchor" href="#nscomparisonpredicate-types" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSComparisonPredicate</code> Types</h3>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">enum</span> NSPredicateOperatorType <span class="pl-k">:</span> <span class="pl-c1">UInt</span> {
    <span class="pl-k">case</span> LessThanPredicateOperatorType
    <span class="pl-k">case</span> LessThanOrEqualToPredicateOperatorType
    <span class="pl-k">case</span> GreaterThanPredicateOperatorType
    <span class="pl-k">case</span> GreaterThanOrEqualToPredicateOperatorType
    <span class="pl-k">case</span> EqualToPredicateOperatorType
    <span class="pl-k">case</span> NotEqualToPredicateOperatorType
    <span class="pl-k">case</span> MatchesPredicateOperatorType
    <span class="pl-k">case</span> LikePredicateOperatorType
    <span class="pl-k">case</span> BeginsWithPredicateOperatorType
    <span class="pl-k">case</span> EndsWithPredicateOperatorType
    <span class="pl-k">case</span> InPredicateOperatorType
    <span class="pl-k">case</span> CustomSelectorPredicateOperatorType
    <span class="pl-k">case</span> ContainsPredicateOperatorType
    <span class="pl-k">case</span> BetweenPredicateOperatorType
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">enum</span> {
   NSLessThanPredicateOperatorType = <span class="pl-c1">0</span>,
   NSLessThanOrEqualToPredicateOperatorType,
   NSGreaterThanPredicateOperatorType,
   NSGreaterThanOrEqualToPredicateOperatorType,
   NSEqualToPredicateOperatorType,
   NSNotEqualToPredicateOperatorType,
   NSMatchesPredicateOperatorType,
   NSLikePredicateOperatorType,
   NSBeginsWithPredicateOperatorType,
   NSEndsWithPredicateOperatorType,
   NSInPredicateOperatorType,
   NSCustomSelectorPredicateOperatorType,
   NSContainsPredicateOperatorType,
   NSBetweenPredicateOperatorType
};

<span class="pl-k">typedef</span> <span class="pl-c1">NSUInteger</span> <span class="pl-c1">NSPredicateOperatorType</span>;</pre></div>

<h3><a id="user-content-nscomparisonpredicate-options" class="anchor" href="#nscomparisonpredicate-options" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSComparisonPredicate</code> Options</h3>

<blockquote>
<ul>
<li><code>NSCaseInsensitivePredicateOption</code>: A case-insensitive predicate. You represent this option in a predicate format string using a [c] following a string operation (for example, "NeXT" like[c] "next").</li>
<li><code>NSDiacriticInsensitivePredicateOption</code>: A diacritic-insensitive predicate. You represent this option in a predicate format string using a [d] following a string operation (for example, "naïve" like[d] "naive").</li>
<li><code>NSNormalizedPredicateOption</code>: Indicates that the strings to be compared have been preprocessed. This option supersedes NSCaseInsensitivePredicateOption and NSDiacriticInsensitivePredicateOption, and is intended as a performance optimization option. You represent this option in a predicate format string using a [n] following a string operation (for example, "WXYZlan" matches[n] ".lan").</li>
<li><code>NSLocaleSensitivePredicateOption</code>: Indicates that strings to be compared using <code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>=&gt;</code>, <code>&gt;</code> should be handled in a locale-aware fashion. You represent this option in a predicate format string using a <code>[l]</code> following one of the <code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>=&gt;</code>, <code>&gt;</code> operators (for example, "straße" &gt;[l] "strasse").</li>
</ul>
</blockquote>

<h2><a id="user-content-block-predicates" class="anchor" href="#block-predicates" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Block Predicates</h2>

<p>Finally, if you just can't be bothered to learn the <code>NSPredicate</code> format syntax, you can go through the motions with <code>NSPredicate +predicateWithBlock:</code>.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> shortNamePredicate <span class="pl-k">=</span> NSPredicate { (evaluatedObject, _) <span class="pl-k">in</span>
    <span class="pl-k">return</span> (evaluatedObject <span class="pl-k">as!</span> Person)<span class="pl-k">.</span>firstName<span class="pl-k">.</span><span class="pl-c1">utf16</span><span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">5</span>
}

(people <span class="pl-k">as</span> NSArray)<span class="pl-k">.</span>filteredArrayUsingPredicate(shortNamePredicate)
<span class="pl-c">// ["Alice Smith", "Bob Jones"]</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSPredicate</span> *shortNamePredicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithBlock:</span>^<span class="pl-c1">BOOL</span>(<span class="pl-c1">id</span> evaluatedObject, <span class="pl-c1">NSDictionary</span> *bindings) {
            <span class="pl-k">return</span> [[evaluatedObject <span class="pl-c1">firstName</span>] <span class="pl-c1">length</span>] &lt;= <span class="pl-c1">5</span>;
        }];

<span class="pl-c">// ["Alice Smith", "Bob Jones"]</span>
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Short Names: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [people <span class="pl-c1">filteredArrayUsingPredicate:</span>shortNamePredicate]);</pre></div>

<p>...Alright, that whole dig on <code>predicateWithBlock:</code> as being the lazy way out wasn't <em>entirely</em> charitable.</p>

<p>Actually, since blocks can encapsulate any kind of calculation, there is a whole class of queries that can't be expressed with the <code>NSPredicate</code> format string (such as evaluating against values dynamically calculated at run-time). And while its possible to accomplish the same using an <code>NSExpression</code> with a custom selector, blocks provide a convenient interface to get the job done.</p>

<p>One important note: <strong><code>NSPredicate</code>s created with <code>predicateWithBlock:</code> cannot be used for Core Data fetch requests backed by a <code>SQLite</code> store.</strong></p>

<hr>

<p><code>NSPredicate</code> is, and I know this is said a lot, truly one of the jewels of Cocoa. Other languages would be lucky to have something with half of its capabilities in a third-party library—let alone the standard library. Having it as a standard-issue component affords us as application and framework developers an incredible amount of leverage in working with data.</p>

<p>Together with <code>NSExpression</code>, <code>NSPredicate</code> reminds us what a treat Foundation is: a framework that is not only incredibly useful, but meticulously architected and engineered, to be taken as inspiration for how we should write our own code.</p>
</article></div>