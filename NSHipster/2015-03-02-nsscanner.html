<div class="announce instapaper_body md" data-path="2015-03-02-nsscanner.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSScanner</div></td>

  <td><div>Nate Cook</div></td>

  <td><div>Cocoa</div></td>

  <td><div>Being able to pull apart strings and extract particular bits of data is a powerful skill, one that we use over and over building apps and shaping our tools. Cocoa provides a powerful set of frameworks to handle string processing. This week's article focuses on `NSScanner`, a highly configurable tool designed for extracting substrings and numeric values from loosely demarcated strings.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.2</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Strings are a ubiquitous and diverse part of our computing lives. They comprise emails and essays, poems and novels—and indeed, every article on <a href="http://nshipster.com">nshipster.com</a>, the configuration files that shape the site, and the code that builds it.</p>

<p>Being able to pull apart strings and extract particular bits of data is therefore a powerful skill, one that we use over and over building apps and shaping our tools.  Cocoa provides a powerful set of tools to handle string processing. In particular:</p>

<ul>
<li><p><strong><code>string.componentsSeparatedByCharactersInSet</code></strong> / <strong><code>string.componentsSeparatedByString</code></strong>: Great for splitting a string into constituent pieces. Not so great at anything else.</p></li>
<li><p><strong><code>NSRegularExpression</code></strong>: Powerful for validating and extracting string data from an expected format. Cumbersome when dealing with complex serial input and finicky for parsing numeric values.</p></li>
<li><p><strong><code>NSDataDetector</code></strong>: Perfect for detecting and extracting dates, addresses, links, and more. Limited to its predefined types.</p></li>
<li><p><strong><code>NSScanner</code></strong>: Highly configurable and designed for scanning string and numeric values from loosely demarcated strings.</p></li>
</ul>

<p>This week's article focuses on the last of these, <code>NSScanner</code>. Read on to learn about its flexibility and power.</p>

<hr>

<p>Among Cocoa's tools, <code>NSScanner</code> serves as a wrapper around a string, scanning through its contents to efficiently retrieve substrings and numeric values. It offers several properties that modify an <code>NSScanner</code> instance's behavior:</p>

<blockquote>
<ul>
<li><code>caseSensitive</code> <em><code>Bool</code></em>: Whether to pay attention to the upper- or lower-case while scanning. Note that this property <em>only</em> applies to the string-matching methods <code>scanString:intoString:</code> and <code>scanUpToString:intoString:</code>—character sets scanning is always case-sensitive.</li>
<li><code>charactersToBeSkipped</code>  <em><code>NSCharacterSet</code></em>: The characters to skip over on the way to finding a match for the requested value type.</li>
<li><code>scanLocation</code> <em><code>Int</code></em>: The current position of the scanner in its string. Scanning can be rewound or restarted by setting this property.</li>
<li><code>locale</code> <em><code>NSLocale</code></em>: The locale that the scanner should use when parsing numeric values (see below).</li>
</ul>
</blockquote>

<p>An <code>NSScanner</code> instance has two additional read-only properties: <code>string</code>, which gives you back the string the scanner is scanning; and <code>atEnd</code>, which is true if <code>scanLocation</code> is at the end of the string.</p>

<blockquote>
<p><em>Note:</em> <code>NSScanner</code> is actually the abstract superclass of a private cluster of scanner implementation classes. Even though you're calling <code>alloc</code> and <code>init</code> on <code>NSScanner</code>, you'll actually receive one of these subclasses, such as <code>NSConcreteScanner</code>. No need to fret over this.</p>
</blockquote>

<h2><a id="user-content-extracting-substrings-and-numeric-values" class="anchor" href="#extracting-substrings-and-numeric-values" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extracting Substrings and Numeric Values</h2>

<p>The <em>raison d'être</em> of <code>NSScanner</code> is to pull substrings and numeric values from a larger string. It has fifteen methods to do this, <em>all</em> of which follow the same basic pattern. Each method takes a reference to an output variable as a parameter and returns a boolean value indicating success or failure of the scan:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> whitespaceAndPunctuationSet <span class="pl-k">=</span> NSMutableCharacterSet<span class="pl-k">.</span>whitespaceAndNewlineCharacterSet()
whitespaceAndPunctuationSet<span class="pl-k">.</span>formUnionWithCharacterSet(NSCharacterSet<span class="pl-k">.</span>punctuationCharacterSet())

<span class="pl-k">let</span> stringScanner <span class="pl-k">=</span> NSScanner(string: <span class="pl-s"><span class="pl-pds">"</span>John &amp; Paul &amp; Ringo &amp; George.<span class="pl-pds">"</span></span>)
stringScanner<span class="pl-k">.</span>charactersToBeSkipped <span class="pl-k">=</span> whitespaceAndPunctuationSet

<span class="pl-c">// using the latest Swift 1.2 beta 2 syntax:</span>
<span class="pl-k">var</span> name: NSString?
<span class="pl-k">while</span> stringScanner<span class="pl-k">.</span>scanUpToCharactersFromSet(whitespaceAndPunctuationSet, intoString: <span class="pl-k">&amp;</span>name)
{
    println(name)
}
<span class="pl-c">// John</span>
<span class="pl-c">// Paul</span>
<span class="pl-c">// Ringo</span>
<span class="pl-c">// George</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSMutableCharacterSet</span> *whitespaceAndPunctuationSet = [<span class="pl-c1">NSMutableCharacterSet</span> <span class="pl-c1">punctuationCharacterSet</span>];
[whitespaceAndPunctuationSet <span class="pl-c1">formUnionWithCharacterSet:</span>[<span class="pl-c1">NSCharacterSet</span> <span class="pl-c1">whitespaceAndNewlineCharacterSet</span>]];

<span class="pl-c1">NSScanner</span> *stringScanner = [[<span class="pl-c1">NSScanner</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>John &amp; Paul &amp; Ringo &amp; George.<span class="pl-pds">"</span></span>];
stringScanner.charactersToBeSkipped = whitespaceAndPunctuationSet;

<span class="pl-c1">NSString</span> *name;
<span class="pl-k">while</span> ([stringScanner <span class="pl-c1">scanUpToCharactersFromSet:</span>whitespaceAndPunctuationSet <span class="pl-c1">intoString:</span>&amp;name]) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, name);
}
<span class="pl-c">// John</span>
<span class="pl-c">// Paul</span>
<span class="pl-c">// Ringo</span>
<span class="pl-c">// George</span></pre></div>

<p>The NSScanner API has methods for two use-cases: scanning for strings generally, or for numeric types specifically.</p>

<h4><a id="user-content-1-string-scanners" class="anchor" href="#1-string-scanners" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1) String Scanners</h4>

<blockquote>
<dl>
<dt><code>scanString:intoString:</code> / <code>scanCharactersFromSet:intoString:</code></dt>
<dd>
Scans to match the string parameter or characters in the <code>NSCharacterSet</code> parameter, respectively. The <code>intoString</code> parameter will return containing the scanned string, if found. These methods are often used to advance the scanner's location—pass <code>nil</code> for the <code>intoString</code> parameter to ignore the output.
</dd>

<dt><code>scanUpToString:intoString:</code> / <code>scanUpToCharactersFromSet:intoString:</code></dt>
<dd>
Scans characters into a string <em>until</em> finding the string parameter or characters in the <code>NSCharacterSet</code> parameter, respectively. The <code>intoString</code> parameter will return containing the scanned string, if any was found. If the given string or character set are <em>not</em> found, the result will be the entire rest of the scanner's string.
</dd>
</dl>
</blockquote>

<h4><a id="user-content-2-numeric-scanners" class="anchor" href="#2-numeric-scanners" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2) Numeric Scanners</h4>

<blockquote>
<dl>
<dt><code>scanDouble:</code> / <code>scanFloat:</code> / <code>scanDecimal:</code></dt>
<dd>
Scans a floating-point value from the scanner's string and returns the value in the referenced <code>Double</code>, <code>Float</code>, or <code>NSDecimal</code> instance, if found.
</dd>

<dt><code>scanInteger:</code> / <code>scanInt:</code> / <code>scanLongLong:</code> / <code>scanUnsignedLongLong:</code></dt>
<dd>
Scans an integer value from the scanner's string and returns the value in the referenced <code>Int</code>, <code>Int32</code>, <code>Int64</code>, or <code>UInt64</code> instance, if found.
</dd>

<dt><code>scanHexDouble:</code> / <code>scanHexFloat:</code></dt>
<dd>
Scans a hexadecimal floating-point value from the scanner's string and returns the value in the referenced <code>Double</code> or <code>Float</code> instance, if found. To scan properly, the floating-point value <em>must</em> have a <code>0x</code> or <code>0X</code> prefix.
</dd>

<dt><code>scanHexInt:</code> / <code>scanHexLongLong:</code></dt>
<dd>
Scans a hexadecimal integer value from the scanner's string and returns the value in the referenced <code>UInt32</code> or <code>UInt64</code> instance, if found. The value may have a <code>0x</code> or <code>0X</code> prefix, but it is not required.
</dd>

</dl>
</blockquote>

<hr>

<h2><a id="user-content-localizedscannerwithstring--locale" class="anchor" href="#localizedscannerwithstring--locale" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>localizedScannerWithString / locale</code></h2>

<p>Because it is a part of Cocoa, <code>NSScanner</code> has built-in localization support (of course). An <code>NSScanner</code> instance can work with either the user's locale when created via <code>+ localizedScannerWithString:</code>, or a specific locale after setting its <code>locale</code> property. In particular, the separator for floating-point values will be correctly interpreted based on the given locale:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> price <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">0</span>
<span class="pl-k">let</span> gasPriceScanner <span class="pl-k">=</span> NSScanner(string: <span class="pl-s"><span class="pl-pds">"</span>2.09 per gallon<span class="pl-pds">"</span></span>)
gasPriceScanner<span class="pl-k">.</span>scanDouble(<span class="pl-k">&amp;</span>price)
<span class="pl-c">// 2.09</span>

<span class="pl-c">// use a german locale instead of the default</span>
<span class="pl-k">let</span> benzinPriceScanner <span class="pl-k">=</span> NSScanner(string: <span class="pl-s"><span class="pl-pds">"</span>1,38 pro Liter<span class="pl-pds">"</span></span>)
benzinPriceScanner<span class="pl-k">.</span>locale <span class="pl-k">=</span> NSLocale(localeIdentifier: <span class="pl-s"><span class="pl-pds">"</span>de-DE<span class="pl-pds">"</span></span>)
benzinPriceScanner<span class="pl-k">.</span>scanDouble(<span class="pl-k">&amp;</span>price)
<span class="pl-c">// 1.38</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">double</span> price;
<span class="pl-c1">NSScanner</span> *gasPriceScanner = [[<span class="pl-c1">NSScanner</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>2.09 per gallon<span class="pl-pds">"</span></span>];
[gasPriceScanner <span class="pl-c1">scanDouble:</span>&amp;price];
<span class="pl-c">// 2.09</span>

<span class="pl-c">// use a german locale instead of the default</span>
<span class="pl-c1">NSScanner</span> *benzinPriceScanner = [[<span class="pl-c1">NSScanner</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>1,38 pro Liter<span class="pl-pds">"</span></span>];
[benzinPriceScanner <span class="pl-c1">setLocale:</span>[<span class="pl-c1">NSLocale</span> <span class="pl-c1">localeWithLocaleIdentifier:</span><span class="pl-s"><span class="pl-pds">@"</span>de-DE<span class="pl-pds">"</span></span>]];
[benzinPriceScanner <span class="pl-c1">scanDouble:</span>&amp;price];
<span class="pl-c">// 1.38</span></pre></div>

<hr>

<h2><a id="user-content-example-parsing-svg-path-data" class="anchor" href="#example-parsing-svg-path-data" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example: Parsing SVG Path Data</h2>

<p>To take <code>NSScanner</code> out for a spin, we'll look at parsing the path data from an SVG path. SVG path data are stored as a string of instructions for drawing the path, where "M" indicates a "move-to" step, "L" stands for "line-to", and "C" stands for a curve. Uppercase instructions are followed by points in absolute coordinates; lowercase instructions are followed by coordinates relative to the last point in the path.</p>

<p>Here's an SVG path I happen to have lying around (and a point-offsetting helper we'll use later):</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> svgPathData <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>M28.2,971.4c-10,0.5-19.1,13.3-28.2,2.1c0,15.1,23.7,30.5,39.8,16.3c16,14.1,39.8-1.3,39.8-16.3c-12.5,15.4-25-14.4-39.8,4.5C35.8,972.7,31.9,971.2,28.2,971.4z<span class="pl-pds">"</span></span>

<span class="pl-k">extension</span> CGPoint {
    <span class="pl-k">func</span> <span class="pl-en">offset</span>(p: CGPoint) <span class="pl-k">-&gt;</span> CGPoint {
        <span class="pl-k">return</span> CGPoint(x: x <span class="pl-k">+</span> p<span class="pl-k">.</span>x, y: y <span class="pl-k">+</span> p<span class="pl-k">.</span>y)
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-c1">NSString</span> *<span class="pl-k">const</span> svgPathData = <span class="pl-s"><span class="pl-pds">@"</span>M28.2,971.4c-10,0.5-19.1,13.3-28.2,2.1c0,15.1,23.7,30.5,39.8,16.3c16,14.1,39.8-1.3,39.8-16.3c-12.5,15.4-25-14.4-39.8,4.5C35.8,972.7,31.9,971.2,28.2,971.4z<span class="pl-pds">"</span></span>;

<span class="pl-c1">CGPoint</span> <span class="pl-en">offsetPoint</span>(<span class="pl-c1">CGPoint</span> p1, <span class="pl-c1">CGPoint</span> p2) {
    <span class="pl-k">return</span> <span class="pl-c1">CGPointMake</span>(p1.<span class="pl-smi">x</span> + p2.<span class="pl-smi">x</span>, p1.<span class="pl-smi">y</span> + p2.<span class="pl-smi">y</span>);
}</pre></div>

<p>Note that the point data are fairly irregular. Sometimes the <code>x</code> and <code>y</code> values of a point are separated by a comma, sometimes not, and likewise with points themselves. Parsing these data with regular expressions could turn into a mess pretty quickly, but with <code>NSScanner</code> the code is clear and straightforward.</p>

<p>We'll define a <code>bezierPathFromSVGPath</code> function that will convert a string of path data into an <code>UIBezierPath</code>. Our scanner is set up to skip commas and whitespace while scanning for values:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">bezierPathFromSVGPath</span>(str: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> UIBezierPath {
    <span class="pl-k">let</span> scanner <span class="pl-k">=</span> NSScanner(string: str)

    <span class="pl-c">// skip commas and whitespace</span>
    <span class="pl-k">let</span> skipChars <span class="pl-k">=</span> NSMutableCharacterSet(charactersInString: <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>)
    skipChars<span class="pl-k">.</span>formUnionWithCharacterSet(NSCharacterSet<span class="pl-k">.</span>whitespaceAndNewlineCharacterSet())
    scanner<span class="pl-k">.</span>charactersToBeSkipped <span class="pl-k">=</span> skipChars

    <span class="pl-c">// the resulting bezier path</span>
    <span class="pl-k">var</span> path <span class="pl-k">=</span> UIBezierPath()</pre></div>

<div class="highlight highlight-source-objc"><pre>- (UIBezierPath *)bezierPathFromSVGPath:(<span class="pl-c1">NSString</span> *)str {
    <span class="pl-c1">NSScanner</span> *scanner = [<span class="pl-c1">NSScanner</span> <span class="pl-c1">scannerWithString:</span>str];

    <span class="pl-c">// skip commas and whitespace</span>
    <span class="pl-c1">NSMutableCharacterSet</span> *skipChars = [<span class="pl-c1">NSMutableCharacterSet</span> <span class="pl-c1">characterSetWithCharactersInString:</span><span class="pl-s"><span class="pl-pds">@"</span>,<span class="pl-pds">"</span></span>];
    [skipChars <span class="pl-c1">formUnionWithCharacterSet:</span>[<span class="pl-c1">NSCharacterSet</span> <span class="pl-c1">whitespaceAndNewlineCharacterSet</span>]];
    scanner.<span class="pl-smi">charactersToBeSkipped</span> = skipChars;

    <span class="pl-c">// the resulting bezier path</span>
    UIBezierPath *path = [UIBezierPath <span class="pl-c1">bezierPath</span>];</pre></div>

<p>With the setup out of the way, it's time to start scanning. We start by scanning for a string made up of characters in the allowed set of instructions:</p>

<div class="highlight highlight-source-swift"><pre>    <span class="pl-c">// instructions code can be upper- or lower-case</span>
    <span class="pl-k">let</span> instructionSet <span class="pl-k">=</span> NSCharacterSet(charactersInString: <span class="pl-s"><span class="pl-pds">"</span>MCSQTAmcsqta<span class="pl-pds">"</span></span>)
    <span class="pl-k">var</span> instruction: NSString?

    <span class="pl-c">// scan for an instruction code</span>
    <span class="pl-k">while</span> scanner<span class="pl-k">.</span>scanCharactersFromSet(instructionSet, intoString: <span class="pl-k">&amp;</span>instruction) {</pre></div>

<div class="highlight highlight-source-objc"><pre>    <span class="pl-c">// instructions codes can be upper- or lower-case</span>
    <span class="pl-c1">NSCharacterSet</span> *instructionSet = [<span class="pl-c1">NSCharacterSet</span> <span class="pl-c1">characterSetWithCharactersInString:</span><span class="pl-s"><span class="pl-pds">@"</span>MCSQTAmcsqta<span class="pl-pds">"</span></span>];
    <span class="pl-c1">NSString</span> *instruction;

    <span class="pl-c">// scan for an instruction code</span>
    <span class="pl-k">while</span> ([scanner <span class="pl-c1">scanCharactersFromSet:</span>instructionSet <span class="pl-c1">intoString:</span>&amp;instruction]) {</pre></div>

<p>The next section scans for two <code>Double</code> values in a row, converts them to a <code>CGPoint</code>, and then ultimately adds the correct step to the bezier path:</p>

<div class="highlight highlight-source-swift"><pre>        <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">0</span>, y <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">0</span>
        <span class="pl-k">var</span> points: [CGPoint] <span class="pl-k">=</span> []

        <span class="pl-c">// scan for pairs of Double, adding them as CGPoints to the points array</span>
        <span class="pl-k">while</span> scanner<span class="pl-k">.</span>scanDouble(<span class="pl-k">&amp;</span>x) <span class="pl-k">&amp;&amp;</span> scanner<span class="pl-k">.</span>scanDouble(<span class="pl-k">&amp;</span>y) {
            points<span class="pl-k">.</span>append(CGPoint(x: x, y: y))
        }

        <span class="pl-c">// new point for bezier path</span>
        <span class="pl-k">switch</span> instruction <span class="pl-k">??</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> {
        <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>M<span class="pl-pds">"</span></span>:
            path<span class="pl-k">.</span>moveToPoint(points[<span class="pl-c1">0</span>])
        <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>:
            path<span class="pl-k">.</span>addCurveToPoint(points[<span class="pl-c1">2</span>], controlPoint1: points[<span class="pl-c1">0</span>], controlPoint2: points[<span class="pl-c1">1</span>])
        <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>:
            path<span class="pl-k">.</span>addCurveToPoint(path<span class="pl-k">.</span>currentPoint<span class="pl-k">.</span>offset(points[<span class="pl-c1">2</span>]),
                    controlPoint1: path<span class="pl-k">.</span>currentPoint<span class="pl-k">.</span>offset(points[<span class="pl-c1">0</span>]),
                    controlPoint2: path<span class="pl-k">.</span>currentPoint<span class="pl-k">.</span>offset(points[<span class="pl-c1">1</span>]))
        <span class="pl-k">default</span>:
            <span class="pl-k">break</span>
        }
    }

    <span class="pl-k">return</span> path
}</pre></div>

<div class="highlight highlight-source-objc"><pre>        <span class="pl-k">double</span> x, y;
        <span class="pl-c1">NSMutableArray</span> *points = [<span class="pl-c1">NSMutableArray</span> <span class="pl-c1">array</span>];

        <span class="pl-c">// scan for pairs of Double, adding them as CGPoints to the points array</span>
        <span class="pl-k">while</span> ([scanner <span class="pl-c1">scanDouble:</span>&amp;x] &amp;&amp; [scanner <span class="pl-c1">scanDouble:</span>&amp;y]) {
            [points <span class="pl-c1">addObject:</span>[<span class="pl-c1">NSValue</span> <span class="pl-c1">valueWithCGPoint:</span><span class="pl-c1">CGPointMake</span>(x, y)]];
        }

        <span class="pl-c">// new point in path</span>
        <span class="pl-k">if</span> ([instruction <span class="pl-c1">isEqualToString:</span><span class="pl-s"><span class="pl-pds">@"</span>M<span class="pl-pds">"</span></span>]) {
            [path <span class="pl-c1">moveToPoint:</span>[points[<span class="pl-c1">0</span>] <span class="pl-c1">CGPointValue</span>]];
        } <span class="pl-k">else</span> <span class="pl-k">if</span> ([instruction <span class="pl-c1">isEqualToString:</span><span class="pl-s"><span class="pl-pds">@"</span>C<span class="pl-pds">"</span></span>]) {
            [path <span class="pl-c1">addCurveToPoint:</span>[points[<span class="pl-c1">2</span>] <span class="pl-c1">CGPointValue</span>]
                    <span class="pl-c1">controlPoint1:</span>[points[<span class="pl-c1">0</span>] <span class="pl-c1">CGPointValue</span>]
                    <span class="pl-c1">controlPoint2:</span>[points[<span class="pl-c1">1</span>] <span class="pl-c1">CGPointValue</span>]];
        } <span class="pl-k">else</span> <span class="pl-k">if</span> ([instruction <span class="pl-c1">isEqualToString:</span><span class="pl-s"><span class="pl-pds">@"</span>c<span class="pl-pds">"</span></span>]) {
            <span class="pl-c1">CGPoint</span> newPoint = <span class="pl-c1">offsetPoint</span>(path.<span class="pl-smi">currentPoint</span>, [points[<span class="pl-c1">2</span>] <span class="pl-c1">CGPointValue</span>]);
            <span class="pl-c1">CGPoint</span> control1 = <span class="pl-c1">offsetPoint</span>(path.<span class="pl-smi">currentPoint</span>, [points[<span class="pl-c1">0</span>] <span class="pl-c1">CGPointValue</span>]);
            <span class="pl-c1">CGPoint</span> control2 = <span class="pl-c1">offsetPoint</span>(path.<span class="pl-smi">currentPoint</span>, [points[<span class="pl-c1">1</span>] <span class="pl-c1">CGPointValue</span>]);

            [path <span class="pl-c1">addCurveToPoint:</span>newPoint
                    <span class="pl-c1">controlPoint1:</span>control1
                    <span class="pl-c1">controlPoint2:</span>control2];
        }
    }

    [path <span class="pl-c1">applyTransform:</span><span class="pl-c1">CGAffineTransformMakeScale</span>(<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>)];
    <span class="pl-k">return</span> path;
}</pre></div>

<p>Lo and behold, the result:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/nsscanner-rendered.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/nsscanner-rendered.gif" alt="NSMustacheScanner" style="max-width:100%;"></a></p>

<p>The required flipping, resizing, waxing, and twirling are left as an exercise for the reader.</p>

<hr>

<h2><a id="user-content-swift-friendly-scanning" class="anchor" href="#swift-friendly-scanning" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Swift-Friendly Scanning</h2>

<p>As a last note, working with <code>NSScanner</code> in Swift can feel almost silly. Really, <code>NSScanner</code>, I need to pass in a pointer just so you can return a <code>Bool</code>? I can't use optionals, which are pretty much designed for this exact purpose? <em>Really?</em></p>

<p>With a <a href="https://gist.github.com/natecook1000/59bb0c9117b555f5d40d">simple extension converting the built-in methods to ones returning optional values</a>, scanning becomes far more in sync with Swift's idiom. Our path data scanning example can now use optional binding instead of <code>inout</code> variables for a cleaner, easier-to-read implementation:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// look for an instruction code</span>
<span class="pl-k">while</span> <span class="pl-k">let</span> instruction <span class="pl-k">=</span> scanner<span class="pl-k">.</span>scanCharactersFromSet(instructionSet) {
   <span class="pl-k">var</span> points: [CGPoint] <span class="pl-k">=</span> []

   <span class="pl-c">// scan for pairs of Double, adding them as CGPoints to the points array</span>
   <span class="pl-k">while</span> <span class="pl-k">let</span> x <span class="pl-k">=</span> scanner<span class="pl-k">.</span>scanDouble(), y <span class="pl-k">=</span> scanner<span class="pl-k">.</span>scanDouble() {
       points<span class="pl-k">.</span>append(CGPoint(x: x, y: y))
   }

   <span class="pl-c">// new point for bezier path</span>
   <span class="pl-k">switch</span> instruction {
       <span class="pl-c">// ...</span>
   }
}</pre></div>

<hr>

<p>You've gotta have the right tools for every job. <code>NSScanner</code> can be the shiny tool to reach for when it's time to parse a user's input or a web service's data. Being able to distinguish which tools are right for which tasks helps us on our way to creating clear and accurate code. </p>
</article></div>