<div class="announce instapaper_body md" data-path="2014-12-15-nsundomanager.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSUndoManager</div></td>

  <td><div>Delisa Mason</div></td>

  <td><div>Cocoa</div></td>

  <td><div>We all make mistakes. Thankfully, Foundation comes to our rescue for more than just our misspellings. Cocoa includes a simple yet robust API for undoing or redoing actions through NSUndoManager.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.0</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>We all make mistakes. Thankfully, Foundation comes to our rescue for more than just our misspellings. Cocoa includes a simple yet robust API for undoing or redoing actions through <code>NSUndoManager</code>.</p>

<p>By default, each application window has an undo manager, and any object in the responder chain can manage a custom undo manager for performing undo and redo operations local to their respective view. <code>UITextField</code> and <code>UITextView</code> use this functionality to automatically provide support for undoing text edits while first responder. However, indicating whether other actions can be undone is an exercise left for the app developer.</p>

<p>Creating an undoable action requires three steps: performing a change, registering an "undo operation" which can reverse the change, and responding to a request to undo the change.</p>

<h2><a id="user-content-undo-operations" class="anchor" href="#undo-operations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Undo Operations</h2>

<p>To show an action can be undone, register an "undo operation" while performing the action. The <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/UndoArchitecture/Articles/UndoManager.html#//apple_ref/doc/uid/20000205-CJBDJCCJ">Undo Architecture</a> documentation defines an "undo operation" as:</p>

<blockquote>
<p>A method for reverting a change to an object, along with the arguments needed to revert the change.</p>
</blockquote>

<p>The operation specifies:</p>

<ul>
<li>The object to receive a message if an undo is requested</li>
<li>The message to send and</li>
<li>The arguments to pass with the message</li>
</ul>

<p>If the method invoked by the undo operation also registers an undo operation, the undo manager provides redo support without extra work, as it is "undoing the undo".</p>

<p>There are two types of undo operations, "simple" selector-based undo and complex "NSInvocation-based undo".</p>

<h3><a id="user-content-registering-a-simple-undo-operation" class="anchor" href="#registering-a-simple-undo-operation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Registering a Simple Undo Operation</h3>

<p>To register a simple undo operation, invoke <code>NSUndoManger -registerUndoWithTarget:selector:object:</code> on a target which can undo the action. The target is not necessarily the modified object, and is often a utility or container which manages the object's state. Specify the name of the undo action at the same time, using <code>NSUndoManager -setActionName:</code>. The undo dialog shows the name of the action, so it should be localized.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">updateScore</span>(score: NSNumber) {
    undoManager<span class="pl-k">.</span>registerUndoWithTarget(<span class="pl-k">self</span>, selector:Selector(<span class="pl-s"><span class="pl-pds">"</span>updateScore:<span class="pl-pds">"</span></span>), object:myMovie<span class="pl-k">.</span>score)
    undoManager<span class="pl-k">.</span>setActionName(NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>actions.update<span class="pl-pds">"</span></span>, comment: <span class="pl-s"><span class="pl-pds">"</span>Update Score<span class="pl-pds">"</span></span>))
    myMovie<span class="pl-k">.</span>score <span class="pl-k">=</span> score
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-k">void</span>)updateScore:(<span class="pl-c1">NSNumber</span>*)score {
    [undoManager <span class="pl-c1">registerUndoWithTarget:</span><span class="pl-v">self</span> <span class="pl-c1">selector:</span><span class="pl-k">@selector</span>(<span class="pl-c1">updateScore:</span>) <span class="pl-c1">object:</span>myMovie.score];
    [undoManager <span class="pl-c1">setActionName:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>actions.update<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Update Score<span class="pl-pds">"</span></span>)];
    myMovie.<span class="pl-smi">score</span> = score;
}</pre></div>

<h3><a id="user-content-registering-a-complex-undo-operation-with-nsinvocation" class="anchor" href="#registering-a-complex-undo-operation-with-nsinvocation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Registering a Complex Undo Operation with NSInvocation</h3>

<p>Simple undo operations may be too rigid for some uses, as undoing an action may require more than one argument. In these cases, we can leverage <code>NSInvocation</code> to record the selector and arguments required. Calling <code>prepareWithInvocationTarget:</code> records which object will receive the message which will make the change.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">movePiece</span>(piece: ChessPiece, row:<span class="pl-c1">UInt</span>, column:<span class="pl-c1">UInt</span>) {
    <span class="pl-k">let</span> undoController <span class="pl-k">:</span> ViewController <span class="pl-k">=</span> undoManager?<span class="pl-k">.</span>prepareWithInvocationTarget(<span class="pl-k">self</span>) <span class="pl-k">as</span> ViewController
    undoController<span class="pl-k">.</span>movePiece(piece, row:piece<span class="pl-k">.</span>row, column:piece<span class="pl-k">.</span>column)
    undoManager?<span class="pl-k">.</span>setActionName(NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>actions.move-piece<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Move Piece<span class="pl-pds">"</span></span>))

    piece<span class="pl-k">.</span>row <span class="pl-k">=</span> row
    piece<span class="pl-k">.</span>column <span class="pl-k">=</span> column
    updateChessboard()
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-k">void</span>)movePiece:(ChessPiece*)piece toRow:(<span class="pl-c1">NSUInteger</span>)row column:(<span class="pl-c1">NSUInteger</span>)column {
    [[undoManager <span class="pl-c1">prepareWithInvocationTarget:</span><span class="pl-v">self</span>] <span class="pl-c1">movePiece:</span>piece <span class="pl-c1">ToRow:</span>piece.row <span class="pl-c1">column:</span>piece.column];
    [undoManager <span class="pl-c1">setActionName:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>actions.move-piece<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Move Piece<span class="pl-pds">"</span></span>)];

    piece.<span class="pl-smi">row</span> = row;
    piece.<span class="pl-smi">column</span> = column;
    [<span class="pl-v">self</span> <span class="pl-c1">updateChessboard</span>];
}</pre></div>

<p>The magic here is that <code>NSUndoManager</code> implements <code>forwardInvocation:</code>. When the undo manager receives the message to undo <code>-movePiece:row:column:</code>, it forwards the message to the target since <code>NSUndoManager</code> does not implement this method.</p>

<h2><a id="user-content-performing-an-undo" class="anchor" href="#performing-an-undo" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Performing an Undo</h2>

<p>Once undo operations are registered, actions can be undone and redone as needed, using <code>NSUndoManager -undo</code> and <code>NSUndoManager -redo</code>.</p>

<h3><a id="user-content-responding-to-the-shake-gesture-on-ios" class="anchor" href="#responding-to-the-shake-gesture-on-ios" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Responding to the Shake Gesture on iOS</h3>

<p>By default, users trigger an undo operation by shaking the device. If a view controller should handle an undo request, the view controller must:</p>

<ol>
<li>Be able to become first responder</li>
<li>Become first responder once its view appears,</li>
<li>Resign first responder when its view disappears</li>
</ol>

<p>When the view controller then receives the motion event, the operating system presents a dialog to the user when undo or redo actions are available. The <code>undoManager</code> property of the view controller will handle the user's choice without further involvement.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> ViewController: UIViewController {
    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">viewDidAppear</span>(animated: <span class="pl-c1">Bool</span>) {
        <span class="pl-k">super</span><span class="pl-k">.</span>viewDidAppear(animated)
        becomeFirstResponder()
    }

    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">viewWillDisappear</span>(animated: <span class="pl-c1">Bool</span>) {
        <span class="pl-k">super</span><span class="pl-k">.</span>viewWillDisappear(animated)
        resignFirstResponder()
    }

    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">canBecomeFirstResponder</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    }

    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">@implementation</span> <span class="pl-en">ViewController</span>

- (<span class="pl-k">void</span>)<span class="pl-en">viewDidAppear</span><span class="pl-en">:</span>(<span class="pl-c1">BOOL</span>)<span class="pl-smi">animated</span> {
    [<span class="pl-v">super</span> <span class="pl-c1">viewDidAppear:</span>animated];
    [<span class="pl-v">self</span> <span class="pl-c1">becomeFirstResponder</span>];
}

- (<span class="pl-k">void</span>)<span class="pl-en">viewWillDisappear</span><span class="pl-en">:</span>(<span class="pl-c1">BOOL</span>)<span class="pl-smi">animated</span> {
    [<span class="pl-v">super</span> <span class="pl-c1">viewWillDisappear:</span>animated];
    [<span class="pl-v">self</span> <span class="pl-c1">resignFirstResponder</span>];
}

- (<span class="pl-c1">BOOL</span>)<span class="pl-en">canBecomeFirstResponder</span> {
    <span class="pl-k">return</span> <span class="pl-c1">YES</span>;
}

<span class="pl-c">// ...</span>

<span class="pl-k">@end</span></pre></div>

<h2><a id="user-content-customizing-the-undo-stack" class="anchor" href="#customizing-the-undo-stack" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Customizing the Undo Stack</h2>

<h3><a id="user-content-grouping-actions-together" class="anchor" href="#grouping-actions-together" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Grouping Actions Together</h3>

<p>All undo operations registered during a single run loop will be undone together, unless "undo groups" are otherwise specified. Grouping allows undoing or redoing many actions at once. Although each action can be performed and undone individually, if the user performs two at once, undoing both at once preserves a consistent user experience.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">readAndArchiveEmail</span>(email: Email) {
    undoManager?<span class="pl-k">.</span>beginUndoGrouping()
    markEmail(email, read: <span class="pl-c1">true</span>)
    archiveEmail(email)
    undoManager?<span class="pl-k">.</span>setActionName(NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>actions.read-archive<span class="pl-pds">"</span></span>, comment:<span class="pl-s"><span class="pl-pds">"</span>Mark as Read and Archive<span class="pl-pds">"</span></span>))
    undoManager?<span class="pl-k">.</span>endUndoGrouping()
}

<span class="pl-k">func</span> <span class="pl-en">markEmail</span>(email: Email, read:<span class="pl-c1">Bool</span>) {
    <span class="pl-k">let</span> undoController: ViewController <span class="pl-k">=</span> undoManager?<span class="pl-k">.</span>prepareWithInvocationTarget(<span class="pl-k">self</span>) <span class="pl-k">as</span> ViewController
    undoController<span class="pl-k">.</span>markEmail(email, read:email<span class="pl-k">.</span>read)
    undoManager?<span class="pl-k">.</span>setActionName(NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>actions.read<span class="pl-pds">"</span></span>, comment:<span class="pl-s"><span class="pl-pds">"</span>Mark as Read<span class="pl-pds">"</span></span>))
    email<span class="pl-k">.</span>read <span class="pl-k">=</span> read
}

<span class="pl-k">func</span> <span class="pl-en">archiveEmail</span>(email: Email) {
    <span class="pl-k">let</span> undoController: ViewController <span class="pl-k">=</span> undoManager?<span class="pl-k">.</span>prepareWithInvocationTarget(<span class="pl-k">self</span>) <span class="pl-k">as</span> ViewController
    undoController<span class="pl-k">.</span>moveEmail(email, toFolder:<span class="pl-s"><span class="pl-pds">"</span>Inbox<span class="pl-pds">"</span></span>)
    undoManager?<span class="pl-k">.</span>setActionName(NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>actions.archive<span class="pl-pds">"</span></span>, comment:<span class="pl-s"><span class="pl-pds">"</span>Archive<span class="pl-pds">"</span></span>))
    moveEmail(email, toFolder:<span class="pl-s"><span class="pl-pds">"</span>All Mail<span class="pl-pds">"</span></span>)
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-k">void</span>)readAndArchiveEmail:(Email*)email {
    [undoManager <span class="pl-c1">beginUndoGrouping</span>];
    [<span class="pl-v">self</span> <span class="pl-c1">markEmail:</span>email <span class="pl-c1">asRead:</span><span class="pl-c1">YES</span>];
    [<span class="pl-v">self</span> <span class="pl-c1">archiveEmail:</span>email];
    [undoManager <span class="pl-c1">setActionName:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>actions.read-archive<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Mark as Read and Archive<span class="pl-pds">"</span></span>)];
    [undoManager <span class="pl-c1">endUndoGrouping</span>];
}

- (<span class="pl-k">void</span>)markEmail:(Email*)email asRead:(<span class="pl-c1">BOOL</span>)isRead {
    [[undoManager <span class="pl-c1">prepareWithInvocationTarget:</span><span class="pl-v">self</span>] <span class="pl-c1">markEmail:</span>email <span class="pl-c1">asRead:</span>[email <span class="pl-c1">isRead</span>]];
    [undoManager <span class="pl-c1">setActionName:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>actions.read<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Mark as Read<span class="pl-pds">"</span></span>)];
    email.<span class="pl-smi">read</span> = isRead;
}

- (<span class="pl-k">void</span>)archiveEmail:(Email*)email {
    [[undoManager <span class="pl-c1">prepareWithInvocationTarget:</span><span class="pl-v">self</span>] <span class="pl-c1">moveEmail:</span>email <span class="pl-c1">toFolder:</span><span class="pl-s"><span class="pl-pds">@"</span>Inbox<span class="pl-pds">"</span></span>];
    [undoManager <span class="pl-c1">setActionName:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>actions.archive<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Archive<span class="pl-pds">"</span></span>)];
    [<span class="pl-v">self</span> <span class="pl-c1">moveEmail:</span>email <span class="pl-c1">toFolder:</span><span class="pl-s"><span class="pl-pds">@"</span>All Mail<span class="pl-pds">"</span></span>];
}</pre></div>

<h3><a id="user-content-clearing-the-stack" class="anchor" href="#clearing-the-stack" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clearing the Stack</h3>

<p>Sometimes the undo manager's list of actions should be cleared to avoid confusing the user with unexpected results. The most common cases are when the context changes dramatically, like changing the visible view controller on iOS or externally made changes occurring on an open document. When that time comes, the undo manager's stack can be cleared using <code>NSUndoManager -removeAllActions</code> or <code>NSUndoManager -removeAllActionsWithTarget:</code> if finer granularity is needed.</p>

<h2><a id="user-content-caveats" class="anchor" href="#caveats" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Caveats</h2>

<p>If an action has different names for undo versus redo, check whether an undo operation is occurring before setting the action name to ensure the title of the undo dialog reflects which action will be undone. An example would be a pair of opposing operations, like adding and removing an object:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">addItem</span>(item: NSObject) {
    undoManager?<span class="pl-k">.</span>registerUndoWithTarget(<span class="pl-k">self</span>, selector: Selector(<span class="pl-s"><span class="pl-pds">"</span>removeItem:<span class="pl-pds">"</span></span>), object:item)
    <span class="pl-k">if</span> undoManager?<span class="pl-k">.</span>undoing <span class="pl-k">==</span> <span class="pl-c1">false</span> {
        undoManager?<span class="pl-k">.</span>setActionName(NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>action.add-item<span class="pl-pds">"</span></span>, comment: <span class="pl-s"><span class="pl-pds">"</span>Add Item<span class="pl-pds">"</span></span>))
    }
    myArray<span class="pl-k">.</span>append(item)
}

<span class="pl-k">func</span> <span class="pl-en">removeItem</span>(item: NSObject) {
    <span class="pl-k">if</span> <span class="pl-k">let</span> index <span class="pl-k">=</span> find(myArray, item) {
        undoManager?<span class="pl-k">.</span>registerUndoWithTarget(<span class="pl-k">self</span>, selector: Selector(<span class="pl-s"><span class="pl-pds">"</span>addItem:<span class="pl-pds">"</span></span>), object:item)
        <span class="pl-k">if</span> undoManager?<span class="pl-k">.</span>undoing <span class="pl-k">==</span> <span class="pl-c1">false</span> {
            undoManager?<span class="pl-k">.</span>setActionName(NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>action.remove-item<span class="pl-pds">"</span></span>, comment: <span class="pl-s"><span class="pl-pds">"</span>Remove Item<span class="pl-pds">"</span></span>))
        }
        myArray<span class="pl-k">.</span><span class="pl-c1">removeAtIndex</span>(index)
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-k">void</span>)addItem:(<span class="pl-c1">id</span>)item {
    [undoManager <span class="pl-c1">registerUndoWithTarget:</span><span class="pl-v">self</span> <span class="pl-c1">selector:</span><span class="pl-k">@selector</span>(<span class="pl-c1">removeItem:</span>) <span class="pl-c1">object:</span>item];
    <span class="pl-k">if</span> (![undoManager <span class="pl-c1">isUndoing</span>]) {
        [undoManager <span class="pl-c1">setActionName:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>actions.add-item<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Add Item<span class="pl-pds">"</span></span>)];
    }
    [myArray <span class="pl-c1">addObject:</span>item];
}

- (<span class="pl-k">void</span>)removeItem:(<span class="pl-c1">id</span>)item {
    [undoManager <span class="pl-c1">registerUndoWithTarget:</span><span class="pl-v">self</span> <span class="pl-c1">selector:</span><span class="pl-k">@selector</span>(<span class="pl-c1">addItem:</span>) <span class="pl-c1">object:</span>item];
    <span class="pl-k">if</span> (![undoManager <span class="pl-c1">isUndoing</span>]) {
        [undoManager <span class="pl-c1">setActionName:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>actions.remove-item<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Remove Item<span class="pl-pds">"</span></span>)];
    }
    [myArray <span class="pl-c1">removeObject:</span>item];
}</pre></div>

<p>If your test framework runs many tests as a part of one run loop (like Kiwi), clear the undo stack between tests in <code>teardown</code>. Otherwise tests will share undo state and invoking <code>NSUndoManager -undo</code> during a test may lead to unexpected results.</p>

<hr>

<p>There are even more ways to refine behavior with <code>NSUndoManager</code>, particularly for grouping actions and managing scope. Apple also provides <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/UndoRedo.html">usability guidelines</a> for making undo and redo accessible in an expected and delightful way.</p>

<p>We all may wish to live without mistakes, but Cocoa gives us a way to let our users live with fewer regrets as it makes some actions easily changeable.</p>
</article></div>