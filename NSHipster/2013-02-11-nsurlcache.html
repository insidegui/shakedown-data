<div class="announce instapaper_body md" data-path="2013-02-11-nsurlcache.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSURLCache</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>NSURLCache provides a composite in-memory and on-disk caching mechanism for URL requests to your application. As part of Foundation's URL Loading System, any request loaded through NSURLConnection will be handled by NSURLCache.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.1</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p><code>NSURLCache</code> provides a composite in-memory and on-disk caching mechanism for URL requests to your application. As part of Foundation's <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">URL Loading System</a>, any request loaded through <code>NSURLConnection</code> will be handled by <code>NSURLCache</code>.</p>

<p>Network caching reduces the number of requests that need to be made to the server, and improve the experience of using an application offline or under slow network conditions.</p>

<p>When a request has finished loading its response from the server, a cached response will be saved locally. The next time the same request is made, the locally-cached response will be returned immediately, without connecting to the server. <code>NSURLCache</code> returns the cached response <em>automatically</em> and <em>transparently</em>.</p>

<p>As of iOS 5, a shared <code>NSURLCache</code> is set for the application by default. <a href="https://developer.apple.com/library/ios/documentation/cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/clm/NSURLCache/setSharedURLCache:">Quoth the docs</a>:</p>

<blockquote>
<p>Applications that do not have special caching requirements or constraints should find the default shared cache instance acceptable. An application with more specific needs can create a custom NSURLCache object and set it as the shared cache instance using setSharedURLCache:. The application should do so before any calls to this method.</p>
</blockquote>

<p>Those having such special caching requirements can set a shared URL cache in <code>-application:didFinishLaunchingWithOptions:</code> on iOS, or  <code>–applicationDidFinishLaunching:</code> on OS X:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">application</span>(application: UIApplication<span class="pl-k">!</span>, <span class="pl-en">didFinishLaunchingWithOptions</span> <span class="pl-smi">launchOptions</span>: NSDictionary<span class="pl-k">!</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">let</span> URLCache <span class="pl-k">=</span> NSURLCache(memoryCapacity: <span class="pl-c1">4</span> <span class="pl-k">*</span> <span class="pl-c1">1024</span> <span class="pl-k">*</span> <span class="pl-c1">1024</span>, diskCapacity: <span class="pl-c1">20</span> <span class="pl-k">*</span> <span class="pl-c1">1024</span> <span class="pl-k">*</span> <span class="pl-c1">1024</span>, diskPath: <span class="pl-c1">nil</span>)
    NSURLCache<span class="pl-k">.</span>setSharedURLCache(URLCache)

    <span class="pl-k">return</span> <span class="pl-c1">true</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">BOOL</span>)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(<span class="pl-c1">NSDictionary</span> *)launchOptions
{
  <span class="pl-c1">NSURLCache</span> *URLCache = [[<span class="pl-c1">NSURLCache</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithMemoryCapacity:</span><span class="pl-c1">4</span> * <span class="pl-c1">1024</span> * <span class="pl-c1">1024</span>
                                                       <span class="pl-c1">diskCapacity:</span><span class="pl-c1">20</span> * <span class="pl-c1">1024</span> * <span class="pl-c1">1024</span>
                                                           <span class="pl-c1">diskPath:</span><span class="pl-c1">nil</span>];
  [<span class="pl-c1">NSURLCache</span> <span class="pl-c1">setSharedURLCache:</span>URLCache];
}</pre></div>

<p>Caching policies are specified in both the request (by the client) and in the response (by the server). Understanding these policies and how they relate to one another is essential to finding the optimal behavior for your application.</p>

<h2><a id="user-content-nsurlrequestcachepolicy" class="anchor" href="#nsurlrequestcachepolicy" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSURLRequestCachePolicy</code></h2>

<p><code>NSURLRequest</code> has a <code>cachePolicy</code> property, which specifies the caching behavior of the request according to the following constants:</p>

<ul>
<li><code>NSURLRequestUseProtocolCachePolicy</code>: Caching logic defined in the protocol implementation is used for a particular URL load request. This is the default policy.</li>
<li><code>NSURLRequestReloadIgnoringLocalCacheData</code>: Data should be loaded from the originating source. No existing cache data should be used.</li>
<li><code>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</code>: Not only should the local cache data be ignored, but proxies and other intermediates should be instructed to disregard their caches so far as the protocol allows.</li>
<li><code>NSURLRequestReturnCacheDataElseLoad</code>: Existing cached data should be used, regardless of its age or expiration date. If there is no existing data in the cache corresponding to the request, the data is loaded from the originating source.</li>
<li><code>NSURLRequestReturnCacheDataDontLoad</code>: Existing cache data should be used, regardless of its age or expiration date. If there is no existing data in the cache corresponding to the request, no attempt is made to load the data from the originating source, and the load is considered to have failed, (i.e. "offline" mode).</li>
<li><code>NSURLRequestReloadRevalidatingCacheData</code>: Existing cache data may be used provided the origin source confirms its validity, otherwise the URL is loaded from the origin source.</li>
</ul>

<p>It may not surprise you that these values are poorly understood and often confused with one another.</p>

<p>Adding to the confusion is the fact that <code>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</code> and <code>NSURLRequestReloadRevalidatingCacheData</code> <a href="https://gist.github.com/mattt/4753073#file-nsurlrequest-h-L95-L108"><em>aren't even implemented</em></a>! (<a href="http://openradar.appspot.com/radar?id=1755401">Link to Radar</a>).</p>

<p>So here's what you <em>actually</em> need to know about <code>NSURLRequestCachePolicy</code>:</p>

<table>
  <thead>
    <tr>
      <th>Constant</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><tt>UseProtocolCachePolicy</tt></td>
      <td>Default behavior</td>
    </tr>
    <tr>
      <td><tt>ReloadIgnoringLocalCacheData</tt></td>
      <td>Don't use the cache</td>
    </tr>
    <tr>
      <td><del><tt>ReloadIgnoringLocalAndRemoteCacheData</tt></del></td>
      <td><del>Seriously, don't use the cache</del></td>
    </tr>
    <tr>
      <td><tt>ReturnCacheDataElseLoad</tt></td>
      <td>Use the cache (no matter how out of date), or if no cached response exists, load from the network</td>
    </tr>
    <tr>
      <td><tt>ReturnCacheDataDontLoad</tt></td>
      <td>Offline mode: use the cache (no matter how out of date), but <em>don't</em> load from the network</td>
    </tr>
    <tr>
      <td><del><tt>ReloadRevalidatingCacheData</tt></del></td>
      <td><del>Validate cache against server before using</del></td>
    </tr>
  </tbody>
</table>

<h2><a id="user-content-http-cache-semantics" class="anchor" href="#http-cache-semantics" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP Cache Semantics</h2>

<p>Because <code>NSURLConnection</code> is designed to support multiple protocols—including both <code>FTP</code> and <code>HTTP</code>/<code>HTTPS</code>—the URL Loading System APIs specify caching in a protocol-agnostic fashion. For the purposes of this article, caching will be explained in terms of HTTP semantics.</p>

<p>HTTP requests and responses use <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">headers</a> to communicate metadata such as character encoding, MIME type, and caching directives.</p>

<h3><a id="user-content-request-cache-headers" class="anchor" href="#request-cache-headers" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Request Cache Headers</h3>

<p>By default, <code>NSURLRequest</code> will use the current time to determine whether a cached response should be returned. For more precise cache control, the following headers can be specified:</p>

<ul>
<li><code>If-Modified-Since</code> - This request header corresponds to the <code>Last-Modified</code> response header. Set the value of this to the <code>Last-Modified</code> value received from the last request to the same endpoint.</li>
<li><code>If-None-Match</code> - This request header corresponds to the <code>Etag</code> response header. Use the <code>Etag</code> value received previously for the last request to that endpoint.</li>
</ul>

<h3><a id="user-content-response-cache-headers" class="anchor" href="#response-cache-headers" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Response Cache Headers</h3>

<p>An <code>NSHTTPURLResponse</code> contains a set of HTTP headers, which can include the following directives for how that response should be cached:</p>

<ul>
<li><code>Cache-Control</code> - This header must be present in the response from the server to enable HTTP caching by a client. The value of this header may include information like its <code>max-age</code> (how long to cache a response), and whether the response may be cached with <code>public</code> or <code>private</code> access, or <code>no-cache</code> (not at all). See the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9"><code>Cache-Control</code> section of RFC 2616</a> for full details.</li>
</ul>

<p>In addition to <code>Cache-Control</code>, a server may send additional headers that can be used to conditionally request information as needed (as mentioned in the previous section):</p>

<ul>
<li><code>Last-Modified</code> - The value of this header corresponds to the date and time when the requested resource was last changed. For example, if a client requests a timeline of recent photos, <code>/photos/timeline</code>, the <code>Last-Modified</code>
value could be set to when the most recent photo was taken.</li>
<li><code>Etag</code> - An abbreviation for "entity tag", this is an identifier that represents the contents requested resource. In practice, an <code>Etag</code> header value could be something like the <a href="http://en.wikipedia.org/wiki/MD5"><code>MD5</code></a> digest of the resource properties. This is particularly useful for dynamically generated resources that may not have an obvious <code>Last-Modified</code> value.</li>
</ul>

<h2><a id="user-content-nsurlconnectiondelegate" class="anchor" href="#nsurlconnectiondelegate" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSURLConnectionDelegate</code></h2>

<p>Once the server response has been received, the <code>NSURLConnection</code> delegate has an opportunity to specify the cached response in <code>-connection:willCacheResponse:</code>.</p>

<p><code>NSCachedURLResponse</code> is a class that contains both an <code>NSURLResponse</code> with the cached <code>NSData</code> associated with the response.</p>

<p>In <code>-connection:willCacheResponse:</code>, the <code>cachedResponse</code> object has been automatically created from the result of the URL connection. Because there is no mutable counterpart to <code>NSCachedURLResponse</code>, in order to change anything about <code>cachedResponse</code>, a new object must be constructed, passing any modified values into <code>–initWithResponse:data:userInfo:storagePolicy:</code>, for instance:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// MARK: NSURLConnectionDataDelegate</span>

<span class="pl-k">func</span> <span class="pl-en">connection</span>(connection: NSURLConnection<span class="pl-k">!</span>, <span class="pl-en">willCacheResponse</span> <span class="pl-smi">cachedResponse</span>: NSCachedURLResponse<span class="pl-k">!</span>) <span class="pl-k">-&gt;</span> NSCachedURLResponse! {
    <span class="pl-k">var</span> mutableUserInfo <span class="pl-k">=</span> NSMutableDictionary(dictionary: cachedResponse<span class="pl-k">.</span>userInfo)
    <span class="pl-k">var</span> mutableData <span class="pl-k">=</span> NSMutableData(data: cachedResponse<span class="pl-k">.</span>data)
    <span class="pl-k">var</span> storagePolicy: NSURLCacheStoragePolicy <span class="pl-k">=</span> <span class="pl-k">.</span>AllowedInMemoryOnly

    <span class="pl-c">// ...</span>

    <span class="pl-k">return</span> NSCachedURLResponse(response: cachedResponse<span class="pl-k">.</span>response, data: mutableData, userInfo: mutableUserInfo, storagePolicy: storagePolicy)
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">NSCachedURLResponse</span> *)connection:(<span class="pl-c1">NSURLConnection</span> *)connection
                  willCacheResponse:(<span class="pl-c1">NSCachedURLResponse</span> *)cachedResponse
{
    <span class="pl-c1">NSMutableDictionary</span> *mutableUserInfo = [[cachedResponse <span class="pl-c1">userInfo</span>] <span class="pl-c1">mutableCopy</span>];
    <span class="pl-c1">NSMutableData</span> *mutableData = [[cachedResponse <span class="pl-c1">data</span>] <span class="pl-c1">mutableCopy</span>];
    <span class="pl-c1">NSURLCacheStoragePolicy</span> storagePolicy = NSURLCacheStorageAllowedInMemoryOnly;

    <span class="pl-c">// ...</span>

    <span class="pl-k">return</span> [[<span class="pl-c1">NSCachedURLResponse</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithResponse:</span>[cachedResponse <span class="pl-c1">response</span>]
                                                    <span class="pl-c1">data:</span>mutableData
                                                <span class="pl-c1">userInfo:</span>mutableUserInfo
                                           <span class="pl-c1">storagePolicy:</span>storagePolicy];
}</pre></div>

<p>If <code>-connection:willCacheResponse:</code> returns <code>nil</code>, the response will not be cached.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">connection</span>(connection: NSURLConnection<span class="pl-k">!</span>, <span class="pl-en">willCacheResponse</span> <span class="pl-smi">cachedResponse</span>: NSCachedURLResponse<span class="pl-k">!</span>) <span class="pl-k">-&gt;</span> NSCachedURLResponse! {
    <span class="pl-k">return</span> <span class="pl-c1">nil</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">NSCachedURLResponse</span> *)connection:(<span class="pl-c1">NSURLConnection</span> *)connection
                  willCacheResponse:(<span class="pl-c1">NSCachedURLResponse</span> *)cachedResponse
{
    <span class="pl-k">return</span> <span class="pl-c1">nil</span>;
}</pre></div>

<p>When left unimplemented, <code>NSURLConnection</code> will simply use the cached response that would otherwise be passed into <code>-connection:willCacheResponse:</code>, so unless you need to change or prevent caching, this method does not need to be implemented in the delegate.</p>

<h2><a id="user-content-caveats" class="anchor" href="#caveats" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Caveats</h2>

<p>Just like its unrelated-but-similarly-named cohort, <a href="http://nshipster.com/nscache/"><code>NSCache</code></a>, <code>NSURLCache</code> is not without some peculiarities.</p>

<p>As of iOS 5, disk caching is supported, but only for HTTP, not HTTPS, requests (though iOS 6 added support for this). Peter Steinberger <a href="http://petersteinberger.com/blog/2012/nsurlcache-uses-a-disk-cache-as-of-ios5/">wrote an excellent article on this subject</a>, after digging into the internals while implementing <a href="https://github.com/steipete/SDURLCache">his own NSURLCache subclass</a>.</p>

<p><a href="http://blackpixel.com/blog/2012/05/caching-and-nsurlconnection.html">Another article by Daniel Pasco at Black Pixel</a> describes some unexpected default behavior when communicating with servers that don't set cache headers.</p>

<hr>

<p><code>NSURLCache</code> reminds us of how important it is to be familiar with the systems we interact with. Chief among them when developing for iOS or OS X is, of course, the <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">URL Loading System</a>.</p>

<p>Untold numbers of developers have hacked together an awkward, fragile system for network caching functionality, all because they weren't aware that <code>NSURLCache</code> could be setup in two lines and do it 100× better. Even more developers have never known the benefits of network caching, and never attempted a solution, causing their apps to make untold numbers of unnecessary requests to the server.</p>

<p>So be the change you want to see in the world, and be sure to always start your app on the right foot, by setting a shared <code>NSURLCache</code> in <code>-application:didFinishLaunchingWithOptions:</code>.</p>
</article></div>