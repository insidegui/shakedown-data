<div class="announce instapaper_body md" data-path="2014-04-28-mkgeodesicpolyline.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>MKGeodesicPolyline</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>We knew that the Earth was not flat long before 1492. Early navigators observed the way ships would dip out of view over the horizon many centuries before the Age of Discovery. For many iOS developers, though, a flat MKMapView was a necessary conceit until recently.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>November 12, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>We knew that the Earth was not flat long before 1492. Early navigators observed the way ships would dip out of view over the horizon many centuries before the Age of Discovery.</p>

<p>For many iOS developers, though, a flat <code>MKMapView</code> was a necessary conceit until recently.</p>

<p>What changed? The discovery of <code>MKGeodesicPolyline</code>, which is the subject of this week's article.</p>

<hr>

<p><a href="https://developer.apple.com/library/ios/documentation/MapKit/Reference/MKGeodesicPolyline_class/Reference/Reference.html"><code>MKGeodesicPolyline</code></a> was introduced to the Map Kit framework in iOS 7. As its name implies, it creates a <a href="http://en.wikipedia.org/wiki/Geodesic">geodesic</a>—essentially a straight line over a curved surface.</p>

<p>On the surface of a <del><a href="http://en.wikipedia.org/wiki/Sphere">sphere</a></del> <del><ins><a href="http://en.wikipedia.org/wiki/Oblate_spheroid">oblate spheroid</a></ins></del> <ins><a href="http://en.wikipedia.org/wiki/Geoid">geoid</a></ins>, the shortest distance between two points appears as an arc on a flat projection. Over large distances, this takes a <a href="http://en.wikipedia.org/wiki/Great-circle_distance">pronounced, circular shape</a>.</p>

<p>An <code>MKGeodesicPolyline</code> is created with an array of 2 <code>MKMapPoint</code>s or <code>CLLocationCoordinate2D</code>s:</p>

<h3><a id="user-content-creating-an-mkgeodesicpolyline" class="anchor" href="#creating-an-mkgeodesicpolyline" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating an <code>MKGeodesicPolyline</code></h3>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> LAX <span class="pl-k">=</span> CLLocation(latitude: <span class="pl-c1">33</span><span class="pl-k">.</span><span class="pl-c1">9424955</span>, longitude: <span class="pl-c1">-118</span><span class="pl-k">.</span><span class="pl-c1">4080684</span>)
<span class="pl-k">let</span> JFK <span class="pl-k">=</span> CLLocation(latitude: <span class="pl-c1">40</span><span class="pl-k">.</span><span class="pl-c1">6397511</span>, longitude: <span class="pl-c1">-73</span><span class="pl-k">.</span><span class="pl-c1">7789256</span>)

<span class="pl-k">var</span> coordinates <span class="pl-k">=</span> [LAX<span class="pl-k">.</span>coordinate, JFK<span class="pl-k">.</span>coordinate]
<span class="pl-k">let</span> geodesicPolyline <span class="pl-k">=</span> MKGeodesicPolyline(coordinates: <span class="pl-k">&amp;</span>coordinates, count: <span class="pl-c1">2</span>)

mapView<span class="pl-k">.</span>addOverlay(geodesicPolyline)</pre></div>

<div class="highlight highlight-source-objc"><pre>CLLocation *LAX = [[CLLocation <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithLatitude:</span><span class="pl-c1">33.9424955</span>
                                             <span class="pl-c1">longitude:</span>-<span class="pl-c1">118.4080684</span>];
CLLocation *JFK = [[CLLocation <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithLatitude:</span><span class="pl-c1">40.6397511</span>
                                             <span class="pl-c1">longitude:</span>-<span class="pl-c1">73.7789256</span>];

CLLocationCoordinate2D coordinates[<span class="pl-c1">2</span>] =
    {LAX.<span class="pl-smi">coordinate</span>, JFK.<span class="pl-smi">coordinate</span>};

MKGeodesicPolyline *geodesicPolyline =
    [MKGeodesicPolyline <span class="pl-c1">polylineWithCoordinates:</span>coordinates
                                          <span class="pl-c1">count:</span><span class="pl-c1">2</span>];

[mapView <span class="pl-c1">addOverlay:</span>geodesicPolyline];</pre></div>

<p>Although the overlay looks like a smooth curve, it is actually comprised of thousands of tiny line segments (true to its <code>MKPolyline</code> lineage):</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c1">print</span>(geodesicPolyline<span class="pl-k">.</span>pointCount) <span class="pl-c">// 3984</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%d</span><span class="pl-pds">"</span></span>, geodesicPolyline.pointCount) <span class="pl-c">// 3984</span></pre></div>

<p>Like any object conforming to the <code>MKOverlay</code> protocol, an <code>MKGeodesicPolyline</code> instance is displayed by adding it to an <code>MKMapView</code> with <code>addOverlay()</code> and implementing <code>mapView(_:rendererForOverlay:)</code>:</p>

<h3><a id="user-content-rendering-mkgeodesicpolyline-on-an-mkmapview" class="anchor" href="#rendering-mkgeodesicpolyline-on-an-mkmapview" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering <code>MKGeodesicPolyline</code> on an <code>MKMapView</code></h3>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// MARK: MKMapViewDelegate</span>

<span class="pl-k">func</span> <span class="pl-en">mapView</span>(mapView: MKMapView, <span class="pl-en">rendererForOverlay</span> <span class="pl-smi">overlay</span>: MKOverlay) <span class="pl-k">-&gt;</span> MKOverlayRenderer {
    <span class="pl-k">guard</span> <span class="pl-k">let</span> polyline <span class="pl-k">=</span> overlay <span class="pl-k">as?</span> MKPolyline <span class="pl-k">else</span> {
        <span class="pl-k">return</span> MKOverlayRenderer()
    }

    <span class="pl-k">let</span> renderer <span class="pl-k">=</span> MKPolylineRenderer(polyline: polyline)
    renderer<span class="pl-k">.</span>lineWidth <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">.</span><span class="pl-c1">0</span>
    renderer<span class="pl-k">.</span>alpha <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span>
    renderer<span class="pl-k">.</span>strokeColor <span class="pl-k">=</span> UIColor<span class="pl-k">.</span>blueColor()

    <span class="pl-k">return</span> renderer
}</pre></div>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">pragma mark</span> - MKMapViewDelegate

- (MKOverlayRenderer *)mapView:(MKMapView *)mapView
            rendererForOverlay:(<span class="pl-k">id</span> &lt;MKOverlay&gt;)overlay
{
    <span class="pl-k">if</span> (![overlay <span class="pl-c1">isKindOfClass:</span>[MKPolyline <span class="pl-c1">class</span>]]) {
        <span class="pl-k">return</span> <span class="pl-c1">nil</span>;
    }

    MKPolylineRenderer *renderer =
        [[MKPolylineRenderer <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithPolyline:</span>(MKPolyline *)overlay];
    renderer.<span class="pl-smi">lineWidth</span> = <span class="pl-c1">3</span>.<span class="pl-c1">0f</span>;
    renderer.<span class="pl-smi">strokeColor</span> = [UIColor <span class="pl-c1">blueColor</span>];
    renderer.<span class="pl-smi">alpha</span> = <span class="pl-c1">0.5</span>;

    <span class="pl-k">return</span> renderer;
}</pre></div>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline.jpg" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline.jpg" alt="MKGeodesicPolyline on an MKMapView" style="max-width:100%;"></a></p>

<blockquote>
<p>For comparison, here's the same geodesic overlaid with a route created from <a href="http://nshipster.com/mktileoverlay-mkmapsnapshotter-mkdirections/"><code>MKDirections</code></a>:</p>
</blockquote>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline-with-directions.jpg" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline-with-directions.jpg" alt="MKGeodesicPolyline on an MKMapView compared to MKDirections Polyline" style="max-width:100%;"></a></p>

<p><a href="http://en.wikipedia.org/wiki/As_the_crow_flies">As the crow flies</a>, it's 3,983 km.<br>
As the wolf runs, it's 4,559 km—nearly 15% longer.<br>
…and that's just distance; taking into account average travel speed, the total time is ~5 hours by air and 40+ hours by land.</p>

<h3><a id="user-content-animating-an-mkannotationview-on-a-mkgeodesicpolyline" class="anchor" href="#animating-an-mkannotationview-on-a-mkgeodesicpolyline" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Animating an <code>MKAnnotationView</code> on a <code>MKGeodesicPolyline</code></h3>

<p>Since geodesics make reasonable approximations for flight paths, a common use case would be to animate the trajectory of a flight over time.</p>

<p>To do this, we'll make properties for our map view and geodesic polyline between LAX and JFK, and add new properties for the <code>planeAnnotation</code> and <code>planeAnnotationPosition</code> (the index of the current map point for the polyline):</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// MARK: Flight Path Properties</span>
<span class="pl-k">var</span> mapView: MKMapView<span class="pl-k">!</span>
<span class="pl-k">var</span> flightpathPolyline: MKGeodesicPolyline<span class="pl-k">!</span>
<span class="pl-k">var</span> planeAnnotation: MKPointAnnotation<span class="pl-k">!</span>
<span class="pl-k">var</span> planeAnnotationPosition <span class="pl-k">=</span> <span class="pl-c1">0</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">@interface</span> <span class="pl-en">MapViewController</span> () &lt;MKMapViewDelegate&gt;
<span class="pl-k">@property</span> MKMapView *mapView;
<span class="pl-k">@property</span> MKGeodesicPolyline *flightpathPolyline;
<span class="pl-k">@property</span> MKPointAnnotation *planeAnnotation;
<span class="pl-k">@property</span> <span class="pl-c1">NSUInteger</span> planeAnnotationPosition;
<span class="pl-k">@end</span></pre></div>

<p>Next, right below the initialization of our map view and polyline, we create an <code>MKPointAnnotation</code> for our plane:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> annotation <span class="pl-k">=</span> MKPointAnnotation()
annotation<span class="pl-k">.</span>title <span class="pl-k">=</span> NSLocalizedString(<span class="pl-s"><span class="pl-pds">"</span>Plane<span class="pl-pds">"</span></span>, comment: <span class="pl-s"><span class="pl-pds">"</span>Plane marker<span class="pl-pds">"</span></span>)
mapView<span class="pl-k">.</span>addAnnotation(annotation)

<span class="pl-k">self</span><span class="pl-k">.</span>planeAnnotation <span class="pl-k">=</span> annotation
<span class="pl-k">self</span><span class="pl-k">.</span>updatePlanePosition()</pre></div>

<div class="highlight highlight-source-objc"><pre>self.planeAnnotation = [[MKPointAnnotation <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
self.planeAnnotation.title = NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>Plane<span class="pl-pds">"</span></span>, <span class="pl-c1">nil</span>);
[<span class="pl-v">self</span>.mapView <span class="pl-c1">addAnnotation:</span><span class="pl-v">self</span>.planeAnnotation];

[<span class="pl-v">self</span> <span class="pl-c1">updatePlanePosition</span>];</pre></div>

<p>That call to <code>updatePlanePosition</code> in the last line ticks the animation and updates the position of the plane:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">updatePlanePosition</span>() {
    <span class="pl-k">let</span> step <span class="pl-k">=</span> <span class="pl-c1">5</span>
    <span class="pl-k">guard</span> planeAnnotationPosition <span class="pl-k">+</span> step <span class="pl-k">&lt;</span> flightpathPolyline<span class="pl-k">.</span>pointCount
        <span class="pl-k">else</span> { <span class="pl-k">return</span> }

    <span class="pl-k">let</span> points <span class="pl-k">=</span> flightpathPolyline<span class="pl-k">.</span>points()
    <span class="pl-k">self</span><span class="pl-k">.</span>planeAnnotationPosition <span class="pl-k">+=</span> step
    <span class="pl-k">let</span> nextMapPoint <span class="pl-k">=</span> points[planeAnnotationPosition]

    <span class="pl-k">self</span><span class="pl-k">.</span>planeAnnotation<span class="pl-k">.</span>coordinate <span class="pl-k">=</span> MKCoordinateForMapPoint(nextMapPoint)

    performSelector(<span class="pl-s"><span class="pl-pds">"</span>updatePlanePosition<span class="pl-pds">"</span></span>, withObject: <span class="pl-c1">nil</span>, afterDelay: <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">03</span>)
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-k">void</span>)updatePlanePosition {
    <span class="pl-k">static</span> <span class="pl-c1">NSUInteger</span> <span class="pl-k">const</span> step = <span class="pl-c1">5</span>;

    <span class="pl-k">if</span> (self.<span class="pl-smi">planeAnnotationPosition</span> + step &gt;= self.<span class="pl-smi">flightpathPolyline</span>.<span class="pl-smi">pointCount</span>) {
        <span class="pl-k">return</span>;
    }

    self.<span class="pl-smi">planeAnnotationPosition</span> += step;
    MKMapPoint nextMapPoint = self.<span class="pl-smi">flightpathPolyline</span>.<span class="pl-smi">points</span>[<span class="pl-v">self</span>.planeAnnotationPosition];

    self.<span class="pl-smi">planeAnnotation</span>.<span class="pl-smi">coordinate</span> = <span class="pl-c1">MKCoordinateForMapPoint</span>(nextMapPoint);

    [<span class="pl-v">self</span> <span class="pl-c1">performSelector:</span><span class="pl-k">@selector</span>(<span class="pl-c1">updatePlanePosition</span>) <span class="pl-c1">withObject:</span><span class="pl-c1">nil</span> <span class="pl-c1">afterDelay:</span><span class="pl-c1">0.03</span>];
}</pre></div>

<p>We'll perform this method roughly 30 times a second, until the plane has arrived at its final destination.</p>

<p>Finally, we implement <code>mapView(_:viewForAnnotation:)</code> to have the annotation render on the map view:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">mapView</span>(mapView: MKMapView, <span class="pl-en">viewForAnnotation</span> <span class="pl-smi">annotation</span>: MKAnnotation) <span class="pl-k">-&gt;</span> MKAnnotationView? {
    <span class="pl-k">let</span> planeIdentifier <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Plane<span class="pl-pds">"</span></span>

    <span class="pl-k">let</span> annotationView <span class="pl-k">=</span> mapView<span class="pl-k">.</span>dequeueReusableAnnotationViewWithIdentifier(planeIdentifier)
            <span class="pl-k">??</span> MKAnnotationView(annotation: annotation, reuseIdentifier: planeIdentifier)

    annotationView<span class="pl-k">.</span>image <span class="pl-k">=</span> UIImage(named: <span class="pl-s"><span class="pl-pds">"</span>airplane<span class="pl-pds">"</span></span>)

    <span class="pl-k">return</span> annotationView
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (MKAnnotationView *)mapView:(MKMapView *)mapView
            viewForAnnotation:(<span class="pl-k">id</span> &lt;MKAnnotation&gt;)annotation
{
    <span class="pl-k">static</span> <span class="pl-c1">NSString</span> * PinIdentifier = <span class="pl-s"><span class="pl-pds">@"</span>Pin<span class="pl-pds">"</span></span>;

    MKAnnotationView *annotationView = [mapView <span class="pl-c1">dequeueReusableAnnotationViewWithIdentifier:</span>PinIdentifier];
    <span class="pl-k">if</span> (!annotationView) {
        annotationView = [[MKAnnotationView <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithAnnotation:</span>annotation <span class="pl-c1">reuseIdentifier:</span>PinIdentifier];
    }

    annotationView.<span class="pl-smi">image</span> = [UIImage <span class="pl-c1">imageNamed:</span><span class="pl-s"><span class="pl-pds">@"</span>plane<span class="pl-pds">"</span></span>];

    <span class="pl-k">return</span> annotationView;
}</pre></div>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline-airplane-animate.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline-airplane-animate.gif" alt="MKAnnotationView without Rotation" style="max-width:100%;"></a></p>

<p>Hmm… close but no <a href="http://www.skymall.com/personalized-cigar-case-flask/GC900.html">SkyMall Personalized Cigar Case Flask</a>.</p>

<p>Let's update the rotation of the plane as it moves across its flightpath.</p>

<h3><a id="user-content-rotating-an-mkannotationview-along-a-path" class="anchor" href="#rotating-an-mkannotationview-along-a-path" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rotating an <code>MKAnnotationView</code> along a Path</h3>

<p>To calculate the plane's direction, we'll take the slope from the previous and next points:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> previousMapPoint <span class="pl-k">=</span> points[planeAnnotationPosition]
planeAnnotationPosition <span class="pl-k">+=</span> step
<span class="pl-k">let</span> nextMapPoint <span class="pl-k">=</span> points[planeAnnotationPosition]

<span class="pl-k">self</span><span class="pl-k">.</span>planeDirection <span class="pl-k">=</span> directionBetweenPoints(previousMapPoint, nextMapPoint)
<span class="pl-k">self</span><span class="pl-k">.</span>planeAnnotation<span class="pl-k">.</span>coordinate <span class="pl-k">=</span> MKCoordinateForMapPoint(nextMapPoint)</pre></div>

<div class="highlight highlight-source-objc"><pre>MKMapPoint previousMapPoint = self.flightpathPolyline.points[<span class="pl-v">self</span>.planeAnnotationPosition];
self.planeAnnotationPosition += step;
MKMapPoint nextMapPoint = self.flightpathPolyline.points[<span class="pl-v">self</span>.planeAnnotationPosition];

self.planeDirection = XXDirectionBetweenPoints(previousMapPoint, nextMapPoint);
self.planeAnnotation.coordinate = MKCoordinateForMapPoint(nextMapPoint);</pre></div>

<p><code>directionBetweenPoints</code> is a function that returns a <code>CLLocationDirection</code> (0 – 360 degrees, where North = 0) given two <code>MKMapPoint</code>s.</p>

<blockquote>
<p>We calculate from <code>MKMapPoint</code>s rather than converted coordinates, because we're interested in the slope of the line on the flat projection.</p>
</blockquote>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">private</span> <span class="pl-k">func</span> <span class="pl-en">directionBetweenPoints</span>(sourcePoint: MKMapPoint, <span class="pl-en">_</span> <span class="pl-smi">destinationPoint</span>: MKMapPoint) <span class="pl-k">-&gt;</span> CLLocationDirection {
    <span class="pl-k">let</span> x <span class="pl-k">=</span> destinationPoint<span class="pl-k">.</span>x <span class="pl-k">-</span> sourcePoint<span class="pl-k">.</span>x
    <span class="pl-k">let</span> y <span class="pl-k">=</span> destinationPoint<span class="pl-k">.</span>y <span class="pl-k">-</span> sourcePoint<span class="pl-k">.</span>y

    <span class="pl-k">return</span> radiansToDegrees(atan2(y, x)) <span class="pl-k">%</span> <span class="pl-c1">360</span> <span class="pl-k">+</span> <span class="pl-c1">90</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> CLLocationDirection <span class="pl-en">XXDirectionBetweenPoints</span>(MKMapPoint sourcePoint, MKMapPoint destinationPoint) {
    <span class="pl-k">double</span> x = destinationPoint.<span class="pl-smi">x</span> - sourcePoint.<span class="pl-smi">x</span>;
    <span class="pl-k">double</span> y = destinationPoint.<span class="pl-smi">y</span> - sourcePoint.<span class="pl-smi">y</span>;

    <span class="pl-k">return</span> <span class="pl-c1">fmod</span>(<span class="pl-c1">XXRadiansToDegrees</span>(<span class="pl-c1">atan2</span>(y, x)), <span class="pl-c1">360</span>.<span class="pl-c1">0f</span>) + <span class="pl-c1">90</span>.<span class="pl-c1">0f</span>;
}</pre></div>

<p>That convenience function <code>radiansToDegrees</code> (and its partner, <code>degreesToRadians</code>) are simply:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">private</span> <span class="pl-k">func</span> <span class="pl-en">radiansToDegrees</span>(radians: <span class="pl-c1">Double</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Double</span> {
    <span class="pl-k">return</span> radians <span class="pl-k">*</span> <span class="pl-c1">180</span> <span class="pl-k">/</span> M_PI
}

<span class="pl-k">private</span> <span class="pl-k">func</span> <span class="pl-en">degreesToRadians</span>(degrees: <span class="pl-c1">Double</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Double</span> {
    <span class="pl-k">return</span> degrees <span class="pl-k">*</span> M_PI <span class="pl-k">/</span> <span class="pl-c1">180</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-k">inline</span> <span class="pl-k">double</span> <span class="pl-en">XXRadiansToDegrees</span>(<span class="pl-k">double</span> radians) {
    <span class="pl-k">return</span> radians * <span class="pl-c1">180</span>.<span class="pl-c1">0f</span> / M_PI;
}

<span class="pl-k">static</span> <span class="pl-k">inline</span> <span class="pl-k">double</span> <span class="pl-en">XXDegreesToRadians</span>(<span class="pl-k">double</span> degrees) {
    <span class="pl-k">return</span> degrees * M_PI / <span class="pl-c1">180</span>.<span class="pl-c1">0f</span>;
}</pre></div>

<p>That direction is stored in a new property, <code>var planeDirection: CLLocationDirection</code>, calculated from <code>self.planeDirection = directionBetweenPoints(currentMapPoint, nextMapPoint)</code> in <code>updatePlanePosition</code> (ideally renamed to <code>updatePlanePositionAndDirection</code> with this addition). To make the annotation rotate, we apply a <code>transform</code> on <code>annotationView</code>:</p>

<div class="highlight highlight-source-swift"><pre>annotationView<span class="pl-k">.</span>transform <span class="pl-k">=</span> CGAffineTransformRotate(mapView<span class="pl-k">.</span>transform, 
        degreesToRadians(planeDirection))</pre></div>

<div class="highlight highlight-source-objc"><pre>self.annotationView.transform =
    <span class="pl-en">CGAffineTransformRotate</span>(self.mapView.transform,
                            <span class="pl-en">XXDegreesToRadians</span>(self.planeDirection));</pre></div>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline-airplane-animate-rotate.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/mkgeodesicpolyline-airplane-animate-rotate.gif" alt="MKAnnotationView with Rotation" style="max-width:100%;"></a></p>

<p>Ah much better! At last, we have mastered the skies with a fancy visualization, worthy of any travel-related app.</p>

<hr>

<p>Perhaps more than any other system framework, MapKit has managed to get incrementally better, little by little with every iOS release <a href="http://nshipster.com/mktileoverlay-mkmapsnapshotter-mkdirections/">[1]</a> <a href="http://nshipster.com/mklocalsearch/">[2]</a>. For anyone with a touch-and-go relationship to the framework, returning after a few releases is a delightful experience of discovery and rediscovery.</p>

<p>I look forward to seeing what lies on the horizon with iOS 8 and beyond.</p>
</article></div>