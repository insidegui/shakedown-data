<div class="announce instapaper_body md" data-path="2012-09-03-nslocale.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSLocale</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>nshipster</div></td>

  <td><div>Internationalization is like flossing: everyone knows they should do it, but probably don't.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.1</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Internationalization is like flossing: everyone knows they should do it, but probably don't.</p>

<p>And like any habit, it becomes second-nature with practice, to the point that you couldn't imagine <em>not</em> doing it. All it takes is for someone to show you the way.</p>

<p>Let NSHipster be your dental hygienist Virgil through these foreign lands.. without all of the lecturing about tooth decay (promsies!)</p>

<h2><a id="user-content-i18n-versus-l10n" class="anchor" href="#i18n-versus-l10n" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>i18n versus l10n</h2>

<p>As is necessary in any discussion about Internationalization (i18n) or Localization (l10n), we must take some time to differentiate the two:</p>

<ul>
<li><strong>Localization</strong> is the process of adapting your application for a specific market, or <em>locale</em>.</li>
<li><strong>Internationalization</strong> is the process of preparing your app to be localized.</li>
</ul>

<blockquote>
<p>Internationalization is a necessary, but not sufficient condition for localization, and will be the focus of this article. Localization, which involves the translation of text and assets into a particular language, will be covered in a future edition of NSHipster.</p>
</blockquote>

<p>What makes internationalization difficult is having to think outside of your cultural context. All of the assumptions you have about the way things are supposed to work must be acknowledged and reconsidered. You have to fight the urge to write off things that may seem trivial, like sorting and collation, and empathize with the pain and confusion even minor differences may cause.</p>

<p>Fortunately for us, we don't have to do this alone. Meet <code>NSLocale</code>:</p>

<h2><a id="user-content-nslocale" class="anchor" href="#nslocale" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>NSLocale</code></h2>

<p><code>NSLocale</code> is a Foundation class that encapsulates all of the conventions about language and culture for a particular locale. A locale encompasses all of the linguistic and cultural norms of a particular group of people, including:</p>

<ul>
<li>Language</li>
<li>Keyboards</li>
<li>Number, Date, and Time Formats</li>
<li>Currency</li>
<li>Collation and Sorting</li>
<li>Use of Symbols, Colors, and Iconography</li>
</ul>

<p>Each locale corresponds to a <em>locale identifier</em>, such as <code>en_US</code>, <code>fr_FR</code>, <code>ja_JP</code>, and <code>en_GB</code>, which include a language code (e.g. <code>en</code> for English) and a region code (e.g. <code>US</code> for United States).</p>

<p>Locale identifiers can encode more explicit preferences about currency, calendar system, or number formats, such as in the case of <code>de_DE@collation=phonebook,currency=DDM</code>, which specifies German spoken in Germany, using <a href="http://developer.mimer.com/charts/german_phonebook.htm">phonebook collation</a>, and using the pre-Euro <a href="http://en.wikipedia.org/wiki/Deutsche_Mark">Deutsche Mark</a>.</p>

<p>Users can change their locale settings in the "Language &amp; Text" (or "International" on older versions of OS X) System Preferences on the Mac, or "General &gt; International" in iOS Settings.</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/nslocale-international-system-preferences.png" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/nslocale-international-system-preferences.png" alt="Language &amp; Text System Preferences" style="max-width:100%;"></a></p>

<h2><a id="user-content-formatting-dates--numbers" class="anchor" href="#formatting-dates--numbers" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Formatting Dates &amp; Numbers</h2>

<p>Although <code>NSLocale</code> encapsulates a rich set of domain-specific information, its typical usage is rather understated.</p>

<p>If there's just one thing you should learn about <code>NSLocale</code>, it's that you should always pass <code>[NSLocale currentLocale]</code> into your <code>NSDateFormatter</code> and <code>NSNumberFormatter</code> instances. Doing this will ensure that dates, numbers, and currencies will be formatted according to the localization preferences of the user.</p>

<p>Actually, make that a meta lesson about locales: always use <code>NSDateFormatter</code> and <code>NSNumberFormatter</code> when displaying anything to do with dates or numbers, respectively.</p>

<p>But let's get back to some of the cool features of <code>NSLocale</code> itself, shall we?</p>

<h2><a id="user-content--objectforkey" class="anchor" href="#-objectforkey" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-objectForKey:</code></h2>

<p><code>NSLocale</code> typifies Foundation's obsession with domain-specific pedantry, and nowhere is this more visible than in <code>-objectForKey:</code>. Cue the list of available constants:</p>

<ul>
<li><code>NSLocaleIdentifier</code></li>
<li><code>NSLocaleLanguageCode</code></li>
<li><code>NSLocaleCountryCode</code></li>
<li><code>NSLocaleScriptCode</code></li>
<li><code>NSLocaleVariantCode</code></li>
<li><code>NSLocaleExemplarCharacterSet</code></li>
<li><code>NSLocaleCalendar</code></li>
<li><code>NSLocaleCollationIdentifier</code></li>
<li><code>NSLocaleUsesMetricSystem</code></li>
<li><code>NSLocaleMeasurementSystem</code></li>
<li><code>NSLocaleDecimalSeparator</code></li>
<li><code>NSLocaleGroupingSeparator</code></li>
<li><code>NSLocaleCurrencySymbol</code></li>
<li><code>NSLocaleCurrencyCode</code></li>
<li><code>NSLocaleCollatorIdentifier</code></li>
<li><code>NSLocaleQuotationBeginDelimiterKey</code></li>
<li><code>NSLocaleQuotationEndDelimiterKey</code></li>
<li><code>NSLocaleAlternateQuotationBeginDelimiterKey</code></li>
<li><code>NSLocaleAlternateQuotationEndDelimiterKey</code></li>
</ul>

<p>While this all may seem like fairly esoteric stuff, you may be surprised by the number of opportunities your application has to use this information to make for a better user experience.</p>

<p>It's the small things, like knowing that quotation marks vary between locales:</p>

<ul>
<li>English: “I can eat glass, it doesn't harm me.”</li>
<li>German: „Ich kann Glas essen, das tut mir nicht weh.“</li>
<li>Japanese:「私はガラスを食べられます。それは私を傷つけません。」</li>
</ul>

<p>So if you were building a component that added quotations around arbitrary text, you should use <code>NSLocaleQuotationBeginDelimiterKey</code> and <code>NSLocaleAlternateQuotationEndDelimiterKey</code> rather than assuming <code>@"\""</code> for English quotation marks.</p>

<h2><a id="user-content--displaynameforkeyvalue" class="anchor" href="#-displaynameforkeyvalue" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-displayNameForKey:value:</code></h2>

<p>Another impressive, albeit mostly-useless method is <code>-displayNameForKey:value:</code>, which can return the display name of a locale identifier (<code>NSLocaleIdentifier</code>):</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> locale <span class="pl-k">=</span> NSLocale(localeIdentifier: <span class="pl-s"><span class="pl-pds">"</span>fr_FR<span class="pl-pds">"</span></span>)

<span class="pl-k">let</span> fr_FR <span class="pl-k">=</span> locale<span class="pl-k">.</span>displayNameForKey(NSLocaleIdentifier, value: <span class="pl-s"><span class="pl-pds">"</span>fr_FR<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> en_US <span class="pl-k">=</span> locale<span class="pl-k">.</span>displayNameForKey(NSLocaleIdentifier, value: <span class="pl-s"><span class="pl-pds">"</span>en_US<span class="pl-pds">"</span></span>)</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSLocale</span> *frLocale = [[<span class="pl-c1">NSLocale</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithLocaleIdentifier:</span><span class="pl-s"><span class="pl-pds">@"</span>fr_FR<span class="pl-pds">"</span></span>];
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>fr_FR: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [frLocale <span class="pl-c1">displayNameForKey:</span><span class="pl-c1">NSLocaleIdentifier</span> <span class="pl-c1">value:</span><span class="pl-s"><span class="pl-pds">@"</span>fr_FR<span class="pl-pds">"</span></span>]);
<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>en_US: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [frLocale <span class="pl-c1">displayNameForKey:</span><span class="pl-c1">NSLocaleIdentifier</span> <span class="pl-c1">value:</span><span class="pl-s"><span class="pl-pds">@"</span>en_US<span class="pl-pds">"</span></span>]);</pre></div>

<ul>
<li><code>fr_FR</code>: "français (France)"</li>
<li><code>en_US</code>: "anglais (États-Unis)"</li>
</ul>

<p>You should use this method any time you need to display information about the user's current locale, or any alternative locales available to them, like in this screen from the Settings app:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/nslocale-languages-settings.png" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/nslocale-languages-settings.png" alt="Languages Settings" style="max-width:100%;"></a></p>

<h2><a id="user-content-preferredlanguages" class="anchor" href="#preferredlanguages" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>+preferredLanguages</code></h2>

<p>One final method worth mentioning is <code>NSLocale +preferredLanguages</code>, which returns an array of <a href="http://tools.ietf.org/html/bcp47">IETF BCP 47 language identifier</a> strings, in order of user preference.</p>

<p>An app that communicates with a web server can use these values to define the <code>Accept-Language</code> HTTP header, such that the server has the option to return localized resources:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Accept-Language HTTP Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4</span>
<span class="pl-k">let</span> acceptLanguage: <span class="pl-c1">String</span> <span class="pl-k">=</span> {
    <span class="pl-k">var</span> components: [<span class="pl-c1">String</span>] <span class="pl-k">=</span> []
    <span class="pl-k">for</span> (index, languageCode) <span class="pl-k">in</span> enumerate(NSLocale<span class="pl-k">.</span>preferredLanguages() <span class="pl-k">as</span> [<span class="pl-c1">String</span>]) {
        <span class="pl-k">let</span> q <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">0</span> <span class="pl-k">-</span> (<span class="pl-c1">Double</span>(index) <span class="pl-k">*</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">1</span>)
        components<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">languageCode</span><span class="pl-pse">)</span>;q=<span class="pl-pse">\(</span><span class="pl-s1">q</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
        <span class="pl-k">if</span> q <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span> {
            <span class="pl-k">break</span>
        }
    }

    <span class="pl-k">return</span> <span class="pl-c1">join</span>(<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>, components)
}()

<span class="pl-k">let</span> URL <span class="pl-k">=</span> NSURL(string: <span class="pl-s"><span class="pl-pds">"</span>http://nshipster.com<span class="pl-pds">"</span></span>)
<span class="pl-k">var</span> mutableRequest <span class="pl-k">=</span> NSMutableURLRequest(URL: URL)

mutableRequest<span class="pl-k">.</span>setValue(acceptLanguage, forHTTPHeaderField: <span class="pl-s"><span class="pl-pds">"</span>Accept-Language<span class="pl-pds">"</span></span>)</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSMutableURLRequest</span> *request = ...;
[request <span class="pl-c1">setValue:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [[<span class="pl-c1">NSLocale</span> <span class="pl-c1">preferredLanguages</span>] <span class="pl-c1">componentsJoinedByString:</span><span class="pl-s"><span class="pl-pds">@"</span>, <span class="pl-pds">"</span></span>]], <span class="pl-c1">forHTTPHeaderField:</span><span class="pl-s"><span class="pl-pds">@"</span>Accept-Language<span class="pl-pds">"</span></span>];</pre></div>

<p>Even if your server doesn't yet localize its resources, putting this in place now will allow you to flip the switch when the time comes, without having to push an update to the client. Neat!</p>

<hr>

<p>Internationalization is often considered to be an un-sexy topic in programming--just another chore that most projects don't have to worry about. In actuality, designing software for other locales is a valuable exercise (and not just for the economic benefits of expanding your software into other markets).</p>

<p>One of the greatest joys and challenges in programming is in designing systems that can withstand change. The only way designs can survive this level of change is to identify and refactor assumptions about the system that may not always hold. In this way, internationalization represents the greatest challenge, making us question everything about our cultural identity. And in doing so, we become not just better programmers, but better people, too.</p>

<p>So go and be a better person: make <code>NSLocale</code> part of your daily ritual.</p>
</article></div>