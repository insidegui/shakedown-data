<div class="announce instapaper_body md" data-path="2014-03-03-nstemporarydirectory.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>revisions</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSTemporaryDirectory /<br>NSItemReplacementDirectory /<br>mktemp(3)</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>Volumes have been written about persisting data, but when it comes to short-lived, temporary files, there is very little to go on for Objective-C. (Or if there has, perhaps it was poetically ephemeral itself).</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>2016-03-10</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Translated sample code into Swift.</div></td>
  </tr>
  </tbody>
</table></div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.1.1</div></td>

  <td><div>March 10, 2016</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Volumes have been written about persisting data, but when it comes to short-lived, temporary files, there is very little to go on for Objective-C. (Or if there has, perhaps it was poetically ephemeral itself).</p>

<hr>

<p>Temporary files are used to write a buffer to disk, to either be atomically moved to a permanent location, or processed in some manner and then discarded. Creating a temporary file involves finding the appropriate part of the filesystem, generating a unique name, and moving or deleting the file after you're finished using it.</p>

<h2><a id="user-content-finding-an-enclosing-directory" class="anchor" href="#finding-an-enclosing-directory" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Finding an Enclosing Directory</h2>

<p>The first step to creating temporary files or directories is to find a reasonable, out-of-the-way place to write to—somewhere that won't be backed up by Time Machine or synced to iCloud or the like.</p>

<p>On Unix systems, the <code>/tmp</code> directory was the de facto scratch space, but with the sandboxed containers of iOS and OS X apps today, a hard-coded path just won't cut it.</p>

<p><code>NSTemporaryDirectory</code> is a Foundation function that returns the directory designated for writing short-lived files on the targeted platform.</p>

<h3><a id="user-content-a-wild-goose-chase" class="anchor" href="#a-wild-goose-chase" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A Wild Goose Chase</h3>

<p>In recent years, Apple has pushed to extricate filesystem path operations from <code>NSString</code> APIs, recommending that users switch to using <code>NSURL</code> and <code>NSURL</code>-based APIs for classes like <code>NSFileManager</code>. Unfortunately, the migration has not been entirely smooth.</p>

<p>Consider the documentation for <code>NSTemporaryDirectory</code>:</p>

<blockquote>
<p>See the <code>NSFileManager</code> method <code>URLForDirectory:inDomain:appropriateForURL:create:error:</code> for the preferred means of finding the correct temporary directory.</p>
</blockquote>

<p>Alright, fair enough. Let's see what's going on with <code>NSFileManager -URLForDirectory:inDomain:appropriateForURL:create:error:</code>:</p>

<blockquote>
<p>You can also use this method to create a new temporary directory for storing things like autosave files; to do so, specify <code>NSItemReplacementDirectory</code> for the directory parameter, <code>NSUserDomainMask</code> for the <code>domain</code> parameter, and a valid parent directory for the <code>url</code> parameter. After locating (or creating) the desired directory, this method returns the URL for that directory.</p>
</blockquote>

<p>Huh? Even after reading through that a few times, it's still unclear how to use this, or what the expected behavior is. A quick search through the mailing lists <a href="http://lists.apple.com/archives/cocoa-dev/2012/Apr/msg00117.html">reaffirms</a> this <a href="http://lists.apple.com/archives/cocoa-dev/2012/Feb/msg00186.html">confusion</a>.</p>

<p><em>Actually</em>, this method appears to be intended for moving <em>existing</em> temporary files to a permanent location on disk with <code>-replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:</code>. Not exactly what we're looking for.</p>

<p>So much for the <code>NSString</code> filesystem API migration. Let's stick to something that works:</p>

<div class="highlight highlight-source-swift"><pre>NSURL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: <span class="pl-c1">true</span>)</pre></div>

<div class="highlight highlight-source-objc"><pre>[<span class="pl-c1">NSURL</span> <span class="pl-c1">fileURLWithPath:</span><span class="pl-c1">NSTemporaryDirectory</span>() <span class="pl-c1">isDirectory:</span><span class="pl-c1">YES</span>];</pre></div>

<h2><a id="user-content-generating-a-unique-directory-or-file-name" class="anchor" href="#generating-a-unique-directory-or-file-name" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generating a Unique Directory or File Name</h2>

<p>With a place to call home (temporarily), the next step is to figure out what to name our temporary file. We don't really care what temporary files are named—the only real concern is that they're unique, so as to not interfere with, or be interfered by, any other temporary files.</p>

<p>The best way to generate a unique identifier is to use the <code>globallyUniqueString</code> method on <code>NSProcessInfo</code></p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> identifier <span class="pl-k">=</span> NSProcessInfo<span class="pl-k">.</span>processInfo()<span class="pl-k">.</span>globallyUniqueString</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *identifier = [[<span class="pl-c1">NSProcessInfo</span> <span class="pl-c1">processInfo</span>] <span class="pl-c1">globallyUniqueString</span>];</pre></div>

<p>This will return a string in the format: <code>5BD255F4-CA55-4B82-A555-0F4BC5CA2AD6-479-0000018E14D059CC</code></p>

<blockquote>
<p>Other sources advise the direct invocation of the <code>mktemp(3)</code> system command in order to mitigate potential conflicts. However,  using <code>NSProcessInfo -globallyUniqueString</code> to generate unique names is extremely unlikely to result in a collision.</p>
</blockquote>

<p>Alternatively, <code>NSUUID</code> (<a href="http://nshipster.com/uuid-udid-unique-identifier">discussed previously</a>) also produces workable results, assuming that you're not doing anything <em>too</em> crazy.</p>

<div class="highlight highlight-source-swift"><pre>NSUUID()<span class="pl-k">.</span>UUIDString</pre></div>

<div class="highlight highlight-source-objc"><pre>[[<span class="pl-c1">NSUUID</span> <span class="pl-c1">UUID</span>] <span class="pl-c1">UUIDString</span>]</pre></div>

<p>This produces a string in the format: <code>22361D15-E17B-4C48-AEA6-C73BBEA17011</code></p>

<h2><a id="user-content-creating-a-temporary-file-path" class="anchor" href="#creating-a-temporary-file-path" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a Temporary File Path</h2>

<p>Using the aforementioned technique for generating unique identifiers, we can create unique temporary file paths:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> fileName <span class="pl-k">=</span> <span class="pl-c1">String</span>(format: <span class="pl-s"><span class="pl-pds">"</span>%@_%@<span class="pl-pds">"</span></span>, NSProcessInfo<span class="pl-k">.</span>processInfo()<span class="pl-k">.</span>globallyUniqueString, <span class="pl-s"><span class="pl-pds">"</span>file.txt<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> fileURL <span class="pl-k">=</span> NSURL(fileURLWithPath: NSTemporaryDirectory())<span class="pl-k">.</span>URLByAppendingPathComponent(fileName)</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *fileName = [<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span>_<span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [[<span class="pl-c1">NSProcessInfo</span> <span class="pl-c1">processInfo</span>] <span class="pl-c1">globallyUniqueString</span>], <span class="pl-s"><span class="pl-pds">@"</span>file.txt<span class="pl-pds">"</span></span>];
<span class="pl-c1">NSURL</span> *fileURL = [<span class="pl-c1">NSURL</span> <span class="pl-c1">fileURLWithPath:</span>[<span class="pl-c1">NSTemporaryDirectory</span>() <span class="pl-c1">stringByAppendingPathComponent:</span>fileName]];</pre></div>

<h2><a id="user-content-creating-a-temporary-directory" class="anchor" href="#creating-a-temporary-directory" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a Temporary Directory</h2>

<p>In situations where many temporary files might be created by a process, it may be a good idea to create a temporary sub-directory, which could then be removed for easy cleanup.</p>

<p>Creating a temporary directory is no different than any other invocation of <code>NSFileManager -createDirectoryAtURL:withIntermediateDirectories:attributes:error:</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> directoryURL <span class="pl-k">=</span> NSURL(fileURLWithPath: NSTemporaryDirectory())<span class="pl-k">.</span>URLByAppendingPathComponent(NSProcessInfo<span class="pl-k">.</span>processInfo()<span class="pl-k">.</span>globallyUniqueString, isDirectory: <span class="pl-c1">true</span>)
<span class="pl-k">do</span> {
    <span class="pl-k">try</span> NSFileManager<span class="pl-k">.</span>defaultManager()<span class="pl-k">.</span>createDirectoryAtURL(directoryURL, withIntermediateDirectories: <span class="pl-c1">true</span>, attributes: <span class="pl-c1">nil</span>)
} <span class="pl-k">catch</span> {
    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSURL</span> *directoryURL = [<span class="pl-c1">NSURL</span> <span class="pl-c1">fileURLWithPath:</span>[<span class="pl-c1">NSTemporaryDirectory</span>() <span class="pl-c1">stringByAppendingPathComponent:</span>[[<span class="pl-c1">NSProcessInfo</span> <span class="pl-c1">processInfo</span>] <span class="pl-c1">globallyUniqueString</span>]] <span class="pl-c1">isDirectory:</span><span class="pl-c1">YES</span>];
[[<span class="pl-c1">NSFileManager</span> <span class="pl-c1">defaultManager</span>] <span class="pl-c1">createDirectoryAtURL:</span>directoryURL <span class="pl-c1">withIntermediateDirectories:</span><span class="pl-c1">YES</span> <span class="pl-c1">attributes:</span><span class="pl-c1">nil</span> <span class="pl-c1">error:</span>&amp;error];</pre></div>

<p>And, of course, temporary file paths relative to this directory can be created with <code>URLByAppendingPathComponent:</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> fileURL <span class="pl-k">=</span> directoryURL<span class="pl-k">.</span>URLByAppendingPathComponent(fileName)</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSURL</span> *fileURL = [directoryURL <span class="pl-c1">URLByAppendingPathComponent:</span>fileName];</pre></div>

<h2><a id="user-content-writing-to-a-temporary-file" class="anchor" href="#writing-to-a-temporary-file" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing to a Temporary File</h2>

<p>Files don't exist on the file system until a particular file path is either touched or written to.</p>

<h3><a id="user-content-nsdata--writetourloptionserror" class="anchor" href="#nsdata--writetourloptionserror" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NSData -writeToURL:options:error</h3>

<p>There are several ways in which data is written to disk in Foundation. The most straightforward of which is <code>NSData -writeToURL:options:error</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> data: NSData <span class="pl-k">=</span> <span class="pl-k">...</span>
<span class="pl-k">do</span> {
    <span class="pl-k">try</span> data<span class="pl-k">.</span>writeToURL(fileURL, options: <span class="pl-k">.</span>AtomicWrite)
} <span class="pl-k">catch</span> {
    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSData</span> *data = ...;
<span class="pl-c1">NSError</span> *error = <span class="pl-c1">nil</span>;
[data <span class="pl-c1">writeToURL:</span>fileURL <span class="pl-c1">options:</span>NSDataWritingAtomic <span class="pl-c1">error:</span>&amp;error];</pre></div>

<h3><a id="user-content-nsoutputstream" class="anchor" href="#nsoutputstream" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NSOutputStream</h3>

<p>For more advanced APIs, it is not uncommon to pass an <code>NSOutputStream</code> instance to direct the flow of data. Again, creating an output stream to a temporary file path is no different than any other kind of file path:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> outputStream <span class="pl-k">=</span> NSOutputStream(toFileAtPath: fileURL<span class="pl-k">.</span>absoluteString, append: <span class="pl-c1">false</span>)</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSOutputStream</span> *outputStream = [<span class="pl-c1">NSOutputStream</span> <span class="pl-c1">outputStreamToFileAtPath:</span>[fileURL <span class="pl-c1">absoluteString</span>] <span class="pl-c1">append:</span><span class="pl-c1">NO</span>];</pre></div>

<h3><a id="user-content-cleaning-up" class="anchor" href="#cleaning-up" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cleaning Up</h3>

<p>The final step is what makes a temporary file <em>actually temporary</em>: clean up.</p>

<p>Although files in a system-designated temporary directory make no guarantees about how long they'll exist before being deleted automatically by the operating system (up to a few days, according to scattered reports), it's still good practice to take care of it yourself once you're finished.</p>

<p>Do that with <code>NSFileManager -removeItemAtURL:</code>, which works for both a temporary file and a temporary directory:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">do</span> {
    <span class="pl-k">try</span> NSFileManager<span class="pl-k">.</span>defaultManager()<span class="pl-k">.</span>removeItemAtURL(fileURL)
} <span class="pl-k">catch</span> {
    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSError</span> *error = <span class="pl-c1">nil</span>;
[[<span class="pl-c1">NSFileManager</span> <span class="pl-c1">defaultManager</span>] <span class="pl-c1">removeItemAtURL:</span>fileURL <span class="pl-c1">error:</span>&amp;error];</pre></div>

<hr>

<p>"This too shall pass" is a mantra that acknowledges that all things are indeed temporary. Within the context of the application lifecycle, some things are more temporary than others, and it is in that knowledge that we act appropriately, seeking to find the right place, make a unique impact, and leave without a trace.</p>

<p>Perhaps we can learn something from this cycle in our own, brief and glorious lifecycle.</p>
</article></div>