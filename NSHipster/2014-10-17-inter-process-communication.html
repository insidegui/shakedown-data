<div class="announce instapaper_body md" data-path="2014-10-17-inter-process-communication.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Inter-Process Communication</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div></div></td>

  <td><div>cfhipsterref</div></td>

  <td><div>In many ways, the story of Apple has been about fusing together technologies through happy accidents of history to create something better than before: OS X as a hybrid of MacOS &amp; NeXTSTEP. Objective-C as the combination of Smalltalk's OOP paradigm and C. iCloud as the byproduct of MobileMe and actual clouds (presumably).</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>t.b.c.</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p><a href="{{ site.asseturl }}/cfhipsterref-illustration-postman.png" target="_blank"><img src="{{ site.asseturl }}/cfhipsterref-illustration-postman.png" width="151" height="300" alt="IPC Postman, illustrated by Conor Heelan" style="max-width:100%;"></a></p>

<p>In many ways, the story of Apple has been about fusing together technologies through happy accidents of history to create something better than before: OS X as a hybrid of MacOS &amp; NeXTSTEP. Objective-C as the combination of Smalltalk's OOP paradigm and C. iCloud as the byproduct of MobileMe and <em>actual</em> clouds (presumably).</p>

<p>While this is true for many aspects of Apple's technology stack, inter-process communication is a flagrant counter-example.</p>

<p>Rather than taking the best of what was available at each juncture, solutions just kinda piled up. As a result, a handful of overlapping, mutually-incompatible IPC technologies are scattered across various abstraction layers. Whereas all of these are available on OS X, only Grand Central Dispatch and Pasteboard (albeit to a lesser extent) can be used on iOS.[^1]</p>

<ul>
<li>Mach Ports</li>
<li>Distributed Notifications</li>
<li>Distributed Objects</li>
<li>AppleEvents &amp; AppleScript</li>
<li>Pasteboard</li>
<li>XPC</li>
</ul>

<p>Ranging from low-level kernel abstractions to high-level, object-oriented APIs, they each have particular performance and security characteristics. But fundamentally, they're all mechanisms for transmitting and receiving data from beyond a context boundary.</p>

<h2><a id="user-content-mach-ports" class="anchor" href="#mach-ports" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mach Ports</h2>

<p>All inter-process communication ultimately relies on functionality provided by Mach kernel APIs.</p>

<p>Mach ports are light-weight and powerful, but poorly documented</p>

<p>Sending a message over a given Mach port comes down to a single <code>mach_msg_send</code> call, but it takes a bit of configuration in order to build the message to be sent:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">natural_t</span> data;
<span class="pl-c1">mach_port_t</span> port;

<span class="pl-k">struct</span> {
    <span class="pl-c1">mach_msg_header_t</span> header;
    <span class="pl-c1">mach_msg_body_t</span> body;
    <span class="pl-c1">mach_msg_type_descriptor_t</span> type;
} message;

message.header = (<span class="pl-c1">mach_msg_header_t</span>) {
    .<span class="pl-smi">msgh_remote_port</span> = port,
    .<span class="pl-smi">msgh_local_port</span> = MACH_PORT_NULL,
    .<span class="pl-smi">msgh_bits</span> = <span class="pl-c1">MACH_MSGH_BITS</span>(MACH_MSG_TYPE_COPY_SEND, <span class="pl-c1">0</span>),
    .<span class="pl-smi">msgh_size</span> = <span class="pl-k">sizeof</span>(message)
};

message.body = (<span class="pl-c1">mach_msg_body_t</span>) {
    .<span class="pl-smi">msgh_descriptor_count</span> = <span class="pl-c1">1</span>
};

message.type = (<span class="pl-c1">mach_msg_type_descriptor_t</span>) {
    .<span class="pl-smi">pad1</span> = data,
    .<span class="pl-smi">pad2</span> = <span class="pl-k">sizeof</span>(data)
};

<span class="pl-c1">mach_msg_return_t</span> error = mach_msg_send(&amp;message.header);

<span class="pl-k">if</span> (error == MACH_MSG_SUCCESS) {
    <span class="pl-c">// ...</span>
}</pre></div>

<p>Things are a little easier on the receiving end, since the message only needs to be declared, not initialized:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">mach_port_t</span> port;

<span class="pl-k">struct</span> {
    <span class="pl-c1">mach_msg_header_t</span> header;
    <span class="pl-c1">mach_msg_body_t</span> body;
    <span class="pl-c1">mach_msg_type_descriptor_t</span> type;
    <span class="pl-c1">mach_msg_trailer_t</span> trailer;
} message;

<span class="pl-c1">mach_msg_return_t</span> error = mach_msg_receive(&amp;message.header);

<span class="pl-k">if</span> (error == MACH_MSG_SUCCESS) {
    <span class="pl-c1">natural_t</span> data = message.<span class="pl-smi">type</span>.<span class="pl-smi">pad1</span>;
    <span class="pl-c">// ...</span>
}</pre></div>

<p>Fortunately, higher-level APIs for Mach ports are provided by Core Foundation and Foundation. <code>CFMachPort</code> / <code>NSMachPort</code> are wrappers on top of the kernel APIs that can be used as a runloop source, while <code>CFMessagePort</code> / <code>NSMessagePort</code> facilitate synchronous communication between two ports.</p>

<p><code>CFMessagePort</code> is actually quite nice for simple one-to-one communication. In just a few lines of code, a local named port can be attached as a runloop source to have a callback run each time a message is received:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-c1">CFDataRef</span> <span class="pl-en">Callback</span>(<span class="pl-c1">CFMessagePortRef</span> port,
                          <span class="pl-c1">SInt32</span> messageID,
                          <span class="pl-c1">CFDataRef</span> data,
                          <span class="pl-k">void</span> *info)
{
    <span class="pl-c">// ...</span>
}

<span class="pl-c1">CFMessagePortRef</span> localPort =
    <span class="pl-en">CFMessagePortCreateLocal</span>(<span class="pl-c1">nil</span>,
                             <span class="pl-en">CFSTR</span>(<span class="pl-s"><span class="pl-pds">"</span>com.example.app.port.server<span class="pl-pds">"</span></span>),
                             Callback,
                             nil,
                             nil);

<span class="pl-c1">CFRunLoopSourceRef</span> runLoopSource =
    <span class="pl-en">CFMessagePortCreateRunLoopSource</span>(<span class="pl-c1">nil</span>, localPort, <span class="pl-c1">0</span>);

<span class="pl-en">CFRunLoopAddSource</span>(CFRunLoopGetCurrent(),
                   runLoopSource,
                   kCFRunLoopCommonModes);</pre></div>

<p>Sending data is straightforward as well. Just specify the remote port, the message payload, and timeouts for sending and receiving. <code>CFMessagePortSendRequest</code> takes care of the rest:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">CFDataRef</span> data;
<span class="pl-c1">SInt32</span> messageID = 0x1111; <span class="pl-c">// Arbitrary</span>
<span class="pl-c1">CFTimeInterval</span> timeout = <span class="pl-c1">10.0</span>;

<span class="pl-c1">CFMessagePortRef</span> remotePort =
    <span class="pl-en">CFMessagePortCreateRemote</span>(<span class="pl-c1">nil</span>,
                              <span class="pl-en">CFSTR</span>(<span class="pl-s"><span class="pl-pds">"</span>com.example.app.port.client<span class="pl-pds">"</span></span>));

<span class="pl-c1">SInt32</span> status =
    <span class="pl-en">CFMessagePortSendRequest</span>(remotePort,
                             messageID,
                             data,
                             timeout,
                             timeout,
                             <span class="pl-c1">NULL</span>,
                             <span class="pl-c1">NULL</span>);
<span class="pl-k">if</span> (status == <span class="pl-c1">kCFMessagePortSuccess</span>) {
    <span class="pl-c">// ...</span>
}</pre></div>

<h2><a id="user-content-distributed-notifications" class="anchor" href="#distributed-notifications" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Distributed Notifications</h2>

<p>There are many ways for objects to communicate with one another in Cocoa:</p>

<p>There is, of course, sending a message directly. There are also the target-action, delegate, and callbacks, which are all loosely-coupled, one-to-one design patterns. KVO allows for multiple objects to subscribe to events, but it strongly couples those objects together. Notifications, on the other hand, allow messages to be broadcast globally, and intercepted by any object that knows what to listen for.</p>

<p>Each application manages its own <code>NSNotificationCenter</code> instance for infra-application pub-sub. But there is also a lesser-known Core Foundation API, <code>CFNotificationCenterGetDistributedCenter</code> that allows notifications to be communicated system-wide as well.</p>

<p>To listen for notifications, add an observer to the distributed notification center by specifying the notification name to listen for, and a function pointer to execute each time a notification is received:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">Callback</span>(<span class="pl-c1">CFNotificationCenterRef</span> center,
                     <span class="pl-k">void</span> *observer,
                     <span class="pl-c1">CFStringRef</span> name,
                     <span class="pl-k">const</span> <span class="pl-k">void</span> *object,
                     <span class="pl-c1">CFDictionaryRef</span> userInfo)
{
    <span class="pl-c">// ...</span>
}

<span class="pl-c1">CFNotificationCenterRef</span> distributedCenter =
    <span class="pl-en">CFNotificationCenterGetDistributedCenter</span>();

<span class="pl-c1">CFNotificationSuspensionBehavior</span> behavior =
        <span class="pl-c1">CFNotificationSuspensionBehaviorDeliverImmediately</span>;

<span class="pl-en">CFNotificationCenterAddObserver</span>(distributedCenter,
                                <span class="pl-c1">NULL</span>,
                                Callback,
                                <span class="pl-en">CFSTR</span>(<span class="pl-s"><span class="pl-pds">"</span>notification.identifier<span class="pl-pds">"</span></span>),
                                NULL,
                                behavior);</pre></div>

<p>Sending a distributed notification is even simpler; just post the identifier, object, and user info:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">void</span> *object;
<span class="pl-c1">CFDictionaryRef</span> userInfo;

<span class="pl-c1">CFNotificationCenterRef</span> distributedCenter =
    <span class="pl-en">CFNotificationCenterGetDistributedCenter</span>();

<span class="pl-en">CFNotificationCenterPostNotification</span>(distributedCenter,
                                     <span class="pl-en">CFSTR</span>(<span class="pl-s"><span class="pl-pds">"</span>notification.identifier<span class="pl-pds">"</span></span>),
                                     object,
                                     userInfo,
                                     true);</pre></div>

<p>Of all of the ways to link up two applications, distributed notifications are by far the easiest. It wouldn't be a great idea to use them to send large payloads, but for simple tasks like synchronizing preferences or triggering a data fetch, distributed notifications are perfect.</p>

<h2><a id="user-content-distributed-objects" class="anchor" href="#distributed-objects" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Distributed Objects</h2>

<p>Distributed Objects (DO) is a remote messaging feature of Cocoa that had its heyday back in the mid-90's with NeXT. And though its not widely used any more, the dream of totally frictionless IPC is still unrealized in our modern technology stack.</p>

<p>Vending an object with DO is just a matter of setting up an <code>NSConnection</code> and registering it with a particular name:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">@protocol</span> Protocol;

<span class="pl-k">id</span> &lt;Protocol&gt; vendedObject;

<span class="pl-c1">NSConnection</span> *connection = [[<span class="pl-c1">NSConnection</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
[connection <span class="pl-c1">setRootObject:</span>vendedObject];
[connection <span class="pl-c1">registerName:</span><span class="pl-s"><span class="pl-pds">@"</span>server<span class="pl-pds">"</span></span>];</pre></div>

<p>Another application would then create a connection registered for that same registered name, and immediately get an atomic proxy that functioned as if it were that original object:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">id</span> proxy = [<span class="pl-c1">NSConnection</span> <span class="pl-c1">rootProxyForConnectionWithRegisteredName:</span><span class="pl-s"><span class="pl-pds">@"</span>server<span class="pl-pds">"</span></span> <span class="pl-c1">host:</span><span class="pl-c1">nil</span>];
[proxy <span class="pl-c1">setProtocolForProxy:</span><span class="pl-k">@protocol</span>(Protocol)];</pre></div>

<p>Any time a distributed object proxy is messaged, a Remote Procedure Call (RPC) would be made over the <code>NSConnection</code> to evaluate the message against the vended object and return the result back to the proxy.</p>

<p>Distributed Objects are simple, transparent, and robust. And they would have been a flagpole feature of Cocoa had any of it worked as advertised.</p>

<p>In reality, Distributed Objects can't be used like local objects, if only because any message sent to a proxy could result in an exception being thrown. Unlike other languages, Objective-C doesn't use exceptions for control flow. As a result, wrapping everything in a <code>@try/@catch</code> is a poor fit to the conventions of Cocoa.</p>

<p>DO is awkward for other reasons, too. The divide between objects and primitives is especially pronounced when attempting to marshal values across a connection. Also, connections are totally unencrypted, and the lack of extensibility for the underlying communication channels makes it a deal-breaker for most serious usage.</p>

<p>All that's really left are traces of the annotations used by Distributed Objects to specify the proxying behavior of properties and method parameters:</p>

<ul>
<li><code>in</code>: Argument is used as input, but not referenced later</li>
<li><code>out</code>: Argument is used to return a value by reference</li>
<li><code>inout</code>: Argument is used as input and returned by reference</li>
<li><code>const</code>: Argument is constant</li>
<li><code>oneway</code>: Return without blocking for result</li>
<li><code>bycopy</code>: Return a copy of the object</li>
<li><code>byref</code>: Return a proxy of the object</li>
</ul>

<h2><a id="user-content-appleevents--applescript" class="anchor" href="#appleevents--applescript" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AppleEvents &amp; AppleScript</h2>

<p>AppleEvents are the most enduring legacies of the classic Macintosh operating system. Introduced in System 7, AppleEvents allowed apps to be controlled locally using AppleScript, or remotely using a feature called Program Linking. To this day, AppleScript, using the Cocoa Scripting Bridge, remains the most direct way to programmatically interact with OS X applications.</p>

<p>That said, it's easily one of the weirdest technologies to work with.</p>

<p>AppleScript uses a natural language syntax, intended to be more accessible to non-programmers. And while it does succeed in communicating intent in a human-understandable way, it's a nightmare to write.</p>

<p>To get a better sense of the nature of the beast, here's how to tell Safari to open a URL in the active tab in the frontmost window:</p>

<div class="highlight highlight-source-applescript"><pre><span class="pl-k">tell</span> <span class="pl-c1">application</span> <span class="pl-s"><span class="pl-pds">"</span>Safari<span class="pl-pds">"</span></span>
  <span class="pl-k">set</span> <span class="pl-k">the</span> <span class="pl-c1">URL</span> <span class="pl-k">of</span> <span class="pl-k">the</span> <span class="pl-k">front</span> <span class="pl-c1">document</span> <span class="pl-k">to</span> <span class="pl-s"><span class="pl-pds">"</span>http://nshipster.com<span class="pl-pds">"</span></span>
<span class="pl-k">end tell</span></pre></div>

<p>In many ways, AppleScript's natural language syntax is more of a liability than an asset. English, much like any other spoken language, has a great deal of redundancy and ambiguity built into normal constructions. While this is perfectly acceptable for humans, computers have a tough time resolving all of this.</p>

<p>Even for a seasoned Objective-C developer, it's nearly impossible to write AppleScript without constantly referencing documentation or sample code.</p>

<p>Fortunately, the Scripting Bridge provides a proper programming interface for Cocoa applications.</p>

<h3><a id="user-content-cocoa-scripting-bridge" class="anchor" href="#cocoa-scripting-bridge" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cocoa Scripting Bridge</h3>

<p>In order to interact with an application through the Scripting Bridge, a programming interface must first be generated:</p>

<pre><code>$ sdef /Applications/Safari.app | sdp -fh --basename Safari
</code></pre>

<p><code>sdef</code> generates scripting definition files for an application. These files can then be piped into <code>sdp</code> to be converted into another formatâ€”in this case, a C header. The resulting <code>.h</code> file can then be added and <code>#import</code>-ed into a project to get a first-class object interface to that application.</p>

<p>Here's the same example as before, expressed using the Cocoa Scripting Bridge:</p>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">"</span>Safari.h<span class="pl-pds">"</span></span>

SafariApplication *safari = [SBApplication <span class="pl-c1">applicationWithBundleIdentifier:</span><span class="pl-s"><span class="pl-pds">@"</span>com.apple.Safari<span class="pl-pds">"</span></span>];

<span class="pl-k">for</span> (SafariWindow *window in safari.windows) {
    <span class="pl-k">if</span> (window.<span class="pl-smi">visible</span>) {
        window.<span class="pl-smi">currentTab</span>.<span class="pl-smi">URL</span> = [<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>http://nshipster.com<span class="pl-pds">"</span></span>];
        <span class="pl-k">break</span>;
    }
}</pre></div>

<p>It's a bit more verbose than AppleScript, but this is much easier to integrate into an existing codebase. It's also a lot clearer to understand how this same code could be adapted to slightly different behavior (though that could just be the effect of being more familiar with Objective-C).</p>

<p>Alas, AppleScript's star appears to be falling, as recent releases of OS X and iWork applications have greatly curtailed their scriptability. At this point, it's unlikely that adding support in your own applications will be worth it.</p>

<h2><a id="user-content-pasteboard" class="anchor" href="#pasteboard" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pasteboard</h2>

<p>Pasteboard is the most visible inter-process communication mechanism on OS X and iOS. Whenever a user copies or pastes a piece of text, an image, or a document between applications, an exchange of data from one process to another over mach ports is being mediated by the <code>com.apple.pboard</code> service.</p>

<p>On OS X there's <code>NSPasteboard</code>, and on iOS there's <code>UIPasteboard</code>. They're pretty much the same, although like most counterparts, iOS provides a cleaner, more modern set of APIs that are slightly less capable than what's found on OS X.</p>

<p>Programmatically writing to the Pasteboard is nearly as simple as invoking <code>Edit &gt; Copy</code> in a GUI application:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSImage</span> *image;

<span class="pl-c1">NSPasteboard</span> *pasteboard = [<span class="pl-c1">NSPasteboard</span> <span class="pl-c1">generalPasteboard</span>];
[pasteboard <span class="pl-c1">clearContents</span>];
[pasteboard <span class="pl-c1">writeObjects:</span>@[image]];</pre></div>

<p>The reciprocal paste action is a bit more involved, requiring an iteration over the Pasteboard contents:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSPasteboard</span> *pasteboard = [<span class="pl-c1">NSPasteboard</span> <span class="pl-c1">generalPasteboard</span>];

<span class="pl-k">if</span> ([pasteboard <span class="pl-c1">canReadObjectForClasses:</span>@[[<span class="pl-c1">NSImage</span> <span class="pl-c1">class</span>]] <span class="pl-c1">options:</span><span class="pl-c1">nil</span>]) {
    <span class="pl-c1">NSArray</span> *contents = [pasteboard <span class="pl-c1">readObjectsForClasses:</span>@[[<span class="pl-c1">NSImage</span> <span class="pl-c1">class</span>]] <span class="pl-c1">options:</span> <span class="pl-c1">nil</span>];
    <span class="pl-c1">NSImage</span> *image = [contents <span class="pl-c1">firstObject</span>];
}</pre></div>

<p>What makes Pasteboard especially compelling as a mechanism for transferring data is the notion of simultaneously providing multiple representations of content copied onto a pasteboard. For example, a selection of text may be copied as both rich text (RTF) and plain text (TXT), allowing, for example, a WYSIWYG editor to preserve style information by grabbing the rich text representation, and a code editor to use just the plain text representation.</p>

<p>These representations can even be provided on an on-demand basis by conforming to the <code>NSPasteboardItemDataProvider</code> protocol. This allows derivative representations, such as plain text from rich text, to be generated only as necessary.</p>

<p>Each representation is identified by a Unique Type Identifier (UTI), a concept discussed in greater detail in the next chapter.</p>

<h2><a id="user-content-xpc" class="anchor" href="#xpc" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>XPC</h2>

<p>XPC is the state-of-the-art for inter-process communication in the SDKs. Its architectural goals are to avoid long-running process, to adapt to the available resources, and to lazily initialize wherever possible. The motivation to incorporate XPC into an application is not to do things that are otherwise impossible, but to provide better privilege separation and fault isolation for inter-process communication.</p>

<p>It's a replacement for <code>NSTask</code>, and a whole lot more.</p>

<p>Introduced in 2011, XPC has provided the infrastructure for the App Sandbox on OS X, Remote View Controllers on iOS, and App Extensions on both. It is also widely used by system frameworks and first-party applications:</p>

<div class="highlight highlight-source-shell"><pre>$ find /Applications -name <span class="pl-cce">\*</span>.xpc</pre></div>

<p>By surveying the inventory of XPC services in the wild, one can get a much better understanding of opportunities to use XPC in their own application. Common themes in applications emerge, like services for image and video conversion, system calls, webservice integration, and 3rd party authentication.</p>

<p>XPC takes responsibility for both inter-process communication and service lifecycle management. Everything from registering a service, getting it running, and communicating with other services is handled by <code>launchd</code>. An XPC service can be launched on demand, or restarted if they crash, or terminated if they idle. As such, services should be designed to be completely stateless, so as to allow for sudden termination at any point of execution.</p>

<p>As part of the new security model adopted by iOS and backported in OS X, XPC services are run with the most restricted environment possible by default: no file system access, no network access, and no root privilege escalation. Any capabilities must be whitelisted by a set of entitlements.</p>

<p>XPC can be accessed through either the <code>libxpc</code> C API, or the <code>NSXPCConnection</code> Objective-C API.</p>

<p>XPC services either reside within an application bundle or are advertised to run in the background using launchd.</p>

<p>Services call <code>xpc_main</code> with an event handler to receive new XPC connections:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">connection_handler</span>(<span class="pl-c1">xpc_connection_t</span> peer) {
    <span class="pl-c1">xpc_connection_set_event_handler</span>(peer, ^(<span class="pl-c1">xpc_object_t</span> event) {
        <span class="pl-c1">peer_event_handler</span>(peer, event);
    });

    <span class="pl-c1">xpc_connection_resume</span>(peer);
}

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">const</span> <span class="pl-k">char</span> *argv[]) {
   <span class="pl-c1">xpc_main</span>(connection_handler);
   <span class="pl-c1">exit</span>(EXIT_FAILURE);
}</pre></div>

<p>Each XPC connection is one-to-one, meaning that the service operates on distinct connections, with each call to <code>xpc_connection_create</code> creating a new peer.  :</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">xpc_connection_t</span> c = xpc_connection_create(<span class="pl-s"><span class="pl-pds">"</span>com.example.service<span class="pl-pds">"</span></span>, <span class="pl-c1">NULL</span>);
<span class="pl-en">xpc_connection_set_event_handler</span>(c, ^(<span class="pl-c1">xpc_object_t</span> event) {
    <span class="pl-c">// ...</span>
});
<span class="pl-en">xpc_connection_resume</span>(c);</pre></div>

<p>When a message is sent over an XPC connection, it is automatically dispatched onto a queue managed by the runtime. As soon as the connection is opened on the remote end, messages are dequeued and sent.</p>

<p>Each message is a dictionary, with string keys and strongly-typed values:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">xpc_dictionary_t</span> message = xpc_dictionary_create(<span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>);
<span class="pl-en">xpc_dictionary_set_uint64</span>(message, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>);
<span class="pl-en">xpc_connection_send_message</span>(c, message);
<span class="pl-en">xpc_release</span>(message)</pre></div>

<p>XPC objects operate on the following primitive types:</p>

<ul>
<li>Data</li>
<li>Boolean</li>
<li>Double</li>
<li>String</li>
<li>Signed Integer</li>
<li>Unsigned Integer</li>
<li>Date</li>
<li>UUID</li>
<li>Array</li>
<li>Dictionary</li>
<li>Null</li>
</ul>

<p>XPC offers a convenient way to convert from the <code>dispatch_data_t</code> data type, which simplifies the workflow from GCD to XPC:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">void</span> *buffer;
<span class="pl-c1">size_t</span> length;
<span class="pl-c1">dispatch_data_t</span> ddata =
    <span class="pl-en">dispatch_data_create</span>(buffer,
                         length,
                         DISPATCH_TARGET_QUEUE_DEFAULT,
                         DISPATCH_DATA_DESTRUCTOR_MUNMAP);

<span class="pl-c1">xpc_object_t</span> xdata = xpc_data_create_with_dispatch_data(ddata);</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">dispatch_queue_t</span> queue;
<span class="pl-en">xpc_connection_send_message_with_reply</span>(c, message, queue,
    ^(<span class="pl-c1">xpc_object_t</span> reply)
{
      <span class="pl-k">if</span> (<span class="pl-c1">xpc_get_type</span>(event) == XPC_TYPE_DICTIONARY) {
         <span class="pl-c">// ...</span>
      }
});</pre></div>

<h3><a id="user-content-registering-services" class="anchor" href="#registering-services" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Registering Services</h3>

<p>XPC can also be registered as launchd jobs, configured to automatically start on matching IOKit events, BSD notifications or CFDistributedNotifications. These criteria are specified in a service's <code>launchd.plist</code> file:</p>

<p>.launchd.plist</p>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">key</span>&gt;LaunchEvents&lt;/<span class="pl-ent">key</span>&gt;
&lt;<span class="pl-ent">dict</span>&gt;
  &lt;<span class="pl-ent">key</span>&gt;com.apple.iokit.matching&lt;/<span class="pl-ent">key</span>&gt;
  &lt;<span class="pl-ent">dict</span>&gt;
      &lt;<span class="pl-ent">key</span>&gt;com.example.device-attach&lt;/<span class="pl-ent">key</span>&gt;
      &lt;<span class="pl-ent">dict</span>&gt;
          &lt;<span class="pl-ent">key</span>&gt;idProduct&lt;/<span class="pl-ent">key</span>&gt;
          &lt;<span class="pl-ent">integer</span>&gt;2794&lt;/<span class="pl-ent">integer</span>&gt;
          &lt;<span class="pl-ent">key</span>&gt;idVendor&lt;/<span class="pl-ent">key</span>&gt;
          &lt;<span class="pl-ent">integer</span>&gt;725&lt;/<span class="pl-ent">integer</span>&gt;
          &lt;<span class="pl-ent">key</span>&gt;IOProviderClass&lt;/<span class="pl-ent">key</span>&gt;
          &lt;<span class="pl-ent">string</span>&gt;IOUSBDevice&lt;/<span class="pl-ent">string</span>&gt;
          &lt;<span class="pl-ent">key</span>&gt;IOMatchLaunchStream&lt;/<span class="pl-ent">key</span>&gt;
          &lt;<span class="pl-ent">true</span>/&gt;
          &lt;<span class="pl-ent">key</span>&gt;ProcessType&lt;/<span class="pl-ent">key</span>&gt;
          &lt;<span class="pl-ent">string</span>&gt;Adaptive&lt;/<span class="pl-ent">string</span>&gt;
      &lt;/<span class="pl-ent">dict</span>&gt;
  &lt;/<span class="pl-ent">dict</span>&gt;
&lt;/<span class="pl-ent">dict</span>&gt;</pre></div>

<p>A recent addition to <code>launchd</code> property lists is the <code>ProcessType</code> key, which describe at a high level the intended purpose of the launch agent. Based on the prescribed contention behavior, the operating system will automatically throttle CPU and I/O bandwidth accordingly.</p>

<h4><a id="user-content-process-types-and-contention-behavior" class="anchor" href="#process-types-and-contention-behavior" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Process Types and Contention Behavior</h4>

<table><thead>
<tr>
<th>Process Type</th>
<th>Contention Behavior</th>
</tr>
</thead><tbody>
<tr>
<td>Standard</td>
<td>Default value</td>
</tr>
<tr>
<td>Adaptive</td>
<td>Contend with apps when doing work on their behalf</td>
</tr>
<tr>
<td>Background</td>
<td>Never contend with apps</td>
</tr>
<tr>
<td>Interactive</td>
<td>Always contend with apps</td>
</tr>
</tbody></table>

<p>To register a service to run approximately every 5 minutes (allowing a grace period for system resources to become more available before scheduling at a more aggressive priority), a set of criteria is passed into <code>xpc_activity_register</code>:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">xpc_object_t</span> criteria = xpc_dictionary_create(<span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>);
<span class="pl-en">xpc_dictionary_set_int64</span>(criteria, XPC_ACTIVITY_INTERVAL, <span class="pl-c1">5</span> * <span class="pl-c1">60</span>);
<span class="pl-en">xpc_dictionary_set_int64</span>(criteria, XPC_ACTIVITY_GRACE_PERIOD, <span class="pl-c1">10</span> * <span class="pl-c1">60</span>);

<span class="pl-en">xpc_activity_register</span>(<span class="pl-s"><span class="pl-pds">"</span>com.example.app.activity<span class="pl-pds">"</span></span>,
                      criteria,
                      ^(<span class="pl-c1">xpc_activity_t</span> activity)
{
    <span class="pl-c">// Process Data</span>

    <span class="pl-c1">xpc_activity_set_state</span>(activity, XPC_ACTIVITY_STATE_CONTINUE);

    <span class="pl-c1">dispatch_async</span>(<span class="pl-c1">dispatch_get_main_queue</span>(), ^{
        <span class="pl-c">// Update UI</span>

        <span class="pl-c1">xpc_activity_set_state</span>(activity, XPC_ACTIVITY_STATE_DONE);
    });
});</pre></div>
</article></div>