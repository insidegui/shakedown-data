<div class="announce instapaper_body md" data-path="2014-08-11-swift-operators.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Swift Operators</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Swift</div></td>

  <td><div>swift</div></td>

  <td><div>Operators in Swift are among the most interesting and indeed controversial features of this new language.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>September 8, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>What would a program be without statements? A mish-mash of classes, namespaces, conditionals, loops, and namespaces signifying nothing.</p>

<p>Statements are what do the work of a program. They are the very execution of an executable.</p>

<p>If we were to take apart a statement—say <code>1 + 2</code>—decomposing it into its constituent parts, we would find an operator and operands:</p>

<table><thead>
<tr>
<th align="center">1</th>
<th align="center">+</th>
<th align="center">2</th>
</tr>
</thead><tbody>
<tr>
<td align="center">left operand</td>
<td align="center">operator</td>
<td align="center">right operand</td>
</tr>
</tbody></table>

<p>Although expressions are flat, the compiler will construct a tree representation, or AST:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/swift-operators-one-plus-two.svg" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/swift-operators-one-plus-two.svg" alt="1 + 2 AST" style="max-width:100%;"></a></p>

<p>Compound statements, like <code>1 + 2 + 3</code></p>

<table><thead>
<tr>
<th align="center">(1 + 2)</th>
<th align="center">+</th>
<th align="center">3</th>
</tr>
</thead><tbody>
<tr>
<td align="center">left operand</td>
<td align="center">operator</td>
<td align="center">right operand</td>
</tr>
</tbody></table>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/swift-operators-one-plus-two-plus-three.svg" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/swift-operators-one-plus-two-plus-three.svg" alt="1 + 2 + 3 AST" style="max-width:100%;"></a></p>

<p>Or, to take an even more complex statement, <code>1 + 2 * 3 % 4</code>, the compiler would use operator precedence to resolve the expression into a single statement:</p>

<table><thead>
<tr>
<th align="center">1</th>
<th align="center">+</th>
<th align="center">((2 * 3) % 4)</th>
</tr>
</thead><tbody>
<tr>
<td align="center">left operand</td>
<td align="center">operator</td>
<td align="center">right operand</td>
</tr>
</tbody></table>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/swift-operators-one-plus-two-times-three-mod-four.svg" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/swift-operators-one-plus-two-times-three-mod-four.svg" alt="1 + 2 * 3 % 4 AST" style="max-width:100%;"></a></p>

<p>Operator precedence rules, similar to the ones <a href="http://en.wikipedia.org/wiki/Order_of_operations">you learned in primary school</a>, provide a canonical ordering for any compound statement:</p>

<pre><code>1 + 2 * 3 % 4
1 + ((2 * 3) % 4)
1 + (6 % 4)
1 + 2
</code></pre>

<p>However, consider the statement <code>5 - 2 + 3</code>. Addition and subtraction have the same operator precedence, but evaluating the subtraction first <code>(5 - 2) + 3</code> yields 6, whereas evaluating subtraction after addition, <code>5 - (2 + 3)</code>, yields <code>0</code>. In code, arithmetic operators are left-associative, meaning that the left hand side will evaluate first (<code>(5 - 2) + 3</code>).</p>

<p>Operators can be unary and ternary as well. The <code>!</code> prefix operator negates a logical value of the operand. The <code>?:</code> ternary operator collapses an <code>if-else</code> expression, by evaluating the statement to the left of the <code>?</code> in order to either execute the statement left of the <code>:</code> (statement is <code>true</code>) or right of <code>:</code> (statement is <code>false</code>).</p>

<h2><a id="user-content-swift-operators" class="anchor" href="#swift-operators" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Swift Operators</h2>

<p>Swift includes a set of operators that should be familiar to C or Objective-C developers, with a few additions (notably, the range and nil coalescing operators):</p>

<h3><a id="user-content-prefix" class="anchor" href="#prefix" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefix</h3>

<ul>
<li><code>+</code>: Unary plus</li>
<li><code>-</code>: Unary minus</li>
<li><code>!</code>: Logical NOT</li>
<li><code>~</code>: Bitwise NOT</li>
</ul>

<h3><a id="user-content-infix" class="anchor" href="#infix" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Infix</h3>

<table>
    <tbody><tr>
        <th colspan="2">Exponentiative <tt>{precedence 160}</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>&lt;&lt;</tt></td><td>Bitwise left shift</td></tr>
        <tr><td><tt>&gt;&gt;</tt></td><td>Bitwise right shift</td></tr>
    </tbody>


    <tbody><tr>
        <th colspan="2">Multiplicative <tt>{ associativity left precedence 150 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>*</tt></td><td>Multiply</td></tr>
        <tr><td><tt>/</tt></td><td>Divide</td></tr>
        <tr><td><tt>%</tt></td><td>Remainder</td></tr>
        <tr><td><tt>&amp;*</tt></td><td>Multiply, ignoring overflow</td></tr>
        <tr><td><tt>&amp;/</tt></td><td>Divide, ignoring overflow</td></tr>
        <tr><td><tt>&amp;%</tt></td><td>Remainder, ignoring overflow</td></tr>
        <tr><td><tt>&amp;</tt></td><td>Bitwise AND</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Additive <tt>{ associativity left precedence 140 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>+</tt></td><td>Add</td></tr>
        <tr><td><tt>-</tt></td><td>Subtract</td></tr>
        <tr><td><tt>&amp;+</tt></td><td>Add with overflow</td></tr>
        <tr><td><tt>&amp;-</tt></td><td>Subtract with overflow</td></tr>
        <tr><td><tt>|</tt></td><td>Bitwise OR</td></tr>
        <tr><td><tt>^</tt></td><td>Bitwise XOR</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Range <tt>{ precedence 135 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>..&lt;</tt></td><td>Half-open range</td></tr>
        <tr><td><tt>...</tt></td><td>Closed range</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Cast <tt>{ precedence 132 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>is</tt></td><td>Type check</td></tr>
        <tr><td><tt>as</tt></td><td>Type cast</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Comparative <tt>{ precedence 130 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>&lt;</tt></td><td>Less than</td></tr>
        <tr><td><tt>&lt;=</tt></td><td>Less than or equal</td></tr>
        <tr><td><tt>&gt;</tt></td><td>Greater than</td></tr>
        <tr><td><tt>&gt;=</tt></td><td>Greater than or equal</td></tr>
        <tr><td><tt>==</tt></td><td>Equal</td></tr>
        <tr><td><tt>!=</tt></td><td>Not equal</td></tr>
        <tr><td><tt>===</tt></td><td>Identical</td></tr>
        <tr><td><tt>!==</tt></td><td>Not identical</td></tr>
        <tr><td><tt>~=</tt></td><td>Pattern match</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Conjunctive <tt>{ associativity left precedence 120 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>&amp;&amp;</tt></td><td>Logical AND</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Disjunctive <tt>{ associativity left precedence 110 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>||</tt></td><td>Logical OR</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Nil Coalescing <tt>{ associativity right precedence 110 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>??</tt></td><td>Nil coalescing</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Ternary Conditional <tt>{ associativity right precedence 100 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>?:</tt></td><td>Ternary conditional</td></tr>
    </tbody>

    <tbody><tr>
        <th colspan="2">Assignment <tt>{ associativity right precedence 90 }</tt></th>
    </tr>
    </tbody><tbody>
        <tr><td><tt>=</tt></td><td>Assign</td></tr>
        <tr><td><tt>*=</tt></td><td>Multiply and assign</td></tr>
        <tr><td><tt>/=</tt></td><td>Divide and assign</td></tr>
        <tr><td><tt>%=</tt></td><td>Remainder and assign</td></tr>
        <tr><td><tt>+=</tt></td><td>Add and assign</td></tr>
        <tr><td><tt>-=</tt></td><td>Subtract and assign</td></tr>
        <tr><td><tt>&lt;&lt;=</tt></td><td>Left bit shift and assign</td></tr>
        <tr><td><tt>&gt;&gt;=</tt></td><td>Right bit shift and assign</td></tr>
        <tr><td><tt>&amp;=</tt></td><td>Bitwise AND and assign</td></tr>
        <tr><td><tt>^=</tt></td><td>Bitwise XOR and assign</td></tr>
        <tr><td><tt>|=</tt></td><td>Bitwise OR and assign</td></tr>
    </tbody>
</table>

<h3><a id="user-content-member-functions" class="anchor" href="#member-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Member Functions</h3>

<p>In addition to the aforementioned standard operators, there are some <em>de facto</em> operators defined by the language:</p>

<ul>
<li><code>.</code>: Member Access</li>
<li><code>?</code>: Optional</li>
<li><code>!</code>: Forced-Value</li>
<li><code>[]</code>: Subscript</li>
<li><code>[]=</code>: Subscript Assignment</li>
</ul>

<h2><a id="user-content-overloading" class="anchor" href="#overloading" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overloading</h2>

<p>Swift has the ability to overload operators such that existing operators, like <code>+</code>, can be made to work with additional types.</p>

<p>To overload an operator, simply define a new function for the operator symbol, taking the appropriate number and type of arguments.</p>

<p>For example, to overload <code>*</code> to repeat a string a specified number of times:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">*</span> (<span class="pl-k">left</span>: <span class="pl-c1">String</span>, <span class="pl-k">right</span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
    <span class="pl-k">if</span> <span class="pl-k">right</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span> {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
    }

    <span class="pl-k">var</span> result <span class="pl-k">=</span> <span class="pl-k">left</span>
    <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">..&lt;</span><span class="pl-k">right</span> {
        result <span class="pl-k">+=</span> <span class="pl-k">left</span>
    }

    <span class="pl-k">return</span> result
}

<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">6</span> 
<span class="pl-c">// "aaaaaa"</span></pre></div>

<p>This is, however, a controversial language feature.</p>

<p>Any C++ developer would be all too eager to regale you with horror stories of the non-deterministic havoc this can wreak.</p>

<p>Consider the following statement:</p>

<div class="highlight highlight-source-swift"><pre>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">+</span> [<span class="pl-c1">3</span>, <span class="pl-c1">4</span>] <span class="pl-c">// [1, 2, 3, 4]</span></pre></div>

<p>By default, the <code>+</code> operator acts on two arrays by appending the right hand to the left hand.</p>

<p>However, when overridden thusly:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">+</span>(<span class="pl-k">left</span>: [<span class="pl-c1">Double</span>], <span class="pl-k">right</span>: [<span class="pl-c1">Double</span>]) <span class="pl-k">-&gt;</span> [<span class="pl-c1">Double</span>] {
    <span class="pl-k">var</span> sum <span class="pl-k">=</span> [<span class="pl-c1">Double</span>](count: <span class="pl-k">left</span><span class="pl-k">.</span><span class="pl-c1">count</span>, repeatedValue: <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">0</span>)
    <span class="pl-k">for</span> (i, _) <span class="pl-k">in</span> enumerate(<span class="pl-k">left</span>) {
        sum[i] <span class="pl-k">=</span> <span class="pl-k">left</span>[i] <span class="pl-k">+</span> <span class="pl-k">right</span>[i]
    }

    <span class="pl-k">return</span> sum
}</pre></div>

<p>The result is now an array with the pairwise sums of each element, expressed as <code>Double</code>:</p>

<div class="highlight highlight-source-swift"><pre>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">+</span> [<span class="pl-c1">3</span>, <span class="pl-c1">4</span>] <span class="pl-c">// [4.0, 6.0]</span></pre></div>

<p>And if the operator were also overloaded to work with <code>Int</code> types, with:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">+</span>(<span class="pl-k">left</span>: [<span class="pl-c1">Int</span>], <span class="pl-k">right</span>: [<span class="pl-c1">Int</span>]) <span class="pl-k">-&gt;</span> [<span class="pl-c1">Int</span>] {
    <span class="pl-k">var</span> sum <span class="pl-k">=</span> [<span class="pl-c1">Int</span>](count: <span class="pl-k">left</span><span class="pl-k">.</span><span class="pl-c1">count</span>, repeatedValue: <span class="pl-c1">0</span>)
    <span class="pl-k">for</span> (i, _) <span class="pl-k">in</span> enumerate(<span class="pl-k">left</span>) {
        sum[i] <span class="pl-k">=</span> <span class="pl-k">left</span>[i] <span class="pl-k">+</span> <span class="pl-k">right</span>[i]
    }

    <span class="pl-k">return</span> sum
}</pre></div>

<p>The result would then be an array of pairwise sums, expressed as <code>Int</code>.</p>

<div class="highlight highlight-source-swift"><pre>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">+</span> [<span class="pl-c1">3</span>, <span class="pl-c1">4</span>] <span class="pl-c">// [4, 6]</span></pre></div>

<p>Herein lies the original sin of operator overloading: <strong>ambiguous semantics</strong>.</p>

<p>Having been limited to basic arithmetic operators across many years and programming languages, overloading of operators has become commonplace:</p>

<ul>
<li>Computing Sum of Integers: <code>1 + 2 // 3</code></li>
<li>Computing Sum of Floats: <code>1.0 + 2.0 // 3.0</code></li>
<li>Appending to String: <code>"a" + "b" // "ab"</code></li>
<li>Appending to Array: <code>["foo"] + ["bar"] // ["foo", "bar"]</code></li>
</ul>

<p>It makes sense that <code>+</code> would work on numbers—that's just math. But think about it: <em>why should adding two strings together concatenate them</em>?  <code>1 + 2</code> isn't <code>12</code> (<a href="https://www.destroyallsoftware.com/talks/wat">except in Javascript</a>). Is this really intuitive, or is it just familiar.</p>

<blockquote>
<p>PHP uses <code>.</code> for string concatenation (which is objectively a terrible idea). Objective-C allows consecutive string literals to be appended with whitespace.</p>
</blockquote>

<p>In the run-up to its initial stable release, Swift still has some work to do in resolving ambiguities in operator semantics. Recent changes, such as the addition of the <code>nil</code> coalescing operator (<code>??</code>), and the decision for optionals not to conform to <code>BooleanType</code> (confusing in the case of <code>Bool?</code>) are encouraging, and demonstrate the need for us to collectively ask ourselves <em>"does this really make sense?"</em>, and file radars appropriately.</p>

<blockquote>
<p>I'm specifically concerned about the semantics of array operators, as demonstrated in the previous example. My 2 cents: arrays should forego the <code>+</code> and <code>-</code> operators in lieu of <code>&lt;&lt;</code>:</p>
</blockquote>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">&lt;&lt;</span>&lt;T&gt; (<span class="pl-en">inout</span> <span class="pl-smi">left</span>: [T], <span class="pl-k">right</span>: [T]) <span class="pl-k">-&gt;</span> [T] {
    <span class="pl-k">left</span><span class="pl-k">.</span><span class="pl-c1">extend</span>(<span class="pl-k">right</span>)
    <span class="pl-k">return</span> <span class="pl-k">left</span>
}

<span class="pl-k">func</span> <span class="pl-en">&lt;&lt;</span>&lt;T&gt; (<span class="pl-en">inout</span> <span class="pl-smi">left</span>: [T], <span class="pl-k">right</span>: T) <span class="pl-k">-&gt;</span> [T] {
    <span class="pl-k">left</span><span class="pl-k">.</span>append(<span class="pl-k">right</span>)
    <span class="pl-k">return</span> <span class="pl-k">left</span>
}</pre></div>

<h2><a id="user-content-custom-operators" class="anchor" href="#custom-operators" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Operators</h2>

<p>An even more controversial and exciting feature is the ability to define custom operators.</p>

<p>Consider the arithmetic operator found in many programming languages, but missing in Swift is <code>**</code>, which raises the left hand number to the power of the right hand number (the <code>^</code> symbol, commonly used for superscripts, is already used to perform a <a href="http://en.wikipedia.org/wiki/Bitwise_operation#XOR">bitwise XOR</a>).</p>

<p>To add this operator in Swift, first declare the operator:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">infix</span> <span class="pl-k">operator</span> <span class="pl-k">**</span> { <span class="pl-k">associativity</span> <span class="pl-k">left</span> <span class="pl-k">precedence</span> <span class="pl-c1">160</span> }</pre></div>

<ul>
<li><code>infix</code> specifies that it is a binary operator, taking a left and right hand argument</li>
<li><code>operator</code> is a reserved word that must be preceded with either <code>prefix</code>, <code>infix</code>, or <code>postfix</code></li>
<li><code>**</code> is the operator itself</li>
<li><code>associativity left</code> means that operations are grouped from the left</li>
<li><code>precedence 160</code> means that it will evaluate with the same precedence as the exponential operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> (left and right bitshift).</li>
</ul>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">**</span> (<span class="pl-k">left</span>: <span class="pl-c1">Double</span>, <span class="pl-k">right</span>: <span class="pl-c1">Double</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Double</span> {
    <span class="pl-k">return</span> pow(<span class="pl-k">left</span>, <span class="pl-k">right</span>)
}

<span class="pl-c1">2</span> <span class="pl-k">**</span> <span class="pl-c1">3</span> 
<span class="pl-c">// 8</span></pre></div>

<p>When creating custom operators, make sure to also create the corresponding assignment operator, if appropriate:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">infix</span> <span class="pl-k">operator</span> <span class="pl-k">**=</span> { <span class="pl-k">associativity</span> <span class="pl-k">right</span> <span class="pl-k">precedence</span> <span class="pl-c1">90</span> }
<span class="pl-k">func</span> <span class="pl-en">**=</span> (<span class="pl-en">inout</span> <span class="pl-smi">left</span>: <span class="pl-c1">Double</span>, <span class="pl-k">right</span>: <span class="pl-c1">Double</span>) {
    <span class="pl-k">left</span> <span class="pl-k">=</span> <span class="pl-k">left</span> <span class="pl-k">**</span> <span class="pl-k">right</span>
}</pre></div>

<blockquote>
<p>Note that <code>left</code> is <code>inout</code>, which makes sense, since assignment mutates the original value.</p>
</blockquote>

<h3><a id="user-content-custom-operators-with-protocol-and-method" class="anchor" href="#custom-operators-with-protocol-and-method" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Operators with Protocol and Method</h3>

<p>Function definitions for the operators themselves should be extremely simple—a single LOC, really. For anything more complex, some additional setup is warranted.</p>

<p>Take, for example, a custom operator, <code>=~</code>, which returns whether the left hand side matches a regular expression on the right hand side:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">protocol</span> RegularExpressionMatchable {
    <span class="pl-k">func</span> <span class="pl-en">match</span>(pattern: <span class="pl-c1">String</span>, options: NSRegularExpressionOptions) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span>
}

<span class="pl-k">extension</span> <span class="pl-c1">String</span>: RegularExpressionMatchable {
    <span class="pl-k">func</span> <span class="pl-en">match</span>(pattern: <span class="pl-c1">String</span>, options: NSRegularExpressionOptions <span class="pl-k">=</span> []) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
        <span class="pl-k">let</span> regex <span class="pl-k">=</span> <span class="pl-k">try</span> NSRegularExpression(pattern: pattern, options: options)
        <span class="pl-k">return</span> regex<span class="pl-k">.</span>numberOfMatchesInString(<span class="pl-k">self</span>, options: [], range: NSRange(location: <span class="pl-c1">0</span>, length: <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">distanceTo</span>(utf16<span class="pl-k">.</span><span class="pl-c1">count</span>))) <span class="pl-k">!=</span> <span class="pl-c1">0</span>
    }
}

<span class="pl-k">infix</span> <span class="pl-k">operator</span> <span class="pl-k">=~</span> { <span class="pl-k">associativity</span> <span class="pl-k">left</span> <span class="pl-k">precedence</span> <span class="pl-c1">130</span> }
<span class="pl-k">func</span> <span class="pl-en">=~</span>&lt;T: RegularExpressionMatchable&gt; (<span class="pl-k">left</span>: T, <span class="pl-k">right</span>: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">return</span> <span class="pl-k">try</span><span class="pl-k">!</span> <span class="pl-k">left</span><span class="pl-k">.</span>match(<span class="pl-k">right</span>, options: [])
}</pre></div>

<ul>
<li>First, a <code>RegularExpressionMatchable</code> <code>protocol</code> is declared, with a single method for matching regular expressions.</li>
<li>Next, an <code>extension</code> adding conformance to this <code>protocol</code> to <code>String</code> is declared, with a provided implementation of <code>match</code>, using <code>NSRegularExpression</code>.</li>
<li>Finally, the <code>=~</code> operator is declared and implemented on a generic type conforming to <code>RegularExpressionMatchable</code>.</li>
</ul>

<p>By doing this, a user has the option to use the <code>match</code> function instead of the operator. It also has the added benefit of greater flexibility in what options are passed into the method.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> cocoaClassPattern <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>^[A-Z]{2,}[A-Za-z0-9]+$<span class="pl-pds">"</span></span>

<span class="pl-k">try</span>? <span class="pl-s"><span class="pl-pds">"</span>NSHipster<span class="pl-pds">"</span></span><span class="pl-k">.</span>match(cocoaClassPattern)       <span class="pl-c">// true</span>
<span class="pl-s"><span class="pl-pds">"</span>NSHipster<span class="pl-pds">"</span></span> <span class="pl-k">=~</span> cocoaClassPattern                <span class="pl-c">// true</span></pre></div>

<p>This is all to say: <strong>a custom operator should only ever be provided as a convenience for an existing function.</strong></p>

<h3><a id="user-content-use-of-mathematical-symbols" class="anchor" href="#use-of-mathematical-symbols" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use of Mathematical Symbols</h3>

<p>Custom operators can contain any of the following ASCII characters /, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, or ~, or any of the Unicode characters in the "Math Symbols" character set.</p>

<p>This makes it possible to take the square root of a number with a single <code>√</code> prefix operator (<code>⌥v</code>):</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">prefix</span> <span class="pl-k">operator</span> √ {}
<span class="pl-k">prefix</span> <span class="pl-k">func</span> √ (number: <span class="pl-c1">Double</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Double</span> {
    <span class="pl-k">return</span> sqrt(number)
}

√<span class="pl-c1">4</span> 
<span class="pl-c">// 2</span></pre></div>

<p>Or consider the <code>±</code> operator, which can be used either as an <code>infix</code> or <code>prefix</code> to return a tuple with the sum and difference:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">infix</span> <span class="pl-k">operator</span> ± { <span class="pl-k">associativity</span> <span class="pl-k">left</span> <span class="pl-k">precedence</span> <span class="pl-c1">140</span> }
<span class="pl-k">func</span> ± (<span class="pl-k">left</span>: <span class="pl-c1">Double</span>, <span class="pl-k">right</span>: <span class="pl-c1">Double</span>) <span class="pl-k">-&gt;</span> (<span class="pl-c1">Double</span>, <span class="pl-c1">Double</span>) {
    <span class="pl-k">return</span> (<span class="pl-k">left</span> <span class="pl-k">+</span> <span class="pl-k">right</span>, <span class="pl-k">left</span> <span class="pl-k">-</span> <span class="pl-k">right</span>)
}

<span class="pl-k">prefix</span> <span class="pl-k">operator</span> ± {}
<span class="pl-k">prefix</span> <span class="pl-k">func</span> ± (value: <span class="pl-c1">Double</span>) <span class="pl-k">-&gt;</span> (<span class="pl-c1">Double</span>, <span class="pl-c1">Double</span>) {
    <span class="pl-k">return</span> <span class="pl-c1">0</span> ± value
}

<span class="pl-c1">2</span> ± <span class="pl-c1">3</span>
<span class="pl-c">// (5, -1)</span>

±<span class="pl-c1">4</span>
<span class="pl-c">// (4, -4)</span></pre></div>

<blockquote>
<p>For more examples of functions using mathematical notation in Swift, check out <a href="https://github.com/mattt/Euler">Euler</a>.</p>
</blockquote>

<p>Custom operators are hard to type, and therefore hard to use. <strong>Exercise restraint when using custom operators with exotic symbols</strong>. After all, code should not be copy-pasted.</p>

<hr>

<p>Operators in Swift are among the most interesting and indeed controversial features of this new language.</p>

<p>When overriding or defining new operators in your own code, make sure to follow these guidelines:</p>

<h2><a id="user-content-guidelines-for-swift-operators" class="anchor" href="#guidelines-for-swift-operators" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Guidelines for Swift Operators</h2>

<ol>
<li>Don't create an operator unless its meaning is obvious and undisputed. Seek out any potential conflicts to ensure semantic consistency.</li>
<li>Custom operators should only be provided as a convenience. Complex functionality should always be implemented in a function, preferably one specified as a generic using a custom protocol.</li>
<li>Pay attention to the precedence and associativity of custom operators. Find the closest existing class of operators and use the appropriate precedence value.</li>
<li>If it makes sense, be sure to implement assignment shorthand for a custom operator (e.g. <code>+=</code> for <code>+</code>).</li>
</ol>
</article></div>