<div class="announce instapaper_body md" data-path="2015-03-30-quick-look-debugging.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Quick Look Debugging</div></td>

  <td><div>Nate Cook</div></td>

  <td><div>Xcode</div></td>

  <td><div>Debugging can be an exercise in irony. We create programs that tell our pint-sized supercomputers to complete infinitely varied and incalculable tasks on our behalf, yet when trying to understand those same programs, we tell the computers to wait for *us.*</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.2</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Debugging can be an exercise in irony. We create programs that tell our pint-sized supercomputers to complete infinitely varied and incalculable tasks on our behalf, yet when trying to understand those same programs, we tell the computers to wait for <em>us.</em> </p>

<p>For example, suppose I'm trying to figure out why the <code>UINavigationBar</code> in my app doesn't appear as I expected. To investigate, I might use the debugger to look at the <code>UIColor</code> instance I'm setting on the navigation bar—what color <em>is</em> this, exactly?</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/quicklook-debug.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/quicklook-debug.gif" alt="UIColor in Debug" style="max-width:100%;"></a></p>

<p>Hold on! No more trying to figure out how those components add together. <em>There's a better way.</em></p>

<p>Since version 5, Xcode has shipped with Quick Look display in the debugger. Just as you can inspect the contents of a file on the Desktop with a quick tap of the space bar, in Xcode you can use Quick Look to see a visual representation of a variety of datatypes. Tapping the space bar on our <code>color</code> variable gives an instant answer—no off-the-top-of-your-head RGB calculations required:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/quicklook-color.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/quicklook-color.gif" alt="UIColor Quick Look" style="max-width:100%;"></a></p>

<hr>

<p>You can also invoke Quick Look while debugging directly from your code. Consider the following method, <code>buildPathWithRadius(_:steps:loopCount:)</code>. It creates a <code>UIBezierPath</code> of some kind, but you've forgotten which, and does this code even work?</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">buildPathWithRadius</span>(radius: CGFloat, steps: CGFloat, loopCount: CGFloat) <span class="pl-k">-&gt;</span> UIBezierPath {
    <span class="pl-k">let</span> away <span class="pl-k">=</span> radius <span class="pl-k">/</span> steps
    <span class="pl-k">let</span> around <span class="pl-k">=</span> loopCount <span class="pl-k">/</span> steps <span class="pl-k">*</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> CGFloat(M_PI)

    <span class="pl-k">let</span> points <span class="pl-k">=</span> map(<span class="pl-c1">stride</span>(from: <span class="pl-c1">1</span>, through: steps, by: <span class="pl-c1">1</span>)) { step <span class="pl-k">-&gt;</span> CGPoint <span class="pl-k">in</span>
        <span class="pl-k">let</span> x <span class="pl-k">=</span> cos(step <span class="pl-k">*</span> around) <span class="pl-k">*</span> step <span class="pl-k">*</span> away
        <span class="pl-k">let</span> y <span class="pl-k">=</span> sin(step <span class="pl-k">*</span> around) <span class="pl-k">*</span> step <span class="pl-k">*</span> away

        <span class="pl-k">return</span> CGPoint(x: x, y: y)
    }

    <span class="pl-k">let</span> path <span class="pl-k">=</span> UIBezierPath()
    path<span class="pl-k">.</span>moveToPoint(CGPoint<span class="pl-k">.</span>zeroPoint)
    <span class="pl-k">for</span> point <span class="pl-k">in</span> points {
        path<span class="pl-k">.</span>addLineToPoint(point)
    }

    <span class="pl-k">return</span> path
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (UIBezierPath *)buildPathWithRadius:(<span class="pl-c1">CGFloat</span>)radius steps:(<span class="pl-c1">CGFloat</span>)steps loopCount:(<span class="pl-c1">CGFloat</span>)loopCount {
    <span class="pl-c1">CGFloat</span> x, y;
    <span class="pl-c1">CGFloat</span> away = radius / steps;
    <span class="pl-c1">CGFloat</span> around = loopCount / steps * <span class="pl-c1">2</span> * M_PI;

    UIBezierPath *path = [UIBezierPath <span class="pl-c1">bezierPath</span>];
    [path <span class="pl-c1">moveToPoint:</span><span class="pl-c1">CGPointZero</span>];

    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">1</span>; i &lt;= steps; i++) {
        x = <span class="pl-c1">cos</span>(i * around) * i * away;
        y = <span class="pl-c1">sin</span>(i * around) * i * away;

        [path <span class="pl-c1">addLineToPoint:</span><span class="pl-c1">CGPointMake</span>(x, y)];
    }

    <span class="pl-k">return</span> path;
}</pre></div>

<p>To see the result, you could surely create a custom view for the bezier path or draw it into a <code>UIImage</code>. But better yet, you could insert a breakpoint at the end of the method and mouse over <code>path</code>:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/quicklook-spiral.gif" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/quicklook-spiral.gif" alt="Spiral UIBezierPath Quick Look" style="max-width:100%;"></a></p>

<p>Spiraltastic!</p>

<hr>

<h3><a id="user-content-built-in-types" class="anchor" href="#built-in-types" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Built-In Types</h3>

<p>Quick Look can be used with most of the datatypes you'll want to visualize right out of the box. Xcode already has you covered for the following types:</p>

<blockquote>
<ul>
<li><strong>Images:</strong> <code>UIImage</code>, <code>NSImage</code>, <code>UIImageView</code>, <code>NSImageView</code>, <code>CIImage</code>, and <code>NSBitmapImageRep</code> are all visible via Quick Look.</li>
<li><strong>Colors:</strong> <code>UIColor</code> and <code>NSColor</code>. (Sorry, <code>CGColor</code>.)</li>
<li><strong>Strings:</strong> <code>NSString</code> and <code>NSAttributedString</code>.</li>
<li><strong>Geometry:</strong> <code>UIBezierPath</code> and <code>NSBezierPath</code> along with <code>CGPoint</code>, <code>CGRect</code>, and <code>CGSize</code>.</li>
<li><strong>Locations:</strong> <code>CLLocation</code> gives a large, interactive view of the mapped location, with details about altitude and accuracy in an overlay.</li>
<li><strong>URLs:</strong> <code>NSURL</code> is represented by a view showing the local or remote content addressed by the URL.</li>
<li><strong>Cursors:</strong> <code>NSCursor</code>, for the cursored among us.</li>
<li><strong>SpriteKit:</strong> <code>SKSpriteNode</code>, <code>SKShapeNode</code>, <code>SKTexture</code>, and <code>SKTextureAtlas</code> are all represented.</li>
<li><strong>Data:</strong> <code>NSData</code> has a great view showing hex and ASCII values with their offset.</li>
<li><strong>Views:</strong> Last but not least, any <code>UIView</code> subclass will display its contents in a Quick Look popup—so convenient.</li>
</ul>
</blockquote>

<p>What's more, these Quick Look popups often include a button that will open the content in a related application. Image data (as well as views, cursors, and SpriteKit types) offer an option to open in Preview. Remote URLs can be opened in Safari; local ones can be opened in the related application. Finally, plain-text and attributed string data can likewise be opened in TextEdit.</p>

<h3><a id="user-content-custom-types" class="anchor" href="#custom-types" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Types</h3>

<p>For anything beyond these built-in types, Xcode 6 has added Quick Look for custom objects. The implementation couldn't be simpler—add a single <code>debugQuickLookObject()</code> method to any <code>NSObject</code>-derived class, and you're set. <code>debugQuickLookObject()</code> can then return any of the built-in types described above, configured for your custom type's needs:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">debugQuickLookObject</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">AnyObject</span> {
    <span class="pl-k">let</span> path <span class="pl-k">=</span> buildPathWithRadius(radius, steps: steps, loopCount: loopCount)
    <span class="pl-k">return</span> path
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">id</span>)debugQuickLookObject {
    UIBezierPath *path = [<span class="pl-v">self</span> <span class="pl-c1">buildPathWithRadius:</span><span class="pl-v">self</span>.radius <span class="pl-c1">steps:</span><span class="pl-v">self</span>.steps <span class="pl-c1">loopCount:</span><span class="pl-v">self</span>.loopCount];
    <span class="pl-k">return</span> path;
}</pre></div>

<hr>

<p>In sum, Quick Look enables a more direct relationship with the data we manipulate in our code by allowing us to iterate over smaller pieces of functionality. This direct view into previously obfuscated datatypes brings some of the immediacy of a Swift Playground right into our main codebase. Displaying images? Visualizing data? Rendering text? Computers are so good at all that! Let's let them do it from now on.</p>
</article></div>