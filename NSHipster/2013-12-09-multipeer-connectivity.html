<div class="announce instapaper_body md" data-path="2013-12-09-multipeer-connectivity.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Multipeer Connectivity</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>popular</div></td>

  <td><div>As consumer web technologies and enterprises race towards cloud infrastructure, there is a curious and significant counter-movement towards connected devices. The Multipeer Connectivity APIs, introduced in iOS 7, therefore may well be the most significant for the platform.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>t.b.c.</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>As consumer web technologies and enterprises race towards cloud infrastructure, there is a curious and significant counter-movement towards connected devices.</p>

<p>In this age of mobile computing, the possibilities of collaboration, whether in work or play, have never been greater. In this age of privacy concerns and mass surveillance, the need for secure, ad hoc communications has never been more prescient. In this age of connected devices, the promise of mastery over the everyday objects of our lives has never been closer at hand.</p>

<p>The Multipeer Connectivity APIs, introduced in iOS 7, therefore may well be the most significant for the platform. It allows developers to completely reimagine how mobile apps are built, and to redefine what is possible. And we're not just talking about successors to the lame bump-to-send-contact-information genre, either: multi-peer connectivity has implications on everything from collaborative editing and file sharing to multiplayer gaming and sensor aggregation.</p>

<hr>

<p>Multipeer Connectivity is a framework that enables nearby devices to communicate over infrastructure Wi-Fi networks, peer-to-peer Wi-Fi, and Bluetooth personal area networks. Connected peers are able securely transmit messages, streams, or file resources to other devices without going through an intermediary web service.</p>

<h2><a id="user-content-advertising--discovering" class="anchor" href="#advertising--discovering" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advertising &amp; Discovering</h2>

<p>The first step in communication is to make peers aware of one another. This is accomplished by advertising and discovering services.</p>

<p>Advertising makes a service known to other peers, while discovery is the inverse process of the client being made aware of services advertised by other peers. In many cases, clients both discover and advertise for the same service, which can lead to some initial confusionâ€”especially to anyone rooted in the client-server paradigm.</p>

<p>Each service is identified by a type, which is a short text string of ASCII letters, numbers, and dashes, up to 15 characters in length. By convention, a service name should begin with the app name, followed by a dash and a unique descriptor for that service (think of it as simplified <code>com.apple.*</code>-esque reverse-DNS notation):</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-c1">NSString</span> * <span class="pl-k">const</span> XXServiceType = <span class="pl-s"><span class="pl-pds">@"</span>xx-service<span class="pl-pds">"</span></span>;</pre></div>

<p>Peers are uniquely identified by an <code>MCPeerID</code> object, which are initialized with a display name. This could be a user-specified nickname, or simply the current device name:</p>

<div class="highlight highlight-source-objc"><pre>MCPeerID *localPeerID = [[MCPeerID <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithDisplayName:</span>[[UIDevice <span class="pl-c1">currentDevice</span>] <span class="pl-c1">name</span>]];</pre></div>

<blockquote>
<p>Peers can be also be advertised or discovered manually using <code>NSNetService</code> or the Bonjour C APIs, but this is a rather advanced and specific concern. Additional information about manual peer management can be found in the <code>MCSession</code> documentation.</p>
</blockquote>

<h3><a id="user-content-advertising" class="anchor" href="#advertising" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advertising</h3>

<p>Services are advertised by the <code>MCNearbyServiceAdvertiser</code>, which is initialized with a local peer, service type, and any optional information to be communicated to peers that discover the service.</p>

<blockquote>
<p>Discovery information is sent as Bonjour <code>TXT</code> records encoded according to <a href="http://tools.ietf.org/html/rfc6763">RFC 6763</a>.</p>
</blockquote>

<div class="highlight highlight-source-objc"><pre>MCNearbyServiceAdvertiser *advertiser =
    [[MCNearbyServiceAdvertiser <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithPeer:</span>localPeerID
                                      <span class="pl-c1">discoveryInfo:</span><span class="pl-c1">nil</span>
                                        <span class="pl-c1">serviceType:</span>XXServiceType];
advertiser.delegate = self;
[advertiser <span class="pl-c1">startAdvertisingPeer</span>];</pre></div>

<p>Events are handled by the advertiser's <code>delegate</code>, conforming to the <code>MCNearbyServiceAdvertiserDelegate</code> protocol.</p>

<p>As an example implementation, consider a client that allows the user to choose whether to accept or reject incoming connection requests, with the option to reject and block any subsequent requests from that peer:</p>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">pragma mark</span> - MCNearbyServiceAdvertiserDelegate

- (<span class="pl-k">void</span>)advertiser:(MCNearbyServiceAdvertiser *)advertiser
didReceiveInvitationFromPeer:(MCPeerID *)peerID
       withContext:(<span class="pl-c1">NSData</span> *)context
 invitationHandler:(<span class="pl-k">void</span>(^)(<span class="pl-c1">BOOL</span> accept, MCSession *session))invitationHandler
{
    <span class="pl-k">if</span> ([<span class="pl-v">self</span>.mutableBlockedPeers <span class="pl-c1">containsObject:</span>peerID]) {
        <span class="pl-c1">invitationHandler</span>(<span class="pl-c1">NO</span>, <span class="pl-c1">nil</span>);
        <span class="pl-k">return</span>;
    }

    [[UIActionSheet <span class="pl-c1">actionSheetWithTitle:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>Received Invitation from <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">@"</span>Received Invitation from {Peer}<span class="pl-pds">"</span></span>), peerID.displayName]
                       <span class="pl-c1">cancelButtonTitle:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>Reject<span class="pl-pds">"</span></span>, <span class="pl-c1">nil</span>)
                  <span class="pl-c1">destructiveButtonTitle:</span>NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>Block<span class="pl-pds">"</span></span>, <span class="pl-c1">nil</span>)
                       <span class="pl-c1">otherButtonTitles:</span>@[NSLocalizedString(<span class="pl-s"><span class="pl-pds">@"</span>Accept<span class="pl-pds">"</span></span>, <span class="pl-c1">nil</span>)]
                                   <span class="pl-c1">block:</span>^(UIActionSheet *actionSheet, <span class="pl-c1">NSInteger</span> buttonIndex)
    {
        <span class="pl-c1">BOOL</span> acceptedInvitation = (buttonIndex == [actionSheet <span class="pl-c1">firstOtherButtonIndex</span>]);

        <span class="pl-k">if</span> (buttonIndex == [actionSheet <span class="pl-c1">destructiveButtonIndex</span>]) {
            [<span class="pl-v">self</span>.mutableBlockedPeers <span class="pl-c1">addObject:</span>peerID];
        }

        MCSession *session = [[MCSession <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithPeer:</span>localPeerID
                                            <span class="pl-c1">securityIdentity:</span><span class="pl-c1">nil</span>
                                        <span class="pl-c1">encryptionPreference:</span>MCEncryptionNone];
        session.<span class="pl-smi">delegate</span> = self;

        <span class="pl-c1">invitationHandler</span>(acceptedInvitation, (acceptedInvitation ? session : <span class="pl-c1">nil</span>));
    }] <span class="pl-c1">showInView:</span><span class="pl-v">self</span>.view];
}</pre></div>

<blockquote>
<p>For sake of simplicity, this example contrives a block-based initializer for <code>UIActionSheet</code>, which allows for the <code>invitationHandler</code> to be passed directly into the action sheet responder in order to avoid the messy business of creating and managing a custom delegate object. This method can be implemented in a category, or adapted from <a href="http://cocoapods.org/?q=uiactionsheet%20blocks">any of the implementations available on CocoaPods</a></p>
</blockquote>

<h3><a id="user-content-creating-a-session" class="anchor" href="#creating-a-session" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a Session</h3>

<p>As in the example above, sessions are created by advertisers, and passed to peers when accepting an invitation to connect. An <code>MCSession</code> object is initialized with the local peer identifier, as well as <code>securityIdentity</code> and <code>encryptionPreference</code> parameters.</p>

<div class="highlight highlight-source-objc"><pre>MCSession *session = [[MCSession <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithPeer:</span>localPeerID
                                    <span class="pl-c1">securityIdentity:</span><span class="pl-c1">nil</span>
                                <span class="pl-c1">encryptionPreference:</span>MCEncryptionNone];
session.delegate = self;</pre></div>

<p><code>securityIdentity</code> is an optional parameter that allows peers to securely identify peers by X.509 certificates. When specified, the first object should be an <code>SecIdentityRef</code> identifying the client, followed by one or more <code>SecCertificateRef</code> objects than can be used to verify the local peerâ€™s identity.</p>

<p>The <code>encryptionPreference</code> parameter specifies whether to encrypt communication between peers. Three possible values are provided by the <code>MCEncryptionPreference</code> enum:</p>

<ul>
<li><code>MCEncryptionOptional</code>: The session prefers to use encryption, but will accept unencrypted connections.</li>
<li><code>MCEncryptionRequired</code>: The session requires encryption.</li>
<li><code>MCEncryptionNone</code>: The session should not be encrypted.</li>
</ul>

<blockquote>
<p>Enabling encryption can significantly reduce transfer rates, so unless your application specifically deals with user-sensitive information, <code>MCEncryptionNone</code> is recommended.</p>
</blockquote>

<p>The <code>MCSessionDelegate</code> protocol will be covered in the section on sending and receiving information.</p>

<h3><a id="user-content-discovering" class="anchor" href="#discovering" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Discovering</h3>

<p>Clients can discover advertised services using <code>MCNearbyServiceBrowser</code>, which is initialized with the local peer identifier and the service type, much like for <code>MCNearbyServiceAdvertiser</code>.</p>

<div class="highlight highlight-source-objc"><pre>MCNearbyServiceBrowser *browser = [[MCNearbyServiceBrowser <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithPeer:</span>localPeerID <span class="pl-c1">serviceType:</span>XXServiceType];
browser.delegate = self;</pre></div>

<p>There may be many peers advertising a particular service, so as a convenience to the user (and the developer), the <code>MCBrowserViewController</code> offers a built-in, standard way to present and connect to advertising peers:</p>

<div class="highlight highlight-source-objc"><pre>MCBrowserViewController *browserViewController =
    [[MCBrowserViewController <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithBrowser:</span>browser
                                             <span class="pl-c1">session:</span>session];
browserViewController.delegate = self;
[<span class="pl-v">self</span> <span class="pl-c1">presentViewController:</span>browserViewController
                   <span class="pl-c1">animated:</span><span class="pl-c1">YES</span>
                 <span class="pl-c1">completion:</span>
^{
    [browser <span class="pl-c1">startBrowsingForPeers</span>];
}];</pre></div>

<p>When a browser has finished connecting to peers, it calls <code>-browserViewControllerDidFinish:</code> on its delegate, to notify the presenting view controller that it should update its UI to accommodate the newly-connected clients.</p>

<h2><a id="user-content-sending--receiving-information" class="anchor" href="#sending--receiving-information" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sending &amp; Receiving Information</h2>

<p>Once peers are connected to one another, information can be sent between them. The Multipeer Connectivity framework distinguishes between three different forms of data transfer:</p>

<ul>
<li><strong>Messages</strong> are information with well-defined boundaries, such as short text or small serialized objects.</li>
<li><strong>Streams</strong> are open channels of information used to continuously transfer data like audio, video, or real-time sensor events.</li>
<li><strong>Resources</strong> are files like images, movies, or documents.</li>
</ul>

<h3><a id="user-content-messages" class="anchor" href="#messages" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Messages</h3>

<p>Messages are sent with <code>-sendData:toPeers:withMode:error:</code>:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> *message = <span class="pl-s"><span class="pl-pds">@"</span>Hello, World!<span class="pl-pds">"</span></span>;
<span class="pl-c1">NSData</span> *data = [message <span class="pl-c1">dataUsingEncoding:</span>NSUTF8StringEncoding];
<span class="pl-c1">NSError</span> *error = <span class="pl-c1">nil</span>;
<span class="pl-k">if</span> (![<span class="pl-v">self</span>.session <span class="pl-c1">sendData:</span>data
                    <span class="pl-c1">toPeers:</span>peers
                   <span class="pl-c1">withMode:</span>MCSessionSendDataReliable
                      <span class="pl-c1">error:</span>&amp;error]) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
}</pre></div>

<hr>

<p>Messages are received through the <code>MCSessionDelegate</code> method <code>-sessionDidReceiveData:fromPeer:</code>. Here's how one would decode the message sent in the previous code example:</p>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">pragma mark</span> - MCSessionDelegate

- (<span class="pl-k">void</span>)session:(MCSession *)session
 didReceiveData:(<span class="pl-c1">NSData</span> *)data
       fromPeer:(MCPeerID *)peerID
{
    <span class="pl-c1">NSString</span> *message =
        [[<span class="pl-c1">NSString</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithData:</span>data
                              <span class="pl-c1">encoding:</span>NSUTF8StringEncoding];
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, message);
}</pre></div>

<p>Another approach would be to send <code>NSKeyedArchiver</code>-encoded objects:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">id</span> &lt;<span class="pl-c1">NSSecureCoding</span>&gt; object = <span class="pl-c">// ...;</span>
<span class="pl-c1">NSData</span> *data = [<span class="pl-c1">NSKeyedArchiver</span> <span class="pl-c1">archivedDataWithRootObject:</span>object];
<span class="pl-c1">NSError</span> *error = <span class="pl-c1">nil</span>;
<span class="pl-k">if</span> (![<span class="pl-v">self</span>.session <span class="pl-c1">sendData:</span>data
                    <span class="pl-c1">toPeers:</span>peers
                   <span class="pl-c1">withMode:</span>MCSessionSendDataReliable
                      <span class="pl-c1">error:</span>&amp;error]) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
}</pre></div>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">pragma mark</span> - MCSessionDelegate

- (<span class="pl-k">void</span>)session:(MCSession *)session
 didReceiveData:(<span class="pl-c1">NSData</span> *)data
       fromPeer:(MCPeerID *)peerID
{
    <span class="pl-c1">NSKeyedUnarchiver</span> *unarchiver = [[<span class="pl-c1">NSKeyedUnarchiver</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initForReadingWithData:</span>data];
    unarchiver.<span class="pl-smi">requiresSecureCoding</span> = <span class="pl-c1">YES</span>;
    <span class="pl-c1">id</span> object = [unarchiver <span class="pl-c1">decodeObject</span>];
    [unarchiver <span class="pl-c1">finishDecoding</span>];
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, object);
}</pre></div>

<blockquote>
<p>In order to guard against object substitution attacks, it is important to set <code>requiresSecureCoding</code> to <code>YES</code>, such that an exception is thrown if the root object class does not conform to <code>&lt;NSSecureCoding&gt;</code>.  For more information, see the [NSHipster article on <a href="http://nshipster.com/nssecurecoding/">NSSecureCoding</a>.</p>
</blockquote>

<h3><a id="user-content-streams" class="anchor" href="#streams" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Streams</h3>

<p>Streams are created with <code>-startStreamWithName:toPeer:</code>:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSOutputStream</span> *outputStream =
    [session <span class="pl-c1">startStreamWithName:</span>name
                          <span class="pl-c1">toPeer:</span>peer];

stream.delegate = self;
[stream <span class="pl-c1">scheduleInRunLoop:</span>[<span class="pl-c1">NSRunLoop</span> <span class="pl-c1">mainRunLoop</span>]
                <span class="pl-c1">forMode:</span><span class="pl-c1">NSDefaultRunLoopMode</span>];
[stream <span class="pl-c1">open</span>];

<span class="pl-c">// ...</span></pre></div>

<hr>

<p>Streams are received by the <code>MCSessionDelegate</code> with <code>-session:didReceiveStream:withName:fromPeer:</code>:</p>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">pragma mark</span> - MCSessionDelegate

- (<span class="pl-k">void</span>)session:(MCSession *)session
didReceiveStream:(<span class="pl-c1">NSInputStream</span> *)stream
       withName:(<span class="pl-c1">NSString</span> *)streamName
       fromPeer:(MCPeerID *)peerID
{
    stream.<span class="pl-smi">delegate</span> = self;
    [stream <span class="pl-c1">scheduleInRunLoop:</span>[<span class="pl-c1">NSRunLoop</span> <span class="pl-c1">mainRunLoop</span>]
                      <span class="pl-c1">forMode:</span><span class="pl-c1">NSDefaultRunLoopMode</span>];
    [stream <span class="pl-c1">open</span>];
}</pre></div>

<p>Both the input and output streams must be scheduled and opened before they can be used. Once that's done, streams can be read from and written to just like any other bound pair.</p>

<h3><a id="user-content-resources" class="anchor" href="#resources" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resources</h3>

<p>Resources are sent with <code>sendResourceAtURL:withName:toPeer:withCompletionHandler:</code>:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSURL</span> *fileURL = [<span class="pl-c1">NSURL</span> <span class="pl-c1">fileURLWithPath:</span><span class="pl-s"><span class="pl-pds">@"</span>path/to/resource<span class="pl-pds">"</span></span>];
<span class="pl-c1">NSProgress</span> *progress =
    [<span class="pl-v">self</span>.session <span class="pl-c1">sendResourceAtURL:</span>fileURL
                           <span class="pl-c1">withName:</span>[fileURL <span class="pl-c1">lastPathComponent</span>]
                             <span class="pl-c1">toPeer:</span>peer
                  <span class="pl-c1">withCompletionHandler:</span>^(<span class="pl-c1">NSError</span> *error)
{
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
}];</pre></div>

<p>The returned <code>NSProgress</code> object can be <a href="http://nshipster.com/key-value-observing/">Key-Value Observed</a> to monitor progress of the file transfer, as well as provide a cancellation handler, through the <code>-cancel</code> method.</p>

<hr>

<p>Receiving resources happens across two methods in <code>MCSessionDelegate</code>: <code>-session:didStartReceivingResourceWithName:fromPeer:withProgress:</code> &amp; <code>-session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:</code>:</p>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">pragma mark</span> - MCSessionDelegate

- (<span class="pl-k">void</span>)session:(MCSession *)session
didStartReceivingResourceWithName:(<span class="pl-c1">NSString</span> *)resourceName
       fromPeer:(MCPeerID *)peerID
   withProgress:(<span class="pl-c1">NSProgress</span> *)progress
{
    <span class="pl-c">// ...</span>
}

- (<span class="pl-k">void</span>)session:(MCSession *)session
didFinishReceivingResourceWithName:(<span class="pl-c1">NSString</span> *)resourceName
       fromPeer:(MCPeerID *)peerID
          atURL:(<span class="pl-c1">NSURL</span> *)localURL
      withError:(<span class="pl-c1">NSError</span> *)error
{
    <span class="pl-c1">NSURL</span> *destinationURL = [<span class="pl-c1">NSURL</span> <span class="pl-c1">fileURLWithPath:</span><span class="pl-s"><span class="pl-pds">@"</span>/path/to/destination<span class="pl-pds">"</span></span>];
    <span class="pl-c1">NSError</span> *error = <span class="pl-c1">nil</span>;
    <span class="pl-k">if</span> (![[<span class="pl-c1">NSFileManager</span> <span class="pl-c1">defaultManager</span>] <span class="pl-c1">moveItemAtURL:</span>localURL
                                                 <span class="pl-c1">toURL:</span>destinationURL
                                                 <span class="pl-c1">error:</span>&amp;error]) {
        <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
    }
}</pre></div>

<p>Again, the <code>NSProgress</code> parameter in <code>-session:didStartReceivingResourceWithName:fromPeer:withProgress:</code> allows the receiving peer to monitor the file transfer progress. In <code>-session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:</code>, it is the responsibility of the delegate to move the file at the temporary <code>localURL</code> to a permanent location.</p>

<hr>

<p>Multipeer Connectivity is a ground-breaking API, whose value is only just starting to be fully understood. Although full support for features like AirDrop are currently limited to latest-gen devices, you should expect to see this kind of functionality become expected behavior.</p>

<p>As you look forward to the possibilities of the new year ahead, get your head out of the cloud, and start to consider the incredible possibilities around you.</p>
</article></div>