<div class="announce instapaper_body md" data-path="2014-09-15-image-resizing.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>

  <th>revisions</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Image Resizing Techniques</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div></div></td>

  <td><div>Since time immemorial, iOS developers have been perplexed by a singular question: 'How do you resize an image?'. This article endeavors to provide a clear answer to this eternal question.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>September 30, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>2014-09-15</th>

  <th>2015-09-30</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Original publication.</div></td>

  <td><div>Revised for Swift 2.0, `vImage` method added.</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Since time immemorial, iOS developers have been perplexed by a singular question: "How do you resize an image?". It is a question of beguiling clarity, spurred on by a mutual mistrust of developer and platform. A thousand code samples litter web search results, each claiming to be the One True Solution, and all the others false prophets.</p>

<p>It's embarrassing, really.</p>

<p>This week's article endeavors to provide a clear explanation of the various approaches to image resizing on iOS (and OS X, making the appropriate <code>UIImage</code> â†’ <code>NSImage</code> conversions), using empirical evidence to offer insights into the performance characteristics of each approach, rather than simply prescribing any one way for all situations.</p>

<p><strong>Before reading any further, please note the following:</strong></p>

<p>When setting a <code>UIImage</code> on a <code>UIImageView</code>, manual resizing is unnecessary for the vast majority of use cases. Instead, one can simply set the <code>contentMode</code> property to either <code>.ScaleAspectFit</code> to ensure that the entire image is visible within the frame of the image view, or <code>.ScaleAspectFill</code> to have the entire image view filled by the image, cropping as necessary from the center.</p>

<div class="highlight highlight-source-swift"><pre>imageView<span class="pl-k">.</span>contentMode <span class="pl-k">=</span> <span class="pl-k">.</span>ScaleAspectFit
imageView<span class="pl-k">.</span>image <span class="pl-k">=</span> image</pre></div>

<hr>

<h2><a id="user-content-determining-scaled-size" class="anchor" href="#determining-scaled-size" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Determining Scaled Size</h2>

<p>Before doing any image resizing, one must first determine the target size to scale to.</p>

<h3><a id="user-content-scaling-by-factor" class="anchor" href="#scaling-by-factor" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scaling by Factor</h3>

<p>The simplest way to scale an image is by a constant factor. Generally, this involves dividing by a whole number to reduce the original size (rather than multiplying by a whole number to magnify).</p>

<p>A new <code>CGSize</code> can be computed by scaling the width and height components individually:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> size <span class="pl-k">=</span> CGSize(width: image<span class="pl-k">.</span>size<span class="pl-k">.</span>width <span class="pl-k">/</span> <span class="pl-c1">2</span>, height: image<span class="pl-k">.</span>size<span class="pl-k">.</span>height <span class="pl-k">/</span> <span class="pl-c1">2</span>)</pre></div>

<p>...or by applying a <code>CGAffineTransform</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> size <span class="pl-k">=</span> CGSizeApplyAffineTransform(image<span class="pl-k">.</span>size, CGAffineTransformMakeScale(<span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span>, <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span>))</pre></div>

<h3><a id="user-content-scaling-by-aspect-ratio" class="anchor" href="#scaling-by-aspect-ratio" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scaling by Aspect Ratio</h3>

<p>It's often useful to scale the original size in such a way that fits within a rectangle without changing the original aspect ratio. <code>AVMakeRectWithAspectRatioInsideRect</code> is a useful function found in the AVFoundation framework that takes care of that calculation for you:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">import</span> <span class="pl-c1">AVFoundation</span>
<span class="pl-k">let</span> rect <span class="pl-k">=</span> AVMakeRectWithAspectRatioInsideRect(image<span class="pl-k">.</span>size, imageView<span class="pl-k">.</span>bounds)</pre></div>

<h2><a id="user-content-resizing-images" class="anchor" href="#resizing-images" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resizing Images</h2>

<p>There are a number of different approaches to resizing an image, each with different capabilities and performance characteristics.</p>

<h3><a id="user-content-uigraphicsbeginimagecontextwithoptions--uiimage--drawinrect" class="anchor" href="#uigraphicsbeginimagecontextwithoptions--uiimage--drawinrect" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>UIGraphicsBeginImageContextWithOptions</code> &amp; <code>UIImage -drawInRect:</code></h3>

<p>The highest-level APIs for image resizing can be found in the UIKit framework. Given a <code>UIImage</code>, a temporary graphics context can be used to render a scaled version, using <code>UIGraphicsBeginImageContextWithOptions()</code> and <code>UIGraphicsGetImageFromCurrentImageContext()</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> image <span class="pl-k">=</span> UIImage(contentsOfFile: <span class="pl-k">self</span><span class="pl-k">.</span>URL<span class="pl-k">.</span>absoluteString<span class="pl-k">!</span>)

<span class="pl-k">let</span> size <span class="pl-k">=</span> CGSizeApplyAffineTransform(image<span class="pl-k">.</span>size, CGAffineTransformMakeScale(<span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span>, <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span>))
<span class="pl-k">let</span> hasAlpha <span class="pl-k">=</span> <span class="pl-c1">false</span>
<span class="pl-k">let</span> scale: CGFloat <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">0</span> <span class="pl-c">// Automatically use scale factor of main screen</span>

UIGraphicsBeginImageContextWithOptions(size, <span class="pl-k">!</span>hasAlpha, scale)
image<span class="pl-k">.</span>drawInRect(CGRect(origin: CGPointZero, size: size))

<span class="pl-k">let</span> scaledImage <span class="pl-k">=</span> UIGraphicsGetImageFromCurrentImageContext()
UIGraphicsEndImageContext()</pre></div>

<p><code>UIGraphicsBeginImageContextWithOptions()</code> creates a temporary rendering context into which the original is drawn. The first argument, <code>size</code>, is the target size of the scaled image. The second argument, <code>isOpaque</code> is used to determine whether an alpha channel is rendered. Setting this to <code>false</code> for images without transparency (i.e. an alpha channel) may result in an image with a pink hue. The third argument <code>scale</code> is the display scale factor. When set to <code>0.0</code>, the scale factor of the main screen is used, which for Retina displays is <code>2.0</code> or higher (<code>3.0</code> on the iPhone 6 Plus).</p>

<h3><a id="user-content-cgbitmapcontextcreate--cgcontextdrawimage" class="anchor" href="#cgbitmapcontextcreate--cgcontextdrawimage" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>CGBitmapContextCreate</code> &amp; <code>CGContextDrawImage</code></h3>

<p>Core Graphics / Quartz 2D offers a lower-level set of APIs that allow for more advanced configuration. Given a <code>CGImage</code>, a temporary bitmap context is used to render the scaled image, using <code>CGBitmapContextCreate()</code> and <code>CGBitmapContextCreateImage()</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> cgImage <span class="pl-k">=</span> UIImage(contentsOfFile: <span class="pl-k">self</span><span class="pl-k">.</span>URL<span class="pl-k">.</span>absoluteString<span class="pl-k">!</span>)<span class="pl-k">.</span>CGImage

<span class="pl-k">let</span> width <span class="pl-k">=</span> CGImageGetWidth(cgImage) <span class="pl-k">/</span> <span class="pl-c1">2</span>
<span class="pl-k">let</span> height <span class="pl-k">=</span> CGImageGetHeight(cgImage) <span class="pl-k">/</span> <span class="pl-c1">2</span>
<span class="pl-k">let</span> bitsPerComponent <span class="pl-k">=</span> CGImageGetBitsPerComponent(cgImage)
<span class="pl-k">let</span> bytesPerRow <span class="pl-k">=</span> CGImageGetBytesPerRow(cgImage)
<span class="pl-k">let</span> colorSpace <span class="pl-k">=</span> CGImageGetColorSpace(cgImage)
<span class="pl-k">let</span> bitmapInfo <span class="pl-k">=</span> CGImageGetBitmapInfo(cgImage)

<span class="pl-k">let</span> context <span class="pl-k">=</span> CGBitmapContextCreate(<span class="pl-c1">nil</span>, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo<span class="pl-k">.</span><span class="pl-c1">rawValue</span>)

CGContextSetInterpolationQuality(context, kCGInterpolationHigh)

CGContextDrawImage(context, CGRect(origin: CGPointZero, size: CGSize(width: CGFloat(width), height: CGFloat(height))), cgImage)

<span class="pl-k">let</span> scaledImage <span class="pl-k">=</span> CGBitmapContextCreateImage(context)<span class="pl-k">.</span><span class="pl-c1">flatMap</span> { UIImage(CGImage: $<span class="pl-c1">0</span>) }</pre></div>

<p><code>CGBitmapContextCreate</code> takes several arguments to construct a context with desired dimensions and amount of memory for each channel within a given colorspace. In the example, these values are fetched from the <code>CGImage</code>. Next, <code>CGContextSetInterpolationQuality</code> allows for the context to interpolate pixels at various levels of fidelity. In this case, <code>kCGInterpolationHigh</code> is passed for best results. <code>CGContextDrawImage</code> allows for the image to be drawn at a given size and position, allowing for the image to be cropped on a particular edge or to fit a set of image features, such as faces. Finally, <code>CGBitmapContextCreateImage</code> creates a <code>CGImage</code> from the context.</p>

<h3><a id="user-content-cgimagesourcecreatethumbnailatindex" class="anchor" href="#cgimagesourcecreatethumbnailatindex" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>CGImageSourceCreateThumbnailAtIndex</code></h3>

<p>Image I/O is a powerful, yet lesser-known framework for working with images. Independent of Core Graphics, it can read and write between many different formats, access photo metadata, and perform common image processing operations. The framework offers the fastest image encoders and decoders on the platform, with advanced caching mechanisms and even the ability to load images incrementally.</p>

<p><code>CGImageSourceCreateThumbnailAtIndex</code> offers a concise API with different options than found in equivalent Core Graphics calls:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">import</span> <span class="pl-c1">ImageIO</span>

<span class="pl-k">if</span> <span class="pl-k">let</span> imageSource <span class="pl-k">=</span> CGImageSourceCreateWithURL(<span class="pl-k">self</span><span class="pl-k">.</span>URL, <span class="pl-c1">nil</span>) {
    <span class="pl-k">let</span> options: [NSString: NSObject] <span class="pl-k">=</span> [
        kCGImageSourceThumbnailMaxPixelSize: <span class="pl-c1">max</span>(size<span class="pl-k">.</span>width, size<span class="pl-k">.</span>height) <span class="pl-k">/</span> <span class="pl-c1">2</span><span class="pl-k">.</span><span class="pl-c1">0</span>,
        kCGImageSourceCreateThumbnailFromImageAlways: <span class="pl-c1">true</span>
    ]

    <span class="pl-k">let</span> scaledImage <span class="pl-k">=</span> CGImageSourceCreateThumbnailAtIndex(imageSource, <span class="pl-c1">0</span>, options)<span class="pl-k">.</span><span class="pl-c1">flatMap</span> { UIImage(CGImage: $<span class="pl-c1">0</span>) }
}</pre></div>

<p>Given a <code>CGImageSource</code> and set of options, <code>CGImageSourceCreateThumbnailAtIndex</code> creates a thumbnail image. Resizing is accomplished by the <code>kCGImageSourceThumbnailMaxPixelSize</code>. Specifying the maximum dimension divided by a constant factor scales the image while maintaining the original aspect ratio. By specifying either <code>kCGImageSourceCreateThumbnailFromImageIfAbsent</code> or <code>kCGImageSourceCreateThumbnailFromImageAlways</code>, Image I/O will automatically cache the scaled result for subsequent calls.</p>

<h3><a id="user-content-lanczos-resampling-with-core-image" class="anchor" href="#lanczos-resampling-with-core-image" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lanczos Resampling with Core Image</h3>

<p>Core Image provides a built-in <a href="http://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos resampling</a> functionality with the <code>CILanczosScaleTransform</code> filter. Although arguably a higher-level API than UIKit, the pervasive use of key-value coding in Core Image makes it unwieldy.</p>

<p>That said, at least the pattern is consistent. The process of creating a transform filter, configuring it, and rendering an output image is just like any other Core Image workflow:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> image <span class="pl-k">=</span> CIImage(contentsOfURL: <span class="pl-k">self</span><span class="pl-k">.</span>URL)

<span class="pl-k">let</span> filter <span class="pl-k">=</span> CIFilter(name: <span class="pl-s"><span class="pl-pds">"</span>CILanczosScaleTransform<span class="pl-pds">"</span></span>)<span class="pl-k">!</span>
filter<span class="pl-k">.</span>setValue(image, forKey: <span class="pl-s"><span class="pl-pds">"</span>inputImage<span class="pl-pds">"</span></span>)
filter<span class="pl-k">.</span>setValue(<span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span>, forKey: <span class="pl-s"><span class="pl-pds">"</span>inputScale<span class="pl-pds">"</span></span>)
filter<span class="pl-k">.</span>setValue(<span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">0</span>, forKey: <span class="pl-s"><span class="pl-pds">"</span>inputAspectRatio<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> outputImage <span class="pl-k">=</span> filter<span class="pl-k">.</span>valueForKey(<span class="pl-s"><span class="pl-pds">"</span>outputImage<span class="pl-pds">"</span></span>) <span class="pl-k">as!</span> CIImage

<span class="pl-k">let</span> context <span class="pl-k">=</span> CIContext(options: [kCIContextUseSoftwareRenderer: <span class="pl-c1">false</span>])
<span class="pl-k">let</span> scaledImage <span class="pl-k">=</span> UIImage(CGImage: <span class="pl-k">self</span><span class="pl-k">.</span>context<span class="pl-k">.</span>createCGImage(outputImage, fromRect: outputImage<span class="pl-k">.</span>extent()))</pre></div>

<p><code>CILanczosScaleTransform</code> accepts an <code>inputImage</code>, <code>inputScale</code>, and <code>inputAspectRatio</code>, all of which are pretty self-explanatory. A <code>CIContext</code> is used to create a <code>UIImage</code> by way of a <code>CGImageRef</code> intermediary representation, since <code>UIImage(CIImage:)</code> doesn't often work as expected.</p>

<p>Creating a <code>CIContext</code> is an expensive operation, so a cached context should always be used for repeated resizing. A <code>CIContext</code> can be created using either the GPU or the CPU (much slower) for renderingâ€”use the <code>kCIContextUseSoftwareRenderer</code> key in the options dictionary to specify which.</p>

<h3><a id="user-content-vimage-in-accelerate" class="anchor" href="#vimage-in-accelerate" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>vImage</code> in Accelerate</h3>

<p>The <a href="https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/AccelerateFWRef/index.html#//apple_ref/doc/uid/TP40009465">Accelerate framework</a> includes a suite of <code>vImage</code> image-processing functions, with a <a href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/vImage_geometric/index.html#//apple_ref/doc/uid/TP40005490-CH212-145717">set of functions</a> that scale an image buffer. These lower-level APIs promise high performance with low power consumption, but at the cost of managing the buffers yourself. The following is a Swift version of a method <a href="https://gist.github.com/Nyx0uf/217d97f81f4889f4445a">suggested by Nyx0uf on GitHub</a>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> cgImage <span class="pl-k">=</span> UIImage(contentsOfFile: <span class="pl-k">self</span><span class="pl-k">.</span>URL<span class="pl-k">.</span>absoluteString<span class="pl-k">!</span>)<span class="pl-k">.</span>CGImage

<span class="pl-c">// create a source buffer</span>
<span class="pl-k">var</span> format <span class="pl-k">=</span> vImage_CGImageFormat(bitsPerComponent: <span class="pl-c1">8</span>, bitsPerPixel: <span class="pl-c1">32</span>, colorSpace: <span class="pl-c1">nil</span>, 
    bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo<span class="pl-k">.</span>First<span class="pl-k">.</span><span class="pl-c1">rawValue</span>), 
    version: <span class="pl-c1">0</span>, decode: <span class="pl-c1">nil</span>, renderingIntent: CGColorRenderingIntent<span class="pl-k">.</span>RenderingIntentDefault)
<span class="pl-k">var</span> sourceBuffer <span class="pl-k">=</span> vImage_Buffer()
<span class="pl-k">defer</span> {
    sourceBuffer<span class="pl-k">.</span>data<span class="pl-k">.</span><span class="pl-c1">dealloc</span>(<span class="pl-c1">Int</span>(sourceBuffer<span class="pl-k">.</span>height) <span class="pl-k">*</span> <span class="pl-c1">Int</span>(sourceBuffer<span class="pl-k">.</span>height) <span class="pl-k">*</span> <span class="pl-c1">4</span>)
}

<span class="pl-k">var</span> error <span class="pl-k">=</span> vImageBuffer_InitWithCGImage(<span class="pl-k">&amp;</span>sourceBuffer, <span class="pl-k">&amp;</span>format, <span class="pl-c1">nil</span>, cgImage, <span class="pl-c1">numericCast</span>(kvImageNoFlags))
<span class="pl-k">guard</span> error <span class="pl-k">==</span> kvImageNoError <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }

<span class="pl-c">// create a destination buffer</span>
<span class="pl-k">let</span> scale <span class="pl-k">=</span> UIScreen<span class="pl-k">.</span>mainScreen()<span class="pl-k">.</span>scale
<span class="pl-k">let</span> destWidth <span class="pl-k">=</span> <span class="pl-c1">Int</span>(image<span class="pl-k">.</span>size<span class="pl-k">.</span>width <span class="pl-k">*</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span> <span class="pl-k">*</span> scale)
<span class="pl-k">let</span> destHeight <span class="pl-k">=</span> <span class="pl-c1">Int</span>(image<span class="pl-k">.</span>size<span class="pl-k">.</span>height <span class="pl-k">*</span> <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">5</span> <span class="pl-k">*</span> scale)
<span class="pl-k">let</span> bytesPerPixel <span class="pl-k">=</span> CGImageGetBitsPerPixel(image<span class="pl-k">.</span>CGImage) <span class="pl-k">/</span> <span class="pl-c1">8</span>
<span class="pl-k">let</span> destBytesPerRow <span class="pl-k">=</span> destWidth <span class="pl-k">*</span> bytesPerPixel
<span class="pl-k">let</span> destData <span class="pl-k">=</span> <span class="pl-c1">UnsafeMutablePointer</span><span class="pl-k">&lt;</span><span class="pl-c1">UInt8</span><span class="pl-k">&gt;.</span>alloc(destHeight <span class="pl-k">*</span> destBytesPerRow)
<span class="pl-k">defer</span> {
    destData<span class="pl-k">.</span><span class="pl-c1">dealloc</span>(destHeight <span class="pl-k">*</span> destBytesPerRow)
}
<span class="pl-k">var</span> destBuffer <span class="pl-k">=</span> vImage_Buffer(data: destData, height: vImagePixelCount(destHeight), width: vImagePixelCount(destWidth), rowBytes: destBytesPerRow)

<span class="pl-c">// scale the image</span>
error <span class="pl-k">=</span> vImageScale_ARGB8888(<span class="pl-k">&amp;</span>sourceBuffer, <span class="pl-k">&amp;</span>destBuffer, <span class="pl-c1">nil</span>, <span class="pl-c1">numericCast</span>(kvImageHighQualityResampling))
<span class="pl-k">guard</span> error <span class="pl-k">==</span> kvImageNoError <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }

<span class="pl-c">// create a CGImage from vImage_Buffer</span>
<span class="pl-k">let</span> destCGImage <span class="pl-k">=</span> vImageCreateCGImageFromBuffer(<span class="pl-k">&amp;</span>destBuffer, <span class="pl-k">&amp;</span>format, <span class="pl-c1">nil</span>, <span class="pl-c1">nil</span>, <span class="pl-c1">numericCast</span>(kvImageNoFlags), <span class="pl-k">&amp;</span>error)?<span class="pl-k">.</span><span class="pl-c1">takeRetainedValue</span>()
<span class="pl-k">guard</span> error <span class="pl-k">==</span> kvImageNoError <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }

<span class="pl-c">// create a UIImage</span>
<span class="pl-k">let</span> scaledImage <span class="pl-k">=</span> destCGImage<span class="pl-k">.</span><span class="pl-c1">flatMap</span> { UIImage(CGImage: $<span class="pl-c1">0</span>, scale: <span class="pl-c1">0</span><span class="pl-k">.</span><span class="pl-c1">0</span>, orientation: image<span class="pl-k">.</span>imageOrientation) }</pre></div>

<p>The Accelerate APIs used here clearly operate at a lower-level than the other resizing methods. To use this method, you first create a source buffer from your CGImage using a <code>vImage_CGImageFormat</code> with <code>vImageBuffer_InitWithCGImage()</code>. The destination buffer is allocated at the desired image resolution, then <code>vImageScale_ARGB8888</code> does the actual work of resizing the image. Managing your own buffers when operating on images larger than your app's memory limit is left as an exercise for the reader.</p>

<hr>

<h2><a id="user-content-performance-benchmarks" class="anchor" href="#performance-benchmarks" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Performance Benchmarks</h2>

<p>So how do these various approaches stack up to one another?</p>

<p>Here are the results of a set of <a href="http://nshipster.com/benchmarking/">performance benchmarks</a> done on an iPhone 6 running iOS 8.4, via <a href="https://github.com/natecook1000/Image-Resizing">this project</a>:</p>

<h3><a id="user-content-jpeg" class="anchor" href="#jpeg" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JPEG</h3>

<p>Loading, scaling, and displaying a large, high-resolution (12000 â¨‰ 12000 px 20 MB JPEG) source image from <a href="http://visibleearth.nasa.gov/view.php?id=78314">NASA Visible Earth</a> at 1/10<sup>th</sup> the size:</p>

<table><thead>
<tr>
<th>Operation</th>
<th>Time <em>(sec)</em></th>
<th>Ïƒ</th>
</tr>
</thead><tbody>
<tr>
<td><code>UIKit</code></td>
<td>0.612</td>
<td>14%</td>
</tr>
<tr>
<td><code>Core Graphics</code> <sup>1</sup></td>
<td>0.266</td>
<td>3%</td>
</tr>
<tr>
<td><code>Image I/O</code></td>
<td>0.255</td>
<td>2%</td>
</tr>
<tr>
<td><code>Core Image</code> <sup>2</sup></td>
<td>3.703</td>
<td>33%</td>
</tr>
<tr>
<td><code>vImage</code> <sup>3</sup></td>
<td>--</td>
<td>--</td>
</tr>
</tbody></table>

<h3><a id="user-content-png" class="anchor" href="#png" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PNG</h3>

<p>Loading, scaling, and displaying a reasonably large (1024 â¨‰ 1024 px 1MB PNG) rendering of the <a href="http://postgresapp.com">Postgres.app</a> Icon at 1/10<sup>th</sup> the size:</p>

<table><thead>
<tr>
<th>Operation</th>
<th>Time <em>(sec)</em></th>
<th>Ïƒ</th>
</tr>
</thead><tbody>
<tr>
<td><code>UIKit</code></td>
<td>0.044</td>
<td>30%</td>
</tr>
<tr>
<td><code>Core Graphics</code> <sup>4</sup></td>
<td>0.036</td>
<td>10%</td>
</tr>
<tr>
<td><code>Image I/O</code></td>
<td>0.038</td>
<td>11%</td>
</tr>
<tr>
<td><code>Core Image</code> <sup>5</sup></td>
<td>0.053</td>
<td>68%</td>
</tr>
<tr>
<td><code>vImage</code></td>
<td>0.050</td>
<td>25%</td>
</tr>
</tbody></table>

<p><sup>1, 4</sup> Results were consistent across different values of <code>CGInterpolationQuality</code>, with negligible differences in performance benchmarks.</p>

<p><sup>3</sup> The size of the NASA Visible Earth image was larger than could be processed in a single pass on the device.</p>

<p><sup>2, 5</sup> Setting <code>kCIContextUseSoftwareRenderer</code> to <code>true</code> on the options passed on <code>CIContext</code> creation yielded results an order of magnitude slower than base results.</p>

<h2><a id="user-content-conclusions" class="anchor" href="#conclusions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusions</h2>

<ul>
<li><strong>UIKit</strong>, <strong>Core Graphics</strong>, and <strong>Image I/O</strong> all perform well for scaling operations on most images.</li>
<li><strong>Core Image</strong> is outperformed for image scaling operations. In fact, it is specifically recommended in the <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1">Performance Best Practices section of the Core Image Programming Guide</a> to use Core Graphics or Image I/O functions to crop or downsample images beforehand.</li>
<li>For general image scaling without any additional functionality, <strong><code>UIGraphicsBeginImageContextWithOptions</code></strong> is probably the best option.</li>
<li>If image quality is a consideration, consider using <strong><code>CGBitmapContextCreate</code></strong> in combination with <strong><code>CGContextSetInterpolationQuality</code></strong>.</li>
<li>When scaling images with the intent purpose of displaying thumbnails, <strong><code>CGImageSourceCreateThumbnailAtIndex</code></strong> offers a compelling solution for both rendering and caching.</li>
<li>Unless you're already working with <strong><code>vImage</code></strong>, the extra work to use the low-level Accelerate framework for resizing doesn't pay off.</li>
</ul>
</article></div>