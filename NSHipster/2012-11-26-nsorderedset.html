<div class="announce instapaper_body md" data-path="2012-11-26-nsorderedset.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSOrderedSet</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>nshipster</div></td>

  <td><div>Why isn't NSOrderedSet a subclass of NSSet? The answer may surprise you.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>September 15, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Here's a question: why isn't <code>NSOrderedSet</code> a subclass of <code>NSSet</code>?</p>

<p>It seems perfectly logical, after all, for <code>NSOrderedSet</code>--a class that enforces the same uniqueness constraint of <code>NSSet</code>--to be a <em>subclass</em> of <code>NSSet</code>. It has the same methods as <code>NSSet</code>, with the addition of some <code>NSArray</code>-style methods like <code>objectAtIndex:</code>. By all accounts, it would seem to perfectly satisfy the requirements of the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a>, that:</p>

<blockquote>
<p>If <code>S</code> is a subtype of <code>T</code>, then objects of type <code>T</code> in a program may be replaced with objects of type <code>S</code> without altering any of the desirable properties of that program.</p>
</blockquote>

<p>So why is <code>NSOrderedSet</code> a subclass of <code>NSObject</code> and not <code>NSSet</code> or even <code>NSArray</code>?</p>

<p><em>Mutable / Immutable Class Clusters</em></p>

<p><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html%23//apple_ref/doc/uid/TP40002974-CH4-SW34">Class Clusters</a> are a design pattern at the heart of the Foundation framework; the essence of Objective-C's simplicity in everyday use.</p>

<p>But class clusters offer simplicity at the expense of extensibility, which becomes especially tricky when it comes to mutable / immutable class pairs like <code>NSSet</code> / <code>NSMutableSet</code>.</p>

<p>As expertly demonstrated by <a href="http://tomdalling.com">Tom Dalling</a> in <a href="http://stackoverflow.com/questions/11278995/why-doesnt-nsorderedset-inherit-from-nsset">this Stack Overflow question</a>, the method <code>-mutableCopy</code> creates an inconsistency that is inherent to Objective-C's constraint on single inheritance.</p>

<p>To start, let's look at how <code>-mutableCopy</code> is supposed to work in a class cluster:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> immutable <span class="pl-k">=</span> NSSet()
<span class="pl-k">let</span> mutable <span class="pl-k">=</span> immutable<span class="pl-k">.</span>mutableCopy() <span class="pl-k">as!</span> NSMutableSet

mutable<span class="pl-k">.</span>isKindOfClass(NSSet<span class="pl-k">.</span><span class="pl-k">self</span>) <span class="pl-c">// true</span>
mutable<span class="pl-k">.</span>isKindOfClass(NSMutableSet<span class="pl-k">.</span><span class="pl-k">self</span>) <span class="pl-c">// true</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSSet</span>* immutable = [<span class="pl-c1">NSSet</span> <span class="pl-c1">set</span>];
<span class="pl-c1">NSMutableSet</span>* mutable = [immutable <span class="pl-c1">mutableCopy</span>];

[mutable <span class="pl-c1">isKindOfClass:</span>[<span class="pl-c1">NSSet</span> <span class="pl-c1">class</span>]]; <span class="pl-c">// YES</span>
[mutable <span class="pl-c1">isKindOfClass:</span>[<span class="pl-c1">NSMutableSet</span> <span class="pl-c1">class</span>]]; <span class="pl-c">// YES</span></pre></div>

<p>Now let's suppose that <code>NSOrderedSet</code> was indeed a subclass of <code>NSSet</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// class NSOrderedSet: NSSet {...}</span>

<span class="pl-k">let</span> immutable <span class="pl-k">=</span> NSOrderedSet()
<span class="pl-k">let</span> mutable <span class="pl-k">=</span> immutable<span class="pl-k">.</span>mutableCopy() <span class="pl-k">as!</span> NSMutableOrderedSet

mutable<span class="pl-k">.</span>isKindOfClass(NSSet<span class="pl-k">.</span><span class="pl-k">self</span>) <span class="pl-c">// true</span>
mutable<span class="pl-k">.</span>isKindOfClass(NSMutableSet<span class="pl-k">.</span><span class="pl-k">self</span>) <span class="pl-c">// false (!)</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// @interface NSOrderedSet : NSSet</span>

<span class="pl-c1">NSOrderedSet</span>* immutable = [<span class="pl-c1">NSOrderedSet</span> <span class="pl-c1">orderedSet</span>];
<span class="pl-c1">NSMutableOrderedSet</span>* mutable = [immutable <span class="pl-c1">mutableCopy</span>];

[mutable <span class="pl-c1">isKindOfClass:</span>[<span class="pl-c1">NSSet</span> <span class="pl-c1">class</span>]]; <span class="pl-c">// YES</span>
[mutable <span class="pl-c1">isKindOfClass:</span>[<span class="pl-c1">NSMutableSet</span> <span class="pl-c1">class</span>]]; <span class="pl-c">// NO (!)</span></pre></div>

<p><a href="{{ site.asseturl }}/nsorderedset-case-1.svg" target="_blank"><img src="{{ site.asseturl }}/nsorderedset-case-1.svg" style="max-width:100%;"></a></p>

<p>That's no good... since <code>NSMutableOrderedSet</code> couldn't be used as a method parameter of type <code>NSMutableSet</code>. So what happens if we make <code>NSMutableOrderedSet</code> a subclass of <code>NSMutableSet</code> as well?</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// class NSOrderedSet: NSSet {...}</span>
<span class="pl-c">// class NSMutableOrderedSet: NSMutableSet {...}</span>

<span class="pl-k">let</span> immutable <span class="pl-k">=</span> NSOrderedSet()
<span class="pl-k">let</span> mutable <span class="pl-k">=</span> immutable<span class="pl-k">.</span>mutableCopy() <span class="pl-k">as!</span> NSMutableOrderedSet

mutable<span class="pl-k">.</span>isKindOfClass(NSSet<span class="pl-k">.</span><span class="pl-k">self</span>) <span class="pl-c">// true</span>
mutable<span class="pl-k">.</span>isKindOfClass(NSMutableSet<span class="pl-k">.</span><span class="pl-k">self</span>) <span class="pl-c">// true</span>
mutable<span class="pl-k">.</span>isKindOfClass(NSOrderedSet<span class="pl-k">.</span><span class="pl-k">self</span>) <span class="pl-c">// false (!)</span></pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// @interface NSOrderedSet : NSSet</span>
<span class="pl-c">// @interface NSMutableOrderedSet : NSMutableSet</span>

<span class="pl-c1">NSOrderedSet</span>* immutable = [<span class="pl-c1">NSOrderedSet</span> <span class="pl-c1">orderedSet</span>];
<span class="pl-c1">NSMutableOrderedSet</span>* mutable = [immutable <span class="pl-c1">mutableCopy</span>];

[mutable <span class="pl-c1">isKindOfClass:</span>[<span class="pl-c1">NSSet</span> <span class="pl-c1">class</span>]]; <span class="pl-c">// YES</span>
[mutable <span class="pl-c1">isKindOfClass:</span>[<span class="pl-c1">NSMutableSet</span> <span class="pl-c1">class</span>]]; <span class="pl-c">// YES</span>
[mutable <span class="pl-c1">isKindOfClass:</span>[<span class="pl-c1">NSOrderedSet</span> <span class="pl-c1">class</span>]]; <span class="pl-c">// NO (!)</span></pre></div>

<p><a href="{{ site.asseturl }}/nsorderedset-case-2.svg" target="_blank"><img src="{{ site.asseturl }}/nsorderedset-case-2.svg" style="max-width:100%;"></a></p>

<p>This is perhaps even worse, as now <code>NSMutableOrderedSet</code> couldn't be used as a method parameter expecting an <code>NSOrderedSet</code>.</p>

<p>No matter how we approach it, we can't stack a mutable / immutable class pair on top of another existing mutable / immutable class pair. It just won't work in Objective-C.</p>

<p>Rather than subject ourselves to the perils of <a href="http://en.wikipedia.org/wiki/Multiple_inheritance">multiple inheritance</a>, we could use Protocols to get us out of this pickle (as it does every other time the spectre of multiple inheritance is raised). Indeed, Foundation's collection classes <em>could</em> become more aspect-oriented by adding protocols:</p>

<ul>
<li><code>NSArray : NSObject &lt;NSOrderedCollection&gt;</code></li>
<li><code>NSSet : NSObject &lt;NSUniqueCollection&gt;</code></li>
<li><code>NSOrderedSet : NSObject &lt;NSOrderedCollection, NSUniqueCollection&gt;</code></li>
</ul>

<p>However, to reap any benefit from this arrangement, all of the existing APIs would have to be restructured to have parameters accept <code>id &lt;NSOrderedCollection&gt;</code> instead of <code>NSArray</code>. But the transition would be painful, and would likely open up a whole can of edge cases... which would mean that it would never be fully adopted... which would mean that there's less incentive to adopt this approach when defining your own APIs... which are less fun to write because there's now two incompatible ways to do something instead of one... which...</p>

<p>...wait, why would we use <code>NSOrderedSet</code> in the first place, anyway?</p>

<hr>

<p><code>NSOrderedSet</code> was introduced in iOS 5 &amp; OS X Lion. The only APIs changed to add support for <code>NSOrderedSet</code>, though, were part of <a href="http://developer.apple.com/library/mac/#releasenotes/DataManagement/RN-CoreData/_index.html">Core Data</a>.</p>

<p>This was fantastic news for anyone using Core Data at the time, as it solved one of the long-standing annoyances of not having a way to arbitrarily order relationship collections. Previously, you'd have to add a <code>position</code> attribute, which would be re-calculated every time a collection was modified. There wasn't a built-in way to validate that your collection positions were unique or that the sequence didn't have any gaps.</p>

<p>In this way, <code>NSOrderedSet</code> is an <em>answer to our <a href="http://bugreport.apple.com/">prayers</a></em>.</p>

<p>Unfortunately, its very existence in Foundation has created something between an attractive nuisance and a red herring for API designers.</p>

<p>Although it is perfectly suited to that one particular use case in Core Data, <code>NSOrderedSet</code> is probably not a great choice for the majority of APIs that could potentially use it. In cases where a simple collection of objects is passed as a parameter, a simple <code>NSArray</code> does the trick--even if there is an implicit understanding that you shouldn't have duplicate entries. This is even more the case when order matters for a collection parameter--just use <code>NSArray</code> (there should be code to deal with duplicates in the implementation anyway). If uniqueness does matter, or the semantics of sets makes sense for a particular method, <code>NSSet</code> has and remains a great choice.</p>

<hr>

<p>So, as a general rule: <strong><code>NSOrderedSet</code> is useful for intermediary and internal representations, but you probably shouldn't introduce it as a method parameter unless it's particularly well-suited to the semantics of the data model.</strong></p>

<p>If nothing else, <code>NSOrderedSet</code> illuminates some of the fascinating implications of Foundation's use of the class cluster design pattern. In doing so, it allows us better understand the trade-off between simplicity and extensibility as we make these choices in our own application designs.</p>
</article></div>