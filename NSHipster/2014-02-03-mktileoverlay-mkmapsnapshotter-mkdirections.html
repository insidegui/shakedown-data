<div class="announce instapaper_body md" data-path="2014-02-03-mktileoverlay-mkmapsnapshotter-mkdirections.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>MKTileOverlay,<br>MKMapSnapshotter &amp;<br>MKDirections</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>Unless you work with MKMapView. on a regular basis, the last you may have heard about the current state of cartography on iOS may not have been under the cheeriest of circumstances. Therefore, it may come as a surprise maps on iOS have gotten quite a bit better in the intervening releases. Quite good, in fact.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>November 12, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Unless you work with <code>MKMapView</code> on a regular basis, the last you may have heard about the current state of cartography on iOS may not have been <a href="http://www.apple.com/letter-from-tim-cook-on-maps/">under the cheeriest of circumstances</a>. Even now, years after the ire of armchair usability experts has moved on to iOS 7's distinct "look and feel", the phrase "Apple Maps" still does not inspire confidence in the average developer.</p>

<p>Therefore, it may come as a surprise maps on iOS have gotten quite a bit better in the intervening releases. Quite good, in fact—especially with the new mapping APIs introduced in iOS 7.  These new APIs not only expose the advanced presentational functionality seen in Maps, but provide workarounds for MapKit's limitations.</p>

<p>This week on NSHipster, we'll introduce <code>MKTileOverlay</code>, <code>MKMapSnapshotter</code>, and <code>MKDirections</code>: three new MapKit APIs introduced in iOS 7 that unlock a new world of possibilities.</p>

<hr>

<h2><a id="user-content-mktileoverlay" class="anchor" href="#mktileoverlay" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MKTileOverlay</h2>

<p>Don't like the default Apple Maps tiles? <a href="https://developer.apple.com/library/ios/documentation/MapKit/Reference/MKTileOverlay_class/Reference/Reference.html"><code>MKTileOverlay</code></a> allows you to seamlessly swap out to another tile set in just a few lines of code.</p>

<blockquote>
<p>Just like <a href="http://www.openstreetmap.org">OpenStreetMap</a> and <a href="https://maps.google.com">Google Maps</a>, MKTileOverlay uses <a href="http://en.wikipedia.org/wiki/Mercator_projection#The_spherical_model">spherical mercator projection (EPSG:3857)</a>.</p>
</blockquote>

<h3><a id="user-content-setting-custom-map-view-tile-overlay" class="anchor" href="#setting-custom-map-view-tile-overlay" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting Custom Map View Tile Overlay</h3>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> template <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>http://tile.openstreetmap.org/{z}/{x}/{y}.png<span class="pl-pds">"</span></span>

<span class="pl-k">let</span> overlay <span class="pl-k">=</span> MKTileOverlay(URLTemplate: template)
overlay<span class="pl-k">.</span>canReplaceMapContent <span class="pl-k">=</span> <span class="pl-c1">true</span>

mapView<span class="pl-k">.</span>addOverlay(overlay, level: <span class="pl-k">.</span>AboveLabels)</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-c1">NSString</span> * <span class="pl-k">const</span> template = <span class="pl-s"><span class="pl-pds">@"</span>http://tile.openstreetmap.org/{z}/{x}/{y}.png<span class="pl-pds">"</span></span>;

MKTileOverlay *overlay = [[MKTileOverlay <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithURLTemplate:</span>template];
overlay.canReplaceMapContent = <span class="pl-c1">YES</span>;

[<span class="pl-v">self</span>.mapView <span class="pl-c1">addOverlay:</span>overlay
                   <span class="pl-c1">level:</span>MKOverlayLevelAboveLabels];</pre></div>

<p>MKTileOverlay is initialized with a URL template string, with the <code>x</code> &amp; <code>y</code> tile coordinates within the specified zoom level. <a href="https://www.mapbox.com/developers/guide/">MapBox has a great explanation for this scheme is used to generate tiles</a>:</p>

<blockquote>
<p>Each tile has a z coordinate describing its zoom level and x and y coordinates describing its position within a square grid for that zoom level. Hence, the very first tile in the web map system is at 0/0/0.</p>
</blockquote>

<table>
    <tbody><tr>
        <td>0/0/0</td>
    </tr>
</tbody></table>

<blockquote>
<p>Zoom level 0 covers the entire globe. The very next zoom level divides z0 into four equal squares such that 1/0/0 and 1/1/0 cover the northern hemisphere while 1/0/1 and 1/1/1 cover the southern hemisphere.</p>
</blockquote>

<table>
    <tbody><tr>
        <td>1/0/0</td>
        <td>1/1/0</td>
    </tr>
    <tr>
        <td>1/0/1</td>
        <td>1/1/1</td>
    </tr>
</tbody></table>

<blockquote>
<p>Zoom levels are related to each other by powers of four - <code>z0</code> contains 1 tile, <code>z1</code> contains 4 tiles, <code>z2</code> contains 16, and so on. Because of this exponential relationship the amount of detail increases at every zoom level but so does the amount of bandwidth and storage required to serve up tiles. For example, a map at <code>z15</code> – about when city building footprints first become visible – requires about 1.1 billion tiles to cover the entire world. At <code>z17</code>, just two zoom levels greater, the world requires 17 billion tiles.</p>
</blockquote>

<p>After setting <code>canReplaceMapContent</code> to <code>YES</code>, the overlay is added to the <code>MKMapView</code>.</p>

<p>In the map view's delegate, <code>mapView:rendererForOverlay:</code> is implemented simply to return a new <code>MKTileOverlayRenderer</code> instance when called for the <code>MKTileOverlay</code> overlay.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// MARK: MKMapViewDelegate</span>

<span class="pl-k">func</span> <span class="pl-en">mapView</span>(mapView: MKMapView, <span class="pl-en">rendererForOverlay</span> <span class="pl-smi">overlay</span>: MKOverlay) <span class="pl-k">-&gt;</span> MKOverlayRenderer {
    <span class="pl-k">guard</span> <span class="pl-k">let</span> tileOverlay <span class="pl-k">=</span> overlay <span class="pl-k">as?</span> MKTileOverlay <span class="pl-k">else</span> {
        <span class="pl-k">return</span> MKOverlayRenderer()
    }

    <span class="pl-k">return</span> MKTileOverlayRenderer(tileOverlay: tileOverlay)
}</pre></div>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">pragma mark</span> - MKMapViewDelegate

- (MKOverlayRenderer *)mapView:(MKMapView *)mapView
            rendererForOverlay:(<span class="pl-k">id</span> &lt;MKOverlay&gt;)overlay
{
    <span class="pl-k">if</span> ([overlay <span class="pl-c1">isKindOfClass:</span>[MKTileOverlay <span class="pl-c1">class</span>]]) {
        <span class="pl-k">return</span> [[MKTileOverlayRenderer <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithTileOverlay:</span>overlay];
    }

    <span class="pl-k">return</span> <span class="pl-c1">nil</span>;
}</pre></div>

<blockquote>
<p>Speaking of <a href="https://www.mapbox.com">MapBox</a>, <a href="https://github.com/incanus">Justin R. Miller</a> maintains <a href="https://www.mapbox.com/mbxmapkit/">MBXMapKit</a>, a MapBox-enabled drop-in replacement for <code>MKMapView</code>. It's the easiest way to get up-and-running with this world-class mapping service, and highly recommended for anyone looking to make an impact with maps in their next release.</p>
</blockquote>

<h3><a id="user-content-implementing-custom-behavior-with-mktileoverlay-subclass" class="anchor" href="#implementing-custom-behavior-with-mktileoverlay-subclass" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing Custom Behavior with MKTileOverlay Subclass</h3>

<p>If you need to accommodate a different tile coordinate scheme with your server, or want to add in-memory or offline caching, this can be done by subclassing <code>MKTileOverlay</code> and overriding <code>-URLForTilePath:</code> and <code>-loadTileAtPath:result:</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> MKHipsterTileOverlay <span class="pl-k">:</span> MKTileOverlay {
    <span class="pl-k">let</span> cache <span class="pl-k">=</span> NSCache()
    <span class="pl-k">let</span> operationQueue <span class="pl-k">=</span> NSOperationQueue()

    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">URLForTilePath</span>(path: MKTileOverlayPath) <span class="pl-k">-&gt;</span> NSURL {
        <span class="pl-k">return</span> NSURL(string: <span class="pl-c1">String</span>(format: <span class="pl-s"><span class="pl-pds">"</span>http://tile.example.com/%d/%d/%d<span class="pl-pds">"</span></span>, path<span class="pl-k">.</span>z, path<span class="pl-k">.</span>x, path<span class="pl-k">.</span>y))<span class="pl-k">!</span>
    }

    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">loadTileAtPath</span>(path: MKTileOverlayPath, result: (NSData?, NSError?) <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>) {
        <span class="pl-k">let</span> url <span class="pl-k">=</span> URLForTilePath(path)
        <span class="pl-k">if</span> <span class="pl-k">let</span> cachedData <span class="pl-k">=</span> cache<span class="pl-k">.</span><span class="pl-c1">objectForKey</span>(url) <span class="pl-k">as?</span> NSData {
            result(cachedData, <span class="pl-c1">nil</span>)
        } <span class="pl-k">else</span> {
            <span class="pl-k">let</span> request <span class="pl-k">=</span> NSURLRequest(URL: url)
            NSURLConnection<span class="pl-k">.</span>sendAsynchronousRequest(request, queue: operationQueue) {
                [<span class="pl-k">weak</span> <span class="pl-k">self</span>]
                response, data, error <span class="pl-k">in</span>
                <span class="pl-k">if</span> <span class="pl-k">let</span> data <span class="pl-k">=</span> data {
                    <span class="pl-k">self</span>?<span class="pl-k">.</span>cache<span class="pl-k">.</span>setObject(data, forKey: url)
                }
                result(data, error)
            }
        }
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">@interface</span> <span class="pl-en">XXTileOverlay</span> : <span class="pl-e">MKTileOverlay</span>
<span class="pl-k">@property</span> <span class="pl-c1">NSCache</span> *cache;
<span class="pl-k">@property</span> <span class="pl-c1">NSOperationQueue</span> *operationQueue;
<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">XXTileOverlay</span>

- (<span class="pl-c1">NSURL</span> *)<span class="pl-en">URLForTilePath</span><span class="pl-en">:</span>(MKTileOverlayPath)<span class="pl-smi">path</span> {
    <span class="pl-k">return</span> [<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>http://tile.example.com/<span class="pl-c1">%d</span>/<span class="pl-c1">%d</span>/<span class="pl-c1">%d</span><span class="pl-pds">"</span></span>, path.z, path.x, path.y]];
}

- (<span class="pl-k">void</span>)<span class="pl-en">loadTileAtPath</span><span class="pl-en">:</span>(MKTileOverlayPath)<span class="pl-smi">path</span>
                <span class="pl-en">result</span><span class="pl-en">:</span>(<span class="pl-k">void</span> (^)(<span class="pl-c1">NSData</span> *data, <span class="pl-c1">NSError</span> *error))<span class="pl-en">result</span>
{
    <span class="pl-k">if</span> (!result) {
        <span class="pl-k">return</span>;
    }

    <span class="pl-c1">NSData</span> *cachedData = [<span class="pl-v">self</span>.cache <span class="pl-c1">objectForKey:</span>[<span class="pl-v">self</span> <span class="pl-c1">URLForTilePath:</span>path]];
    <span class="pl-k">if</span> (cachedData) {
        <span class="pl-c1">result</span>(cachedData, <span class="pl-c1">nil</span>);
    } <span class="pl-k">else</span> {
        <span class="pl-c1">NSURLRequest</span> *request = [<span class="pl-c1">NSURLRequest</span> <span class="pl-c1">requestWithURL:</span>[<span class="pl-v">self</span> <span class="pl-c1">URLForTilePath:</span>path]];
        [<span class="pl-c1">NSURLConnection</span> <span class="pl-c1">sendAsynchronousRequest:</span>request <span class="pl-c1">queue:</span><span class="pl-v">self</span>.operationQueue <span class="pl-c1">completionHandler:</span>^(<span class="pl-c1">NSURLResponse</span> *response, <span class="pl-c1">NSData</span> *data, <span class="pl-c1">NSError</span> *connectionError) {
            <span class="pl-c1">result</span>(data, connectionError);
        }];
    }
}

<span class="pl-k">@end</span></pre></div>

<h2><a id="user-content-mkmapsnapshotter" class="anchor" href="#mkmapsnapshotter" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MKMapSnapshotter</h2>

<p>Another addition to iOS 7 was <a href="https://developer.apple.com/library/ios/documentation/MapKit/Reference/MKMapSnapshotter_class/Reference/Reference.html"><code>MKMapSnapshotter</code></a>, which formalizes the process of creating an image representation of a map view. Previously, this would involve playing fast and loose with the <code>UIGraphicsContext</code>, but now images can reliably be created for any particular region and perspective.</p>

<blockquote>
<p>See <a href="https://developer.apple.com/wwdc/videos/?id=309">WWDC 2013 Session 309: "Putting Map Kit in Perspective"</a> for additional information on how and when to use <code>MKMapSnapshotter</code>.</p>
</blockquote>

<h3><a id="user-content-creating-a-map-view-snapshot" class="anchor" href="#creating-a-map-view-snapshot" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a Map View Snapshot</h3>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> options <span class="pl-k">=</span> MKMapSnapshotOptions()
options<span class="pl-k">.</span>region <span class="pl-k">=</span> mapView<span class="pl-k">.</span>region
options<span class="pl-k">.</span>size <span class="pl-k">=</span> mapView<span class="pl-k">.</span>frame<span class="pl-k">.</span>size
options<span class="pl-k">.</span>scale <span class="pl-k">=</span> UIScreen<span class="pl-k">.</span>mainScreen()<span class="pl-k">.</span>scale

<span class="pl-k">let</span> fileURL <span class="pl-k">=</span> NSURL(fileURLWithPath: <span class="pl-s"><span class="pl-pds">"</span>path/to/snapshot.png<span class="pl-pds">"</span></span>)

<span class="pl-k">let</span> snapshotter <span class="pl-k">=</span> MKMapSnapshotter(options: options)
snapshotter<span class="pl-k">.</span>startWithCompletionHandler { snapshot, error <span class="pl-k">in</span>
    <span class="pl-k">guard</span> <span class="pl-k">let</span> snapshot <span class="pl-k">=</span> snapshot <span class="pl-k">else</span> {
        <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Snapshot error: <span class="pl-pse">\(</span><span class="pl-s1">error</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
        <span class="pl-k">return</span>
    }

    <span class="pl-k">let</span> data <span class="pl-k">=</span> UIImagePNGRepresentation(snapshot<span class="pl-k">.</span>image)
    data?<span class="pl-k">.</span>writeToURL(fileURL, atomically: <span class="pl-c1">true</span>)
}</pre></div>

<div class="highlight highlight-source-objc"><pre>MKMapSnapshotOptions *options = [[MKMapSnapshotOptions <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
options.region = self.mapView.region;
options.size = self.mapView.frame.size;
options.scale = [[UIScreen <span class="pl-c1">mainScreen</span>] <span class="pl-c1">scale</span>];

<span class="pl-c1">NSURL</span> *fileURL = [<span class="pl-c1">NSURL</span> <span class="pl-c1">fileURLWithPath:</span><span class="pl-s"><span class="pl-pds">@"</span>path/to/snapshot.png<span class="pl-pds">"</span></span>];

MKMapSnapshotter *snapshotter = [[MKMapSnapshotter <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithOptions:</span>options];
[snapshotter <span class="pl-c1">startWithCompletionHandler:</span>^(MKMapSnapshot *snapshot, <span class="pl-c1">NSError</span> *error) {
    <span class="pl-k">if</span> (error) {
        <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
        <span class="pl-k">return</span>;
    }

    UIImage *image = snapshot.<span class="pl-smi">image</span>;
    <span class="pl-c1">NSData</span> *data = <span class="pl-c1">UIImagePNGRepresentation</span>(image);
    [data <span class="pl-c1">writeToURL:</span>fileURL <span class="pl-c1">atomically:</span><span class="pl-c1">YES</span>];
}];</pre></div>

<p>First, an <code>MKMapSnapshotOptions</code> object is created, which is used to specify the region, size, scale, and <a href="https://developer.apple.com/library/mac/documentation/MapKit/Reference/MKMapCamera_class/Reference/Reference.html">camera</a> used to render the map image.</p>

<p>Then, these options are passed to a new <code>MKMapSnapshotter</code> instance, which asynchronously creates an image with <code>-startWithCompletionHandler:</code>. In this example, a PNG representation of the image is written to disk.</p>

<h3><a id="user-content-drawing-annotations-on-map-view-snapshot" class="anchor" href="#drawing-annotations-on-map-view-snapshot" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Drawing Annotations on Map View Snapshot</h3>

<p>However, this only draws the map for the specified region; annotations are rendered separately.</p>

<p>Including annotations—or indeed, any additional information to the map snapshot—can be done by dropping down into Core Graphics:</p>

<div class="highlight highlight-source-swift"><pre>snapshotter<span class="pl-k">.</span>startWithQueue(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="pl-c1">0</span>)) { snapshot, error <span class="pl-k">in</span>
    <span class="pl-k">guard</span> <span class="pl-k">let</span> snapshot <span class="pl-k">=</span> snapshot <span class="pl-k">else</span> {
        <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Snapshot error: <span class="pl-pse">\(</span><span class="pl-s1">error</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
        fatalError()
    }

    <span class="pl-k">let</span> pin <span class="pl-k">=</span> MKPinAnnotationView(annotation: <span class="pl-c1">nil</span>, reuseIdentifier: <span class="pl-c1">nil</span>)
    <span class="pl-k">let</span> image <span class="pl-k">=</span> snapshot<span class="pl-k">.</span>image

    UIGraphicsBeginImageContextWithOptions(image<span class="pl-k">.</span>size, <span class="pl-c1">true</span>, image<span class="pl-k">.</span>scale)
    image<span class="pl-k">.</span>drawAtPoint(CGPoint<span class="pl-k">.</span>zero)

    <span class="pl-k">let</span> visibleRect <span class="pl-k">=</span> CGRect(origin: CGPoint<span class="pl-k">.</span>zero, size: image<span class="pl-k">.</span>size)
    <span class="pl-k">for</span> annotation <span class="pl-k">in</span> mapView<span class="pl-k">.</span>annotations {
        <span class="pl-k">var</span> point <span class="pl-k">=</span> snapshot<span class="pl-k">.</span>pointForCoordinate(annotation<span class="pl-k">.</span>coordinate)
        <span class="pl-k">if</span> visibleRect<span class="pl-k">.</span><span class="pl-c1">contains</span>(point) {
            point<span class="pl-k">.</span>x <span class="pl-k">=</span> point<span class="pl-k">.</span>x <span class="pl-k">+</span> pin<span class="pl-k">.</span>centerOffset<span class="pl-k">.</span>x <span class="pl-k">-</span> (pin<span class="pl-k">.</span>bounds<span class="pl-k">.</span>size<span class="pl-k">.</span>width <span class="pl-k">/</span> <span class="pl-c1">2</span>)
            point<span class="pl-k">.</span>y <span class="pl-k">=</span> point<span class="pl-k">.</span>y <span class="pl-k">+</span> pin<span class="pl-k">.</span>centerOffset<span class="pl-k">.</span>y <span class="pl-k">-</span> (pin<span class="pl-k">.</span>bounds<span class="pl-k">.</span>size<span class="pl-k">.</span>height <span class="pl-k">/</span> <span class="pl-c1">2</span>)
            pin<span class="pl-k">.</span>image?<span class="pl-k">.</span>drawAtPoint(point)
        }
    }

    <span class="pl-k">let</span> compositeImage <span class="pl-k">=</span> UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    <span class="pl-k">let</span> data <span class="pl-k">=</span> UIImagePNGRepresentation(compositeImage)
    data?<span class="pl-k">.</span>writeToURL(fileURL, atomically: <span class="pl-c1">true</span>)
}</pre></div>

<div class="highlight highlight-source-objc"><pre>[snapshotter <span class="pl-c1">startWithQueue:</span><span class="pl-c1">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="pl-c1">0</span>)
              <span class="pl-c1">completionHandler:</span>^(MKMapSnapshot *snapshot, <span class="pl-c1">NSError</span> *error) {
      <span class="pl-k">if</span> (error) {
          <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
          <span class="pl-k">return</span>;
      }

      MKAnnotationView *pin = [[MKPinAnnotationView <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithAnnotation:</span><span class="pl-c1">nil</span> <span class="pl-c1">reuseIdentifier:</span><span class="pl-c1">nil</span>];

      UIImage *image = snapshot.<span class="pl-smi">image</span>;
      <span class="pl-c1">UIGraphicsBeginImageContextWithOptions</span>(image.<span class="pl-smi">size</span>, <span class="pl-c1">YES</span>, image.<span class="pl-smi">scale</span>);
      {
          [image <span class="pl-c1">drawAtPoint:</span><span class="pl-c1">CGPointMake</span>(<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>, <span class="pl-c1">0</span>.<span class="pl-c1">0f</span>)];

          <span class="pl-c1">CGRect</span> rect = <span class="pl-c1">CGRectMake</span>(<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>, <span class="pl-c1">0</span>.<span class="pl-c1">0f</span>, image.<span class="pl-smi">size</span>.<span class="pl-smi">width</span>, image.<span class="pl-smi">size</span>.<span class="pl-smi">height</span>);
          <span class="pl-k">for</span> (<span class="pl-k">id</span> &lt;MKAnnotation&gt; annotation in self.<span class="pl-smi">mapView</span>.<span class="pl-smi">annotations</span>) {
              <span class="pl-c1">CGPoint</span> point = [snapshot <span class="pl-c1">pointForCoordinate:</span>annotation.coordinate];
              <span class="pl-k">if</span> (<span class="pl-c1">CGRectContainsPoint</span>(rect, point)) {
                  point.<span class="pl-smi">x</span> = point.<span class="pl-smi">x</span> + pin.<span class="pl-smi">centerOffset</span>.<span class="pl-smi">x</span> -
                                (pin.<span class="pl-smi">bounds</span>.<span class="pl-smi">size</span>.<span class="pl-smi">width</span> / <span class="pl-c1">2</span>.<span class="pl-c1">0f</span>);
                  point.<span class="pl-smi">y</span> = point.<span class="pl-smi">y</span> + pin.<span class="pl-smi">centerOffset</span>.<span class="pl-smi">y</span> -
                                (pin.<span class="pl-smi">bounds</span>.<span class="pl-smi">size</span>.<span class="pl-smi">height</span> / <span class="pl-c1">2</span>.<span class="pl-c1">0f</span>);
                  [pin.image <span class="pl-c1">drawAtPoint:</span>point];
              }
          }

          UIImage *compositeImage = <span class="pl-c1">UIGraphicsGetImageFromCurrentImageContext</span>();
          <span class="pl-c1">NSData</span> *data = <span class="pl-c1">UIImagePNGRepresentation</span>(compositeImage);
          [data <span class="pl-c1">writeToURL:</span>fileURL <span class="pl-c1">atomically:</span><span class="pl-c1">YES</span>];
      }
      <span class="pl-c1">UIGraphicsEndImageContext</span>();
}];</pre></div>

<h2><a id="user-content-mkdirections" class="anchor" href="#mkdirections" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MKDirections</h2>

<p>The final iOS 7 addition to MapKit that we'll discuss is <a href="https://developer.apple.com/library/mac/documentation/MapKit/Reference/MKDirections_class/Reference/Reference.html"><code>MKDirections</code></a>.</p>

<blockquote>
<p><code>MKDirections</code>' spiritual predecessor (of sorts), <a href="https://developer.apple.com/library/ios/documentation/MapKit/Reference/MKLocalSearch/Reference/Reference.html"><code>MKLocalSearch</code></a> was discussed in <a href="http://nshipster.com/mklocalsearch/">a previous NSHipster article</a></p>
</blockquote>

<p>As its name implies, <code>MKDirections</code> fetches routes between two waypoints. A <code>MKDirectionsRequest</code> object is initialized with a <code>source</code> and <code>destination</code>, and is then passed into an <code>MKDirections</code> object, which can calculate several possible routes and estimated travel times.</p>

<p>It does so asynchronously, with <code>calculateDirectionsWithCompletionHandler:</code>, which returns either an <code>MKDirectionsResponse</code> object or an <code>NSError</code> describing why the directions request failed. An <code>MKDirectionsResponse</code> object contains an array of <code>routes</code>: <code>MKRoute</code> objects with an array of <code>MKRouteStep</code> <code>steps</code> objects, a polyline shape that can be drawn on the map, and other information like estimated travel distance and any travel advisories in effect.</p>

<p>Building on the previous example, here is how <code>MKDirections</code> might be used to create an array of images representing each step in a calculated route between two points (which might then be pasted into an email or cached on disk):</p>

<h3><a id="user-content-getting-snapshots-for-each-step-of-directions-on-a-map-view" class="anchor" href="#getting-snapshots-for-each-step-of-directions-on-a-map-view" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting Snapshots for each Step of Directions on a Map View</h3>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> request <span class="pl-k">=</span> MKDirectionsRequest()
request<span class="pl-k">.</span>source <span class="pl-k">=</span> MKMapItem<span class="pl-k">.</span>mapItemForCurrentLocation()
request<span class="pl-k">.</span>destination <span class="pl-k">=</span> MKMapItem(<span class="pl-k">...</span>)

<span class="pl-k">let</span> directions <span class="pl-k">=</span> MKDirections(request: request)
directions<span class="pl-k">.</span>calculateDirectionsWithCompletionHandler { response, error <span class="pl-k">in</span>
    <span class="pl-k">guard</span> <span class="pl-k">let</span> response <span class="pl-k">=</span> response <span class="pl-k">else</span> {
        <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Directions error: <span class="pl-pse">\(</span><span class="pl-s1">error</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
        <span class="pl-k">return</span>
    }

    stepImagesFromDirectionsResponse(response) { stepImages <span class="pl-k">in</span>
        stepImages<span class="pl-k">.</span><span class="pl-c1">first</span>
        <span class="pl-c1">print</span>(stepImages)
    }
}

<span class="pl-k">func</span> <span class="pl-en">stepImagesFromDirectionsResponse</span>(response: MKDirectionsResponse, completionHandler: ([UIImage]) <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>) {
    <span class="pl-k">guard</span> <span class="pl-k">let</span> route <span class="pl-k">=</span> response<span class="pl-k">.</span>routes<span class="pl-k">.</span><span class="pl-c1">first</span> <span class="pl-k">else</span> {
        completionHandler([])
        <span class="pl-k">return</span>
    }

    <span class="pl-k">var</span> stepImages: [UIImage?] <span class="pl-k">=</span> <span class="pl-c1">Array</span>(count: route<span class="pl-k">.</span>steps<span class="pl-k">.</span><span class="pl-c1">count</span>, repeatedValue: <span class="pl-c1">nil</span>)
    <span class="pl-k">var</span> stepImageCount <span class="pl-k">=</span> <span class="pl-c1">0</span>

    <span class="pl-k">for</span> (index, step) <span class="pl-k">in</span> route<span class="pl-k">.</span>steps<span class="pl-k">.</span><span class="pl-c1">enumerate</span>() {
        <span class="pl-k">let</span> snapshotter <span class="pl-k">=</span> MKMapSnapshotter(options: options)
        snapshotter<span class="pl-k">.</span>startWithCompletionHandler { snapshot, error <span class="pl-k">in</span>
            <span class="pl-k">++</span>stepImageCount

            <span class="pl-k">guard</span> <span class="pl-k">let</span> snapshot <span class="pl-k">=</span> snapshot <span class="pl-k">else</span> {
                <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Snapshot error: <span class="pl-pse">\(</span><span class="pl-s1">error</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
                <span class="pl-k">return</span>
            }

            <span class="pl-k">let</span> image <span class="pl-k">=</span> snapshot<span class="pl-k">.</span>image

            UIGraphicsBeginImageContextWithOptions(image<span class="pl-k">.</span>size, <span class="pl-c1">true</span>, image<span class="pl-k">.</span>scale)
            image<span class="pl-k">.</span>drawAtPoint(CGPoint<span class="pl-k">.</span>zero)

            <span class="pl-c">// draw the path</span>
            <span class="pl-k">guard</span> <span class="pl-k">let</span> c <span class="pl-k">=</span> UIGraphicsGetCurrentContext() <span class="pl-k">else</span> { <span class="pl-k">return</span> }
            CGContextSetStrokeColorWithColor(c, UIColor<span class="pl-k">.</span>blueColor()<span class="pl-k">.</span>CGColor)
            CGContextSetLineWidth(c, <span class="pl-c1">3</span>)
            CGContextBeginPath(c)

            <span class="pl-k">var</span> coordinates: <span class="pl-c1">UnsafeMutablePointer</span><span class="pl-k">&lt;</span>CLLocationCoordinate2D<span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-c1">UnsafeMutablePointer</span><span class="pl-k">.</span>alloc(step<span class="pl-k">.</span>polyline<span class="pl-k">.</span>pointCount)
            <span class="pl-k">defer</span> { coordinates<span class="pl-k">.</span><span class="pl-c1">dealloc</span>(step<span class="pl-k">.</span>polyline<span class="pl-k">.</span>pointCount) }

            step<span class="pl-k">.</span>polyline<span class="pl-k">.</span>getCoordinates(coordinates, range: NSRange(location: <span class="pl-c1">0</span>, length: step<span class="pl-k">.</span>polyline<span class="pl-k">.</span>pointCount))

            <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">0</span> <span class="pl-k">..&lt;</span> step<span class="pl-k">.</span>polyline<span class="pl-k">.</span>pointCount {
                <span class="pl-k">let</span> p <span class="pl-k">=</span> snapshot<span class="pl-k">.</span>pointForCoordinate(coordinates[i])
                <span class="pl-k">if</span> i <span class="pl-k">==</span> <span class="pl-c1">0</span> {
                    CGContextMoveToPoint(c, p<span class="pl-k">.</span>x, p<span class="pl-k">.</span>y)
                } <span class="pl-k">else</span> {
                    CGContextAddLineToPoint(c, p<span class="pl-k">.</span>x, p<span class="pl-k">.</span>y)
                }
            }

            CGContextStrokePath(c)

            <span class="pl-c">// add the start and end points</span>
            <span class="pl-k">let</span> visibleRect <span class="pl-k">=</span> CGRect(origin: CGPoint<span class="pl-k">.</span>zero, size: image<span class="pl-k">.</span>size)

            <span class="pl-k">for</span> mapItem <span class="pl-k">in</span> [response<span class="pl-k">.</span>source, response<span class="pl-k">.</span>destination]
                <span class="pl-k">where</span> mapItem<span class="pl-k">.</span>placemark<span class="pl-k">.</span>location <span class="pl-k">!=</span> <span class="pl-c1">nil</span> {
                <span class="pl-k">var</span> point <span class="pl-k">=</span> snapshot<span class="pl-k">.</span>pointForCoordinate(mapItem<span class="pl-k">.</span>placemark<span class="pl-k">.</span>location<span class="pl-k">!.</span>coordinate)
                <span class="pl-k">if</span> visibleRect<span class="pl-k">.</span><span class="pl-c1">contains</span>(point) {
                    <span class="pl-k">let</span> pin <span class="pl-k">=</span> MKPinAnnotationView(annotation: <span class="pl-c1">nil</span>, reuseIdentifier: <span class="pl-c1">nil</span>)
                    pin<span class="pl-k">.</span>pinTintColor <span class="pl-k">=</span> mapItem<span class="pl-k">.</span>isEqual(response<span class="pl-k">.</span>source) <span class="pl-k">?</span>
                            MKPinAnnotationView<span class="pl-k">.</span>greenPinColor() <span class="pl-k">:</span> MKPinAnnotationView<span class="pl-k">.</span>redPinColor()
                    point<span class="pl-k">.</span>x <span class="pl-k">=</span> point<span class="pl-k">.</span>x <span class="pl-k">+</span> pin<span class="pl-k">.</span>centerOffset<span class="pl-k">.</span>x <span class="pl-k">-</span> (pin<span class="pl-k">.</span>bounds<span class="pl-k">.</span>size<span class="pl-k">.</span>width <span class="pl-k">/</span> <span class="pl-c1">2</span>)
                    point<span class="pl-k">.</span>y <span class="pl-k">=</span> point<span class="pl-k">.</span>y <span class="pl-k">+</span> pin<span class="pl-k">.</span>centerOffset<span class="pl-k">.</span>y <span class="pl-k">-</span> (pin<span class="pl-k">.</span>bounds<span class="pl-k">.</span>size<span class="pl-k">.</span>height <span class="pl-k">/</span> <span class="pl-c1">2</span>)
                    pin<span class="pl-k">.</span>image?<span class="pl-k">.</span>drawAtPoint(point)
                }
            }

            <span class="pl-k">let</span> stepImage <span class="pl-k">=</span> UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()

            stepImages[index] <span class="pl-k">=</span> stepImage

            <span class="pl-k">if</span> stepImageCount <span class="pl-k">==</span> stepImages<span class="pl-k">.</span><span class="pl-c1">count</span> {
                completionHandler(stepImages<span class="pl-k">.</span><span class="pl-c1">flatMap</span>({ $<span class="pl-c1">0</span> }))
            }
        }
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSMutableArray</span> *mutableStepImages = [<span class="pl-c1">NSMutableArray</span> <span class="pl-c1">array</span>];

MKDirectionsRequest *request = [[MKDirectionsRequest <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
request.source = [MKMapItem <span class="pl-c1">mapItemForCurrentLocation</span>];
request.destination = ...;

MKDirections *directions = [[MKDirections <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithRequest:</span>request];
[directions <span class="pl-c1">calculateDirectionsWithCompletionHandler:</span>^(MKDirectionsResponse *response, <span class="pl-c1">NSError</span> *error) {
    <span class="pl-k">if</span> (error) {
        <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
        <span class="pl-k">return</span>;
    }

    MKRoute *route = [response.routes <span class="pl-c1">firstObject</span>];
    <span class="pl-k">for</span> (MKRouteStep *step in route.<span class="pl-smi">steps</span>) {
        [snapshotter <span class="pl-c1">startWithCompletionHandler:</span>^(MKMapSnapshot *snapshot, <span class="pl-c1">NSError</span> *error) {
            <span class="pl-k">if</span> (error) {
                <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>[Error] <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error);
                <span class="pl-k">return</span>;
            }

            UIImage *image = snapshot.<span class="pl-smi">image</span>;
            <span class="pl-c1">UIGraphicsBeginImageContextWithOptions</span>(image.<span class="pl-smi">size</span>, <span class="pl-c1">YES</span>, image.<span class="pl-smi">scale</span>);
            {
                [image <span class="pl-c1">drawAtPoint:</span><span class="pl-c1">CGPointMake</span>(<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>, <span class="pl-c1">0</span>.<span class="pl-c1">0f</span>)];

                <span class="pl-c1">CGContextRef</span> c = <span class="pl-c1">UIGraphicsGetCurrentContext</span>();
                MKPolylineRenderer *polylineRenderer = [[MKPolylineRenderer <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithPolyline:</span>step.polyline];
                <span class="pl-k">if</span> (polylineRenderer.<span class="pl-smi">path</span>) {
                    [polylineRenderer <span class="pl-c1">applyStrokePropertiesToContext:</span>c <span class="pl-c1">atZoomScale:</span><span class="pl-c1">1</span>.<span class="pl-c1">0f</span>];
                    <span class="pl-c1">CGContextAddPath</span>(c, polylineRenderer.<span class="pl-smi">path</span>);
                    <span class="pl-c1">CGContextStrokePath</span>(c);
                }

                <span class="pl-c1">CGRect</span> rect = <span class="pl-c1">CGRectMake</span>(<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>, <span class="pl-c1">0</span>.<span class="pl-c1">0f</span>, image.<span class="pl-smi">size</span>.<span class="pl-smi">width</span>, image.<span class="pl-smi">size</span>.<span class="pl-smi">height</span>);
                <span class="pl-k">for</span> (MKMapItem *mapItem in @[response.source, response.destination]) {
                    <span class="pl-c1">CGPoint</span> point = [snapshot <span class="pl-c1">pointForCoordinate:</span>mapItem.placemark.location.coordinate];
                    <span class="pl-k">if</span> (<span class="pl-c1">CGRectContainsPoint</span>(rect, point)) {
                        MKPinAnnotationView *pin = [[MKPinAnnotationView <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithAnnotation:</span><span class="pl-c1">nil</span> <span class="pl-c1">reuseIdentifier:</span><span class="pl-c1">nil</span>];
                        pin.<span class="pl-smi">pinColor</span> = [mapItem <span class="pl-c1">isEqual:</span>response.source] ? MKPinAnnotationColorGreen : MKPinAnnotationColorRed;

                        point.<span class="pl-smi">x</span> = point.<span class="pl-smi">x</span> + pin.<span class="pl-smi">centerOffset</span>.<span class="pl-smi">x</span> -
                            (pin.<span class="pl-smi">bounds</span>.<span class="pl-smi">size</span>.<span class="pl-smi">width</span> / <span class="pl-c1">2</span>.<span class="pl-c1">0f</span>);
                        point.<span class="pl-smi">y</span> = point.<span class="pl-smi">y</span> + pin.<span class="pl-smi">centerOffset</span>.<span class="pl-smi">y</span> -
                            (pin.<span class="pl-smi">bounds</span>.<span class="pl-smi">size</span>.<span class="pl-smi">height</span> / <span class="pl-c1">2</span>.<span class="pl-c1">0f</span>);
                        [pin.image <span class="pl-c1">drawAtPoint:</span>point];
                    }
                }

                UIImage *stepImage = <span class="pl-c1">UIGraphicsGetImageFromCurrentImageContext</span>();
                [mutableStepImages <span class="pl-c1">addObject:</span>stepImage];
            }
            <span class="pl-c1">UIGraphicsEndImageContext</span>();
        }];
    }
}];</pre></div>

<hr>

<p>As the tools used to map the world around us become increasingly sophisticated and ubiquitous, we become ever more capable of uncovering and communicating connections we create between ideas and the spaces they inhabit. With the introduction of several new MapKit APIs, iOS 7 took great strides to expand on what's possible. Although (perhaps unfairly) overshadowed by the mistakes of the past, MapKit is, and remains an extremely capable framework, worthy of further investigation.</p>
</article></div>