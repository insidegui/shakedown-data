<div class="announce instapaper_body md" data-path="2015-06-29-cloudkit.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>CloudKit</div></td>

  <td><div>Croath Liu</div></td>

  <td><div>Cocoa</div></td>

  <td><div>As an iOS developer, if you want to make an application on your own, you sometimes need to write back-end code. Even for the developer who can take that on, there is more than just the code, there's also maintenance. Your worst fear becomes not that people might not like your application, but that your server might fail under heavy traffic.

Fortunately, we now have CloudKit. Apple takes care of all these details, so you can focus on how to make your application great.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>As an iOS developer, if you want to make an application on your own, you sometimes need to write back-end code. Even for the developer who can take that on, there is more than just the code, there's also maintenance. Your worst fear becomes not that people might not like your application, but that your server might fail under heavy traffic.</p>

<p>Fortunately, we now have CloudKit. Apple takes care of all these details, so you can focus on how to make your application great. </p>

<h2><a id="user-content-what-is-cloudkit" class="anchor" href="#what-is-cloudkit" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is CloudKit?</h2>

<p>Perhaps you've heard of iCloud Drive before—iCloud Drive is where we can store our user's data and files for easy access from other devices. CloudKit is the framework that helps us do this easily in the apps we create.</p>

<p>CloudKit offers tons of APIs to access iCloud. You can create a user model inside your application linked to a user's iCloud account. Meanwhile, you can have a public global database to store application-level data. You can also save large files and bulk data into iCloud Drive, so your users can use their data from their other devices. This works just like working on local files, but with all the operations sent to the cloud.</p>

<p>Overall, CloudKit is a framework that replaces back-end web services like old-school databases, file storage, and user authentication systems. With CloudKit's help you don't need to worry about any of these, so you can focus your energy on your application.</p>

<h2><a id="user-content-get-into-cloudkit" class="anchor" href="#get-into-cloudkit" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Get into CloudKit</h2>

<p>Imagine that you're working on a check-in application where users can add "places" with their location and check in at these places. We'll talk about how to build some basic functions of the check-in application with CloudKit.</p>

<h3><a id="user-content-enable-cloudkit" class="anchor" href="#enable-cloudkit" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enable CloudKit</h3>

<p>We have already talked about how powerful CloudKit is, now it is the time to show you how to use it. It's simple. All you need is to turn on <code>iCloud</code> and check <code>CloudKit</code> in the project panel of Xcode:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/cloudkit-xcode.png" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/cloudkit-xcode.png" alt="Enabling CloudKit in Xcode" style="max-width:100%;"></a></p>

<h3><a id="user-content-fundamental-cloudkit-objects" class="anchor" href="#fundamental-cloudkit-objects" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fundamental CloudKit Objects</h3>

<p>There are 7 different fundamental objects in CloudKit. You may have seen this elsewhere in your programming career, but there are some slight differences.</p>

<ul>
<li><p><code>CKContainer</code>: A container is like a sandbox. An application can only use the resources inside its container. The container is located at the very outer border and each application has one and only one separate container. (You can allow other applications to access your container by configuring  CloudKit Dashboard.)</p></li>
<li><p><code>CKDatabase</code>: A database is the place that you put all your data. There are two different kinds of databases: private and public. The private database is where you store sensitive data, like user's information. The public database is where you store shared data. For example, in our check-in application, you would store a user's birthday and check-ins in the private database but store "places" information in the public database.</p></li>
<li><p><code>CKRecord</code>: A record is a piece of data inside your database. It is stored as a key-value pair. For now, you can save <code>NSString</code>, <code>NSNumber</code>, <code>NSData</code>, <code>NSDate</code>, <code>CLLocation</code>, <code>CKReference</code>, and <code>CKAsset</code>, as well as arrays of  all the types listed above.</p></li>
<li><p><code>CKRecordZone</code>: Records are not stored scattered in a database, they are located in record zones. Every application has a default record zone, and you can also have your own custom record zones.</p></li>
<li><p><code>CKRecordIdentifier</code>: the unique label of a record, used for locating a particular record.</p></li>
<li><p><code>CKReference</code>: Reference is like the relationship in an RDBMS. In our check-in example, there may be many people checked in at the same place, so we'll need to establish a reference between places and check-ins.</p></li>
<li><p><code>CKAsset</code>: Assets are resources, like binary files or bulk data. For example, a user's picture should be stored as an asset.</p></li>
</ul>

<h3><a id="user-content-convenience-api" class="anchor" href="#convenience-api" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Convenience API</h3>

<p>CloudKit's convenience API is there to do basic operations such as reading, writing, and editing records.</p>

<p>Let's work on our check-in application. To get started, import the CloudKit framework and get a reference to the public database:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">import</span> <span class="pl-c1">CloudKit</span>
<span class="pl-c">// ...</span>

<span class="pl-k">let</span> publicDB <span class="pl-k">=</span> CKContainer<span class="pl-k">.</span>defaultContainer()<span class="pl-k">.</span>publicCloudDatabase</pre></div>

<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>CloudKit/CloudKit.h<span class="pl-pds">&gt;</span></span>
<span class="pl-c">// ...</span>

CKDatabase *publicDB = [[CKContainer <span class="pl-c1">defaultContainer</span>] <span class="pl-c1">publicCloudDatabase</span>];</pre></div>

<p>Next, create a new place and save it:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> greatID <span class="pl-k">=</span> CKRecordID(recordName: <span class="pl-s"><span class="pl-pds">"</span>GreatPlace<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> place <span class="pl-k">=</span> CKRecord(recordType: <span class="pl-s"><span class="pl-pds">"</span>Place<span class="pl-pds">"</span></span>, recordID: greatID)

publicDB<span class="pl-k">.</span>saveRecord(place) { savedRecord, error <span class="pl-k">in</span>
    <span class="pl-c">// handle errors here</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre>CKRecordID *greatID = [[CKRecordID <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithRecordName:</span><span class="pl-s"><span class="pl-pds">@"</span>GreatPlace<span class="pl-pds">"</span></span>];
CKRecord *place = [[CKRecord <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithRecordType:</span><span class="pl-s"><span class="pl-pds">@"</span>Place<span class="pl-pds">"</span></span> <span class="pl-c1">recordID:</span>greatID];

[publicDB <span class="pl-c1">saveRecord:</span>place <span class="pl-c1">completionHandler:</span>^(CKRecord *savedPlace, <span class="pl-c1">NSError</span> *error) {
    <span class="pl-c">// handle errors here</span>
}];</pre></div>

<p>CloudKit will connect to the Internet asynchronously when <code>saveRecord:completionHandler:</code> method is invoked. Remember to handle the error in the block, since the user's connection may be unstable. A good application deserves perfect error handling logic.</p>

<p>You should check the error code of the <code>NSError</code> object to detect which kind of error you are dealing with. A <code>CKErrorNetworkUnavailable</code> error may occur if you were on a bad internet connection, and what you need to do is to retry the operation after failure. But when to retry? Immediately or 10 seconds later? Don't worry, CloudKit offers a suggestion in the error's <code>userInfo</code> dictionary with the key <code>CKErrorRetryAfterKey</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">if</span> <span class="pl-k">let</span> retryAfterValue <span class="pl-k">=</span> error<span class="pl-k">.</span>userInfo[CKErrorRetryAfterKey] <span class="pl-k">as?</span> NSTimeInterval {
    <span class="pl-k">let</span> retryAfterDate <span class="pl-k">=</span> NSDate(timeIntervalSinceNow: retryAfterValue)
    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">double</span> retryAfterValue = [error.userInfo[CKErrorRetryAfterKey] <span class="pl-c1">doubleValue</span>];
<span class="pl-c1">NSDate</span> *retryAfterDate = [<span class="pl-c1">NSDate</span> <span class="pl-c1">dateWithTimeIntervalSinceNow:</span>retryAfterValue];</pre></div>

<p>Here I'll read the place's information back:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> greatID <span class="pl-k">=</span> CKRecordID(recordName: <span class="pl-s"><span class="pl-pds">"</span>GreatPlace<span class="pl-pds">"</span></span>)

publicDB<span class="pl-k">.</span>fetchRecordWithID(greatID) { fetchedPlace, error <span class="pl-k">in</span>
    <span class="pl-c">// handle errors here</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre>CKRecordID *greatID = [[CKRecordID <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithRecordName:</span><span class="pl-s"><span class="pl-pds">@"</span>GreatPlace<span class="pl-pds">"</span></span>];

[publicDB <span class="pl-c1">fetchRecordWithID:</span>greatID <span class="pl-c1">completionHandler:</span>^(CKRecord *fetchedPlace, <span class="pl-c1">NSError</span> *error) {
    <span class="pl-c">// handle errors here</span>
}];</pre></div>

<p>And here I'll edit an existing place's information:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> greatID <span class="pl-k">=</span> CKRecordID(recordName: <span class="pl-s"><span class="pl-pds">"</span>GreatPlace<span class="pl-pds">"</span></span>)

publicDB<span class="pl-k">.</span>fetchRecordWithID(greatID) { fetchedPlace, error <span class="pl-k">in</span>
    <span class="pl-k">guard</span> <span class="pl-k">let</span> fetchedPlace <span class="pl-k">=</span> fetchedPlace <span class="pl-k">else</span> {
        <span class="pl-c">// handle errors here</span>
        <span class="pl-k">return</span>
    }

    <span class="pl-k">let</span> name <span class="pl-k">=</span> fetchedPlace[<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>] <span class="pl-k">as?</span> <span class="pl-c1">String</span> <span class="pl-k">??</span> <span class="pl-s"><span class="pl-pds">"</span>Unnamed Place<span class="pl-pds">"</span></span>
    fetchedPlace[<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> Door A<span class="pl-pds">"</span></span>

    publicDB<span class="pl-k">.</span>saveRecord(fetchedPlace) { savedPlace, savedError <span class="pl-k">in</span>
        <span class="pl-c">//...</span>
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>CKRecordID *greatID = [[CKRecordID <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithRecordName:</span><span class="pl-s"><span class="pl-pds">@"</span>GreatPlace<span class="pl-pds">"</span></span>];

[publicDB <span class="pl-c1">fetchRecordWithID:</span>greatID <span class="pl-c1">completionHandler:</span>^(CKRecord *fetchedPlace, <span class="pl-c1">NSError</span> *error) {
    <span class="pl-k">if</span> (fetchedPlace != <span class="pl-c1">nil</span>) {
        <span class="pl-c1">NSString</span> *name = fetchedPlace[<span class="pl-s"><span class="pl-pds">@"</span>name<span class="pl-pds">"</span></span>];
        fetchedPlace[<span class="pl-s"><span class="pl-pds">@"</span>name<span class="pl-pds">"</span></span>] = [name <span class="pl-c1">stringByAppendingString:</span><span class="pl-s"><span class="pl-pds">@"</span> Door A<span class="pl-pds">"</span></span>];

        [publicDB <span class="pl-c1">saveRecord:</span>fetchedPlace <span class="pl-c1">completionHandler:</span>^(CKRecord *savedPlace, <span class="pl-c1">NSError</span> *savedError) {
            <span class="pl-c">//...</span>
        }];
    } <span class="pl-k">else</span> {
        <span class="pl-c">// handle errors here</span>
    }
}];</pre></div>

<p>The progress of editing a record is pretty simple: read, edit, then save. What you should really pay attention to is <em>how</em> to do the three-step updating process, especially when updating one record depends on fetching others.</p>

<p>A bad practice:</p>

<div class="highlight highlight-source-swift"><pre>database<span class="pl-k">.</span>fetchRecordWithID(recordID, completionHandler: { record, error <span class="pl-k">in</span>
    <span class="pl-c">//...</span>
    database<span class="pl-k">.</span>fetchRecordWithID(otherRecordID, completionHandler: { otherRecord, otherError <span class="pl-k">in</span>
        <span class="pl-c">//...</span>
        database<span class="pl-k">.</span>saveRecord(record<span class="pl-k">!</span>, completionHandler: { anotherRecord, anotherError <span class="pl-k">in</span>
            <span class="pl-c">//...</span>
        })
    })
})</pre></div>

<div class="highlight highlight-source-objc"><pre>[database <span class="pl-c1">fetchRecordWithID:</span>recordID <span class="pl-c1">completionHandler:</span>^(CKRecord *record, <span class="pl-c1">NSError</span> *error) {
    <span class="pl-c">//...</span>
        [database <span class="pl-c1">fetchRecordWithID:</span>otherRecordID <span class="pl-c1">completionHandler:</span>^(CKRecord *otherRecord, <span class="pl-c1">NSError</span> *otherError) {
            <span class="pl-c">//...</span>
                [database <span class="pl-c1">saveRecord:</span>record <span class="pl-c1">completionHandler:</span>^(CKRecord *anotherRecord, <span class="pl-c1">NSError</span> *anotherError) {
                    <span class="pl-c">//...</span>
                }];
        }];
}];</pre></div>

<p>With very complex nested operations you may run into a dilemma: There are three (or more) blocks and three (or more) errors to handle, so where should you handle the errors? where should you retry the operation if an error occurs? All together it starts looking like kind of a disaster.</p>

<p>A better approach is to use <code>NSOperation</code> dependencies to manage the dependent tasks:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> firstFetch <span class="pl-k">=</span> CKFetchRecordsOperation()
<span class="pl-k">let</span> secondFetch <span class="pl-k">=</span> CKFetchRecordsOperation()

secondFetch<span class="pl-k">.</span>addDependency(firstFetch)

<span class="pl-k">let</span> queue <span class="pl-k">=</span> NSOperationQueue()
queue<span class="pl-k">.</span>addOperations([firstFetch, secondFetch], waitUntilFinished: <span class="pl-c1">false</span>)</pre></div>

<div class="highlight highlight-source-objc"><pre>CKFetchRecordsOperation *firstFetch = ...;
CKFetchRecordsOperation *secondFetch = ...;

[secondFetch <span class="pl-c1">addDependency:</span>firstFetch];

<span class="pl-c1">NSOperationQueue</span> *queue = [[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
[queue <span class="pl-c1">addOperations:</span>[firstFetch, secondFetch] <span class="pl-c1">waitUntilFinished:</span> <span class="pl-c1">NO</span>];</pre></div>

<p>You can finish almost all the work you need to do with the convenience API. What do you think so far? It's much easier than writing backend code, maintaining a server, and writing the code to communicate with it.</p>

<h2><a id="user-content-advanced-features" class="anchor" href="#advanced-features" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced Features</h2>

<h3><a id="user-content-queries" class="anchor" href="#queries" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Queries</h3>

<p>While powerful, the convenience APIs aren't quite enough to finish our check-in application—now it's time to add search functionality. To add a search function, you will need a <em>query</em>. A <code>CKQuery</code> object is made up of <code>RecordType</code>, <code>NSPredicate</code> and <code>NSSortDescriptors</code>.</p>

<blockquote>
<p><code>NSPredicate</code> plays an important role here, handling string matching, location and date ranging, and combinations of simple queries. Refer to the <a href="https://developer.apple.com/library/ios/documentation/CloudKit/Reference/CKQuery_class/index.html#//apple_ref/occ/cl/CKQuery"><code>CKQuery</code> documentation for more</a>.</p>
</blockquote>

<p>Let's say I want all places starting with the name 'Apple Store':</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> predicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>name BEGINSWITH 'Apple Store'<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> query <span class="pl-k">=</span> CKQuery(recordType: <span class="pl-s"><span class="pl-pds">"</span>Place<span class="pl-pds">"</span></span>, predicate: predicate)

publicDB<span class="pl-k">.</span>performQuery(query, inZoneWithID: <span class="pl-c1">nil</span>) { results, error <span class="pl-k">in</span>
    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSPredicate</span> *predicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>name <span class="pl-k">BEGINSWITH</span> 'Apple Store'<span class="pl-pds">"</span></span>];
CKQuery *query = [[CKQuery <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithRecordType:</span><span class="pl-s"><span class="pl-pds">@"</span>Place<span class="pl-pds">"</span></span> <span class="pl-c1">predicate:</span>predicate];

[publicDB <span class="pl-c1">performQuery:</span>query
          <span class="pl-c1">inZoneWithID:</span><span class="pl-c1">nil</span>
     <span class="pl-c1">completionHandler:</span>^(<span class="pl-c1">NSArray</span> *results, <span class="pl-c1">NSError</span> *error) {
         <span class="pl-c">// ...</span>
     }];</pre></div>

<p>Alternately, you could modify the query to retrieve all the places within one mile around the user.</p>

<h3><a id="user-content-subscriptions" class="anchor" href="#subscriptions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Subscriptions</h3>

<p>After adding queries, our application is almost complete. Or wait, did we forget something?</p>

<p>Yes: notifications. They're a critical part of any check-in application. </p>

<p>For example, a social person may want to be notified if someone mentions something starting with "party" around him or her; for example "party at Sarah's house". This is possible with CloudKit—the framework already provides something to achieve this using the <code>CKSubscription</code> class:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> predicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>description BEGINSWITH 'party'<span class="pl-pds">"</span></span>)

<span class="pl-k">let</span> subscription <span class="pl-k">=</span> CKSubscription(recordType: <span class="pl-s"><span class="pl-pds">"</span>Checkin<span class="pl-pds">"</span></span>, predicate: predicate, options: <span class="pl-k">.</span>FiresOnRecordCreation)

<span class="pl-k">let</span> info <span class="pl-k">=</span> CKNotificationInfo()
info<span class="pl-k">.</span>alertLocalizationKey <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>NEW_PARTY_ALERT_KEY<span class="pl-pds">"</span></span>
info<span class="pl-k">.</span>soundName <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>NewAlert.aiff<span class="pl-pds">"</span></span>
info<span class="pl-k">.</span>shouldBadge <span class="pl-k">=</span> <span class="pl-c1">true</span>

subscription<span class="pl-k">.</span>notificationInfo <span class="pl-k">=</span> info

publicDB<span class="pl-k">.</span>saveSubscription(subscription) { subscription, error <span class="pl-k">in</span>
    <span class="pl-c">//...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre>CKDatabase *publicDB = [[CKContainer <span class="pl-c1">defaultContainer</span>] <span class="pl-c1">publicCloudDatabase</span>];

<span class="pl-c1">NSPredicate</span> *predicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>description <span class="pl-k">BEGINSWITH</span> 'party'<span class="pl-pds">"</span></span>];

CKSubscription *subscription = [[CKSubscription <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithRecordType:</span><span class="pl-s"><span class="pl-pds">@"</span>Checkin<span class="pl-pds">"</span></span> <span class="pl-c1">predicate:</span>predicate <span class="pl-c1">options:</span>CKSubscriptionOptionsFiresOnRecordCreation];

CKNotificationInfo *info = [CKNotificationInfo <span class="pl-c1">new</span>];
info.alertLocalizationKey = <span class="pl-s"><span class="pl-pds">@"</span>NEW_PARTY_ALERT_KEY<span class="pl-pds">"</span></span>;
info.soundName = <span class="pl-s"><span class="pl-pds">@"</span>NewAlert.aiff<span class="pl-pds">"</span></span>;
info.shouldBadge = <span class="pl-c1">YES</span>;

subscription.notificationInfo = info;

[publicDB <span class="pl-c1">saveSubscription:</span>subscription
         <span class="pl-c1">completionHandler:</span>^(CKSubscription *subscription, <span class="pl-c1">NSError</span> *error) {
             <span class="pl-c">//...</span>
         }];</pre></div>

<p>Receiving the notification is handled by the application delegate:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">application</span>(application: UIApplication, <span class="pl-en">didReceiveRemoteNotification</span> <span class="pl-smi">userInfo</span>: [NSObject <span class="pl-k">:</span> <span class="pl-c1">AnyObject</span>]) {
    <span class="pl-k">let</span> ckNotification <span class="pl-k">=</span> CKNotification(fromRemoteNotificationDictionary: userInfo <span class="pl-k">as!</span> [<span class="pl-c1">String</span> <span class="pl-k">:</span> NSObject])
    <span class="pl-k">if</span> ckNotification<span class="pl-k">.</span>notificationType <span class="pl-k">==</span> <span class="pl-k">.</span>Query,
        <span class="pl-k">let</span> queryNotification <span class="pl-k">=</span> ckNotification <span class="pl-k">as?</span> CKQueryNotification
    {
        <span class="pl-k">let</span> recordID <span class="pl-k">=</span> queryNotification<span class="pl-k">.</span>recordID
        <span class="pl-c">//...</span>
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-k">void</span>)application:(UIApplication *)application didReceiveRemoteNotification:(<span class="pl-c1">NSDictionary</span> *)userInfo{
    CKNotification *ckNotification = [CKNotification <span class="pl-c1">notificationFromRemoteNotificationDictionary:</span>userInfo];
    <span class="pl-k">if</span> (ckNotification.<span class="pl-smi">notificationType</span> == CKNotificationTypeQuery) {
        CKQueryNotification *queryNotification = ckNotification;
        CKRecordID *recordID = [queryNotification <span class="pl-c1">recordID</span>];
        <span class="pl-c">// ...</span>
    }
}</pre></div>

<h2><a id="user-content-more" class="anchor" href="#more" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>More</h2>

<p>As I said in the beginning, CloudKit can do much more than described in this article. You can allow your users to add pictures to their check-ins. References in CloudKit allow you to get all the related check-ins for certain places. Moreover, CloudKit has an API that allows you to find your users' friends who are also using your application via their address book.</p>

<p>Can't wait to try out CloudKit? It could free you from writing backend code, caring about server pressure, maintaining a large CDN network, renting a server, and more. But wait—what about the price? How much does it cost? The answer is: free. Apple allows using CloudKit for 10 GB of resource storage, 100 MB of data storage, and 2 GB of daily transfer, scaling with your user base up to to 1 petabyte of resources, 10 TB database, and 200 TB transfer.</p>

<blockquote>
<p>Check out the <a href="https://developer.apple.com/icloud/index.html">CloudKit cost calculator</a> at the bottom of the page for detailed free limits and pricing.</p>
</blockquote>

<hr>

<p>As of WWDC 2015, CloudKit is <em>not only</em> available on iOS or OS X. You can now integrate <a href="https://developer.apple.com/library/prerelease/ios/documentation/CloudKitJS/Reference/CloudKitJavaScriptReference/index.html">CloudKit JS</a> with your website to make it possible for iCloud users to enjoy your service in a web browser or use the <a href="https://developer.apple.com/library/prerelease/ios/documentation/DataManagement/Conceptual/CloutKitWebServicesReference/Introduction/Introduction.html">CloudKit web service</a> to communicate with CloudKit servers directly via HTTP request. All this means it's now possible to use CloudKit from any other mobile or desktop platform!</p>

<p>CloudKit is an amazing thing. I can't wait to see the awesome applications you NSHipsters make with it.</p>
</article></div>