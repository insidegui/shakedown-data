<div class="announce instapaper_body md" data-path="2013-03-18-c-storage-classes.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>C Storage Classes</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Objective-C</div></td>

  <td><div>nshipster</div></td>

  <td><div>In C, the scope and lifetime of a variable or function within a program is determined by its storage class. Understanding these storage classes allows us to decipher common incantations found throughout Objective-C</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>n/a</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>It's time, once again, to take a few steps back from the world of Objective-C, and look at some underlying C language features. Hold onto your fedoras, ladies &amp; gents, as we dive into C storage classes in this week's edition of NSHipster.</p>

<hr>

<p>In C, the <em>scope</em> and <em>lifetime</em> of a variable or function within a program is determined by its <em>storage class</em>. Each variable has a <em>lifetime</em>, or the context in which they store their value. Functions, along with variables, also exist within a particular <em>scope</em>, or visibility, which dictates which parts of a program know about and can access them.</p>

<p>There are 4 storage classes in C:</p>

<ul>
<li><code>auto</code></li>
<li><code>register</code></li>
<li><code>static</code></li>
<li><code>extern</code></li>
</ul>

<p>At least a few of these will look familiar to anyone who has done a cursory amount of Objective-C programming. Let's go into more detail with each one:</p>

<h2><a id="user-content-auto" class="anchor" href="#auto" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>auto</code></h2>

<p>There's a good chance you've never seen this keyword in the wild. That's because <code>auto</code> is the default storage class, and therefore doesn't need to be explicitly used often.</p>

<p>Automatic variables have memory automatically allocated when a program enters a block, and released when the program leaves that block. Access to automatic variables is limited to only the block in which they are declared, as well as any nested blocks.</p>

<h2><a id="user-content-register" class="anchor" href="#register" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>register</code></h2>

<p>Most Objective-C programmers probably aren't familiar with <code>register</code> either, as it's just not widely used in the <code>NS</code> world.</p>

<p><code>register</code> behaves just like <code>auto</code>, except that instead of being allocated onto the stack, they are stored in a <a href="http://en.wikipedia.org/wiki/Processor_register">register</a>.</p>

<p>Registers offer faster access than RAM, but because of the complexities of memory management, putting variables in registers does not guarantee a faster programâ€”in fact, it may very well end up slowing down execution by taking up space on the register unnecessarily. As it were, using <code>register</code> is actually just a <em>suggestion</em> to the compiler to store the variable in the register; implementations may choose whether or not to honor this.</p>

<p><code>register</code>'s lack of popularity in Objective-C is instructive: it's probably best not to bother with it, as it's much more likely to cause a headache than speed up your app in any noticeable way.</p>

<h2><a id="user-content-static" class="anchor" href="#static" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>static</code></h2>

<p>Finally, one that everyone's sure to recognize: <code>static</code>.</p>

<p>As a keyword, <code>static</code> gets used in a lot of different, incompatible ways, so it can be confusing to figure out exactly what it means in every instance. When it comes to storage classes, <code>static</code> means one of two things.</p>

<ol>
<li>A <code>static</code> variable inside a method or function retains its value between invocations.</li>
<li>A <code>static</code> variable declared globally can be called by any function or method, so long as those functions appear in the same file as the <code>static</code> variable. The same goes for <code>static</code> functions.</li>
</ol>

<h3><a id="user-content-static-singletons" class="anchor" href="#static-singletons" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Static Singletons</h3>

<p>A common pattern in Objective-C is the <code>static</code> singleton, wherein a statically-declared variable is initialized and returned in either a function or class method. <code>dispatch once</code> is used to guarantee that the variable is initialized <em>exactly</em> once in a thread-safe manner:</p>

<div class="highlight highlight-source-objc"><pre>+ (<span class="pl-k">instancetype</span>)sharedInstance {
  <span class="pl-k">static</span> <span class="pl-c1">id</span> _sharedInstance = <span class="pl-c1">nil</span>;
  <span class="pl-k">static</span> <span class="pl-c1">dispatch_once_t</span> onceToken;
  <span class="pl-c1">dispatch_once</span>(&amp;onceToken, ^{
      _sharedInstance = [[<span class="pl-v">self</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
  });

  <span class="pl-k">return</span> _sharedInstance;
}</pre></div>

<p>The singleton pattern is useful for creating objects that are shared across the entire application, such as an HTTP client or a notification manager, or objects that may be expensive to create, such as formatters.</p>

<h2><a id="user-content-extern" class="anchor" href="#extern" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>extern</code></h2>

<p>Whereas <code>static</code> makes functions and variables globally visible within a particular file, <code>extern</code> makes them visible globally to <em>all files</em>.</p>

<p>Global variables are not a great idea, generally speaking. Having no constraints on how or when state can be mutated is just asking for impossible-to-debug bugs. That said, there are two common and practical uses for <code>extern</code> in Objective-C.</p>

<h3><a id="user-content-global-string-constants" class="anchor" href="#global-string-constants" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Global String Constants</h3>

<p>Any time your application uses a string constant with a non-linguistic value in a public interface, it should declare it as an external string constant. This is especially true of keys in <code>userInfo</code> dictionaries, <code>NSNotification</code> names, and <code>NSError</code> domains.</p>

<p>The pattern is to declare an <code>extern</code> <code>NSString * const</code> in a public header, and define that <code>NSString * const</code> in the implementation:</p>

<h4><a id="user-content-appdelegateh" class="anchor" href="#appdelegateh" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AppDelegate.h</h4>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">extern</span> <span class="pl-c1">NSString</span> * <span class="pl-k">const</span> <span class="pl-c1">kAppErrorDomain</span>;</pre></div>

<h4><a id="user-content-appdelegatem" class="anchor" href="#appdelegatem" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AppDelegate.m</h4>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> * <span class="pl-k">const</span> <span class="pl-c1">kAppErrorDomain</span> = <span class="pl-s"><span class="pl-pds">@"</span>com.example.yourapp.error<span class="pl-pds">"</span></span>;</pre></div>

<p>It doesn't particularly matter what the value of the string is, so long as it's unique. Using a string constant establishes a strict contract, that the constant variable is used instead of the string's literal value itself.</p>

<h3><a id="user-content-public-functions" class="anchor" href="#public-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Public Functions</h3>

<p>Some APIs may wish to expose helper functions publicly. For auxiliary concerns and state-agnostic procedures, functions are a great way to encapsulate these behaviorsâ€”and if they're particularly useful, it may be worth making them available globally.</p>

<p>The pattern follows the same as in the previous example:</p>

<h4><a id="user-content-transactionstatemachineh" class="anchor" href="#transactionstatemachineh" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TransactionStateMachine.h</h4>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-en">NS_ENUM</span>(<span class="pl-c1">NSUInteger</span>, TransactionState) {
    TransactionOpened,
    TransactionPending,
    TransactionClosed,
};

<span class="pl-k">extern</span> <span class="pl-c1">NSString</span> * <span class="pl-en">NSStringFromTransactionState</span>(TransactionState state);</pre></div>

<h4><a id="user-content-transactionstatemachinem" class="anchor" href="#transactionstatemachinem" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TransactionStateMachine.m</h4>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> * <span class="pl-en">NSStringFromTransactionState</span>(TransactionState state) {
  <span class="pl-k">switch</span> (state) {
    <span class="pl-k">case</span> TransactionOpened:
      <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">@"</span>Opened<span class="pl-pds">"</span></span>;
    <span class="pl-k">case</span> TransactionPending:
      <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">@"</span>Pending<span class="pl-pds">"</span></span>;
    <span class="pl-k">case</span> TransactionClosed:
      <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">@"</span>Closed<span class="pl-pds">"</span></span>;
    <span class="pl-k">default</span>:
      <span class="pl-k">return</span> <span class="pl-c1">nil</span>;
  }
}</pre></div>

<hr>

<p>To understand anything is to make sense of its context. What we may see as obvious and self-evident, is all but unknown to someone without our frame of reference. Our inability to truly understand or appreciate the differences in perspective and information between ourselves and others is perhaps our most basic shortcoming.</p>

<p>That is why, in our constructed logical universe of 0's and 1's, we take such care to separate contexts, and structure our assumptions based on these explicit rules. C storage classes are essential to understanding how a program operates. Without them, we are left to develop as one might walk on egg shells. So take heed of these simple rules of engagement and go forth to code with confidence.</p>
</article></div>