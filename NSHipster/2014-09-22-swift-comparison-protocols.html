<div class="announce instapaper_body md" data-path="2014-09-22-swift-comparison-protocols.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Swift Comparison Protocols</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Swift</div></td>

  <td><div>swift</div></td>

  <td><div>Objective-C required us to wax philosophic about the nature of equality and identity. To the relief of any developer less inclined towards handwavy treatises, this is not as much the case for Swift.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.2</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Objective-C required us to <a href="http://nshipster.com/equality/">wax philosophic</a> about the nature of equality and identity. To the relief of any developer less inclined towards handwavy treatises, this is not as much the case for Swift.</p>

<p>In Swift, <code>Equatable</code> is a fundamental type, from which <code>Comparable</code> and <code>Hashable</code> are both derived. Together, these protocols form the central point of comparison throughout the language.</p>

<hr>

<h2><a id="user-content-equatable" class="anchor" href="#equatable" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Equatable</h2>

<p>Values of the <code>Equatable</code> type can be evaluated for equality and inequality. Declaring a type as equatable bestows several useful abilities, notably the ability for values of that type to be found in a containing <code>Array</code>.</p>

<p>For a type to be <code>Equatable</code>, there must exist an implementation of the <code>==</code> operator function, which accepts a matching type:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">==</span>(lhs: <span class="pl-k">Self</span>, rhs: <span class="pl-k">Self</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span></pre></div>

<p>For value types, equality is determined by evaluating the equality of each component property. As an example, consider a <code>Complex</code> type, which takes a generic type <code>T</code>, which conforms to <code>SignedNumberType</code>:</p>

<blockquote>
<p><code>SignedNumberType</code> is a convenient choice for a generic number type, as it inherits from both <code>Comparable</code> (and thus <code>Equatable</code>, as described in the section) and <code>IntegerLiteralConvertible</code>, which <code>Int</code>, <code>Double</code>, and <code>Float</code> all conform to.</p>
</blockquote>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> Complex<span class="pl-k">&lt;</span>T: <span class="pl-c1">SignedNumberType</span><span class="pl-k">&gt;</span> {
    <span class="pl-k">let</span> real: T
    <span class="pl-k">let</span> imaginary: T
}</pre></div>

<p>Since a <a href="http://en.wikipedia.org/wiki/Complex_number">complex number</a> is comprised of a real and imaginary component, two complex numbers are equal if and only if their respective real and imaginary components are equal:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> Complex: <span class="pl-c1">Equatable</span> {}

<span class="pl-c">// MARK: Equatable</span>

<span class="pl-k">func</span> <span class="pl-en">==</span>&lt;T&gt;(lhs: Complex<span class="pl-k">&lt;</span>T<span class="pl-k">&gt;</span>, rhs: Complex<span class="pl-k">&lt;</span>T<span class="pl-k">&gt;</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">return</span> lhs<span class="pl-k">.</span>real <span class="pl-k">==</span> rhs<span class="pl-k">.</span>real <span class="pl-k">&amp;&amp;</span> lhs<span class="pl-k">.</span>imaginary <span class="pl-k">==</span> rhs<span class="pl-k">.</span>imaginary
}</pre></div>

<p>The result:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> a <span class="pl-k">=</span> Complex<span class="pl-k">&lt;</span><span class="pl-c1">Double</span><span class="pl-k">&gt;</span>(real: <span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">0</span>, imaginary: <span class="pl-c1">2</span><span class="pl-k">.</span><span class="pl-c1">0</span>)
<span class="pl-k">let</span> b <span class="pl-k">=</span> Complex<span class="pl-k">&lt;</span><span class="pl-c1">Double</span><span class="pl-k">&gt;</span>(real: <span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">0</span>, imaginary: <span class="pl-c1">2</span><span class="pl-k">.</span><span class="pl-c1">0</span>)

a <span class="pl-k">==</span> b <span class="pl-c">// true</span>
a <span class="pl-k">!=</span> b <span class="pl-c">// false</span></pre></div>

<blockquote>
<p>As described in <a href="http://nshipster.com/swift-default-protocol-implementations/">the article about Swift Default Protocol Implementations</a>, an implementation of <code>!=</code> is automatically derived from the provided <code>==</code> operator by the standard library.</p>
</blockquote>

<p>For reference types, the equality becomes conflated with identity. It makes sense that two <code>Name</code> structs with the same values would be equal, but two <code>Person</code> objects can have the same name, but be different people.</p>

<p>For Objective-C-compatible object types, the <code>==</code> operator is already provided from the <code>isEqual:</code> method:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> ObjCObject: NSObject {}

ObjCObject() <span class="pl-k">==</span> ObjCObject() <span class="pl-c">// false</span></pre></div>

<p>For Swift reference types, equality can be evaluated as an identity check on an <code>ObjectIdentifier</code> constructed with an instance of that type:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> Object: <span class="pl-c1">Equatable</span> {}

<span class="pl-c">// MARK: Equatable</span>

<span class="pl-k">func</span> <span class="pl-en">==</span>(lhs: Object, rhs: Object) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">return</span> <span class="pl-c1">ObjectIdentifier</span>(lhs) <span class="pl-k">==</span> <span class="pl-c1">ObjectIdentifier</span>(rhs)
}

Object() <span class="pl-k">==</span> Object() <span class="pl-c">// false</span></pre></div>

<h2><a id="user-content-comparable" class="anchor" href="#comparable" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparable</h2>

<p>Building on <code>Equatable</code>, the <code>Comparable</code> protocol allows for more specific inequality, distinguishing cases where the left hand value is greater than or less than the right hand value.</p>

<p>Types conforming to the <code>Comparable</code> protocol provide the following operators:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">&lt;=</span>(lhs: <span class="pl-k">Self</span>, rhs: <span class="pl-k">Self</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span>
<span class="pl-k">func</span> <span class="pl-en">&gt;</span>(lhs: <span class="pl-k">Self</span>, rhs: <span class="pl-k">Self</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span>
<span class="pl-k">func</span> <span class="pl-en">&gt;=</span>(lhs: <span class="pl-k">Self</span>, rhs: <span class="pl-k">Self</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span></pre></div>

<p>What's interesting about this list, however, is not so much what is <em>included</em>, but rather what's <em>missing</em>.</p>

<p>The first and perhaps most noticeable omission is <code>==</code>, since <code>&gt;=</code> is a logical disjunction of <code>&gt;</code> and <code>==</code> comparisons. As a way of reconciling this, <code>Comparable</code> inherits from <code>Equatable</code>, which provides <code>==</code>.</p>

<p>The second omission is a bit more subtle, and is actually the key to understanding what's going on here: <code>&lt;</code>. What happened to the "less than" operator? It's defined by the <code>_Comparable</code> protocol. Why is this significant? As described in <a href="http://nshipster.com/swift-default-protocol-implementations/">the article about Swift Default Protocol Implementations</a>, the Swift Standard Library provides a default implementation of the <code>Comparable</code> protocol based entirely on the existential type <code>_Comparable</code>. This is actually <em>really</em> clever. Since the implementations of all of the comparison functions can be derived from just <code>&lt;</code> and <code>==</code>, all of that functionality is made available automatically through type inference.</p>

<blockquote>
<p>Contrast this with, for example, how Ruby derives equality and comparison operators from a single operator, <code>&lt;=&gt;</code> (a.k.a the "UFO operator"). <a href="https://gist.github.com/mattt/7e4db72ce1b6c8a18bb4">Here's how this could be implemented in Swift</a>.</p>
</blockquote>

<p>As a more complex example, consider a <code>CSSSelector</code> struct, which implements <a href="http://www.w3.org/TR/CSS2/cascade.html#cascading-order">cascade ordering</a> of selectors:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">import</span> <span class="pl-c1">Foundation</span>

<span class="pl-k">struct</span> CSSSelector {
    <span class="pl-k">let</span> selector: <span class="pl-c1">String</span>

    <span class="pl-k">struct</span> Specificity {
        <span class="pl-k">let</span> id: <span class="pl-c1">Int</span>
        <span class="pl-k">let</span> `<span class="pl-k">class</span>`: <span class="pl-c1">Int</span>
        <span class="pl-k">let</span> element: <span class="pl-c1">Int</span>

        <span class="pl-k">init</span>(_ components: [<span class="pl-c1">String</span>]) {
            <span class="pl-k">var</span> (id, `<span class="pl-k">class</span>`, element) <span class="pl-k">=</span> (<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>)
            <span class="pl-k">for</span> token <span class="pl-k">in</span> components {
                <span class="pl-k">if</span> token<span class="pl-k">.</span><span class="pl-c1">hasPrefix</span>(<span class="pl-s"><span class="pl-pds">"</span>#<span class="pl-pds">"</span></span>) {
                    id<span class="pl-k">++</span>
                } <span class="pl-k">else</span> <span class="pl-k">if</span> token<span class="pl-k">.</span><span class="pl-c1">hasPrefix</span>(<span class="pl-s"><span class="pl-pds">"</span>.<span class="pl-pds">"</span></span>) {
                    `<span class="pl-k">class</span>`<span class="pl-k">++</span>
                } <span class="pl-k">else</span> {
                    element<span class="pl-k">++</span>
                }
            }

            <span class="pl-k">self</span><span class="pl-k">.</span>id <span class="pl-k">=</span> id
            <span class="pl-k">self</span><span class="pl-k">.</span>`<span class="pl-k">class</span>` <span class="pl-k">=</span> `<span class="pl-k">class</span>`
            <span class="pl-k">self</span><span class="pl-k">.</span>element <span class="pl-k">=</span> element
        }
    }

    <span class="pl-k">let</span> specificity: Specificity

    <span class="pl-k">init</span>(_ string: <span class="pl-c1">String</span>) {
        <span class="pl-k">self</span><span class="pl-k">.</span>selector <span class="pl-k">=</span> string

        <span class="pl-c">// Naïve tokenization, ignoring operators, pseudo-selectors, and `style=`.</span>
        <span class="pl-k">let</span> components: [<span class="pl-c1">String</span>] <span class="pl-k">=</span> <span class="pl-k">self</span><span class="pl-k">.</span>selector<span class="pl-k">.</span>componentsSeparatedByCharactersInSet(NSCharacterSet<span class="pl-k">.</span>whitespaceCharacterSet())
        <span class="pl-k">self</span><span class="pl-k">.</span>specificity <span class="pl-k">=</span> Specificity(components)
    }
}</pre></div>

<p>Where as CSS selectors are evaluated by specificity rank and order, two selectors are only really equal if they resolve to the same elements:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> CSSSelector: <span class="pl-c1">Equatable</span> {}

<span class="pl-c">// MARK: Equatable</span>

<span class="pl-k">func</span> <span class="pl-en">==</span>(lhs: CSSSelector, rhs: CSSSelector) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-c">// Naïve equality that uses string comparison rather than resolving equivalent selectors</span>
    <span class="pl-k">return</span> lhs<span class="pl-k">.</span>selector <span class="pl-k">==</span> rhs<span class="pl-k">.</span>selector
}</pre></div>

<p>Instead, selectors are actually compared in terms of their specificity:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> CSSSelector<span class="pl-k">.</span>Specificity: <span class="pl-c1">Comparable</span> {}

<span class="pl-c">// MARK: Comparable</span>

<span class="pl-k">func</span> <span class="pl-en">&lt;</span>(lhs: CSSSelector<span class="pl-k">.</span>Specificity, rhs: CSSSelector<span class="pl-k">.</span>Specificity) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">return</span> lhs<span class="pl-k">.</span>id <span class="pl-k">&lt;</span> rhs<span class="pl-k">.</span>id <span class="pl-k">||</span>
        (lhs<span class="pl-k">.</span>id <span class="pl-k">==</span> rhs<span class="pl-k">.</span>id <span class="pl-k">&amp;&amp;</span> lhs<span class="pl-k">.</span>`<span class="pl-k">class</span>` <span class="pl-k">&lt;</span> rhs<span class="pl-k">.</span>`<span class="pl-k">class</span>`) <span class="pl-k">||</span>
        (lhs<span class="pl-k">.</span>id <span class="pl-k">==</span> rhs<span class="pl-k">.</span>id <span class="pl-k">&amp;&amp;</span> lhs<span class="pl-k">.</span>`<span class="pl-k">class</span>` <span class="pl-k">==</span> rhs<span class="pl-k">.</span>`<span class="pl-k">class</span>` <span class="pl-k">&amp;&amp;</span> lhs<span class="pl-k">.</span>element <span class="pl-k">&lt;</span> rhs<span class="pl-k">.</span>element)
}

<span class="pl-c">// MARK: Equatable</span>

<span class="pl-k">func</span> <span class="pl-en">==</span>(lhs: CSSSelector<span class="pl-k">.</span>Specificity, rhs: CSSSelector<span class="pl-k">.</span>Specificity) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">return</span> lhs<span class="pl-k">.</span>id <span class="pl-k">==</span> rhs<span class="pl-k">.</span>id <span class="pl-k">&amp;&amp;</span>
           lhs<span class="pl-k">.</span>`<span class="pl-k">class</span>` <span class="pl-k">==</span> rhs<span class="pl-k">.</span>`<span class="pl-k">class</span>` <span class="pl-k">&amp;&amp;</span>
           lhs<span class="pl-k">.</span>element <span class="pl-k">==</span> rhs<span class="pl-k">.</span>element
}</pre></div>

<p>Bringing everything together:</p>

<blockquote>
<p>For clarity, assume <code>CSSSelector</code> <a href="http://nshipster.com/swift-literal-convertible/">conforms to <code>StringLiteralConvertible</code></a>.</p>
</blockquote>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> a: CSSSelector <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>#logo<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> b: CSSSelector <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>html body #logo<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> c: CSSSelector <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>body div #logo<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> d: CSSSelector <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>.container #logo<span class="pl-pds">"</span></span>

b <span class="pl-k">==</span> c <span class="pl-c">// false</span>
b<span class="pl-k">.</span>specificity <span class="pl-k">==</span> c<span class="pl-k">.</span>specificity <span class="pl-c">// true</span>
c<span class="pl-k">.</span>specificity <span class="pl-k">&lt;</span> a<span class="pl-k">.</span>specificity <span class="pl-c">// false</span>
d<span class="pl-k">.</span>specificity <span class="pl-k">&gt;</span> c<span class="pl-k">.</span>specificity <span class="pl-c">// true</span></pre></div>

<h2><a id="user-content-hashable" class="anchor" href="#hashable" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hashable</h2>

<p>Another important protocol derived from <code>Equatable</code> is <code>Hashable</code>.</p>

<p>Only <code>Hashable</code> types can be stored as the key of a Swift <code>Dictionary</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> <span class="pl-c1">Dictionary</span><span class="pl-k">&lt;</span>Key <span class="pl-k">:</span> <span class="pl-c1">Hashable</span>, Value<span class="pl-k">&gt;</span> <span class="pl-k">:</span> <span class="pl-c1">CollectionType</span>, <span class="pl-c1">DictionaryLiteralConvertible</span> { <span class="pl-k">...</span> }</pre></div>

<p>For a type to conform to <code>Hashable</code>, it must provide a getter for the <code>hashValue</code> property.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">protocol</span> <span class="pl-c1">Hashable</span> <span class="pl-k">:</span> <span class="pl-c1">Equatable</span> {
    <span class="pl-c">/// Returns the hash value.  The hash value is not guaranteed to be stable</span>
    <span class="pl-c">/// across different invocations of the same program.  Do not persist the hash</span>
    <span class="pl-c">/// value across program runs.</span>
    <span class="pl-c">///</span>
    <span class="pl-c">/// The value of `hashValue` property must be consistent with the equality</span>
    <span class="pl-c">/// comparison: if two values compare equal, they must have equal hash</span>
    <span class="pl-c">/// values.</span>
    <span class="pl-k">var</span> hashValue: <span class="pl-c1">Int</span> { <span class="pl-k">get</span> }
}</pre></div>

<p>Determining the <a href="http://en.wikipedia.org/wiki/Perfect_hash_function">optimal hashing value</a> is way outside the scope of this article. Fortunately, most values can derive an adequate hash value from an <code>XOR</code> of the hash values of its component properties.</p>

<p>The following built-in Swift types implement <code>hashValue</code>:</p>

<ul>
<li><code>Double</code></li>
<li><code>Float</code>, <code>Float80</code></li>
<li><code>Int</code>, <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code></li>
<li><code>UInt</code>, <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code></li>
<li><code>String</code></li>
<li><code>UnicodeScalar</code></li>
<li><code>ObjectIdentifier</code></li>
</ul>

<p>Based on this, here's how a struct representing <a href="http://en.wikipedia.org/wiki/Binomial_nomenclature">Binomial Nomenclature in Biological Taxonomy</a>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> Binomen {
    <span class="pl-k">let</span> genus: <span class="pl-c1">String</span>
    <span class="pl-k">let</span> species: <span class="pl-c1">String</span>
}

<span class="pl-c">// MARK: Hashable</span>

<span class="pl-k">extension</span> Binomen: <span class="pl-c1">Hashable</span> {
    <span class="pl-k">var</span> hashValue: <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> genus<span class="pl-k">.</span><span class="pl-c1">hashValue</span> <span class="pl-k">^</span> species<span class="pl-k">.</span><span class="pl-c1">hashValue</span>
    }
}

<span class="pl-c">// MARK: Equatable</span>

<span class="pl-k">func</span> <span class="pl-en">==</span>(lhs: Binomen, rhs: Binomen) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">return</span> lhs<span class="pl-k">.</span>genus <span class="pl-k">==</span> rhs<span class="pl-k">.</span>genus <span class="pl-k">&amp;&amp;</span> lhs<span class="pl-k">.</span>species <span class="pl-k">==</span> rhs<span class="pl-k">.</span>species
}</pre></div>

<p>Being able to hash this type makes it possible to key common name to the "Latin name":</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> commonNames: [Binomen: <span class="pl-c1">String</span>] <span class="pl-k">=</span> [<span class="pl-k">:</span>]
commonNames[Binomen(genus: <span class="pl-s"><span class="pl-pds">"</span>Canis<span class="pl-pds">"</span></span>, species: <span class="pl-s"><span class="pl-pds">"</span>lupis<span class="pl-pds">"</span></span>)] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Grey Wolf<span class="pl-pds">"</span></span>
commonNames[Binomen(genus: <span class="pl-s"><span class="pl-pds">"</span>Canis<span class="pl-pds">"</span></span>, species: <span class="pl-s"><span class="pl-pds">"</span>rufus<span class="pl-pds">"</span></span>)] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Red Wolf<span class="pl-pds">"</span></span>
commonNames[Binomen(genus: <span class="pl-s"><span class="pl-pds">"</span>Canis<span class="pl-pds">"</span></span>, species: <span class="pl-s"><span class="pl-pds">"</span>latrans<span class="pl-pds">"</span></span>)] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Coyote<span class="pl-pds">"</span></span>
commonNames[Binomen(genus: <span class="pl-s"><span class="pl-pds">"</span>Canis<span class="pl-pds">"</span></span>, species: <span class="pl-s"><span class="pl-pds">"</span>aureus<span class="pl-pds">"</span></span>)] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Golden Jackal<span class="pl-pds">"</span></span></pre></div>
</article></div>