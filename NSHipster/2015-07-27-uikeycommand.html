<div class="announce instapaper_body md" data-path="2015-07-27-uikeycommand.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>UIKeyCommand</div></td>

  <td><div>Nate Cook</div></td>

  <td><div>Cocoa</div></td>

  <td><div>As part of the push for greater productivity on the iPad, iOS 9 adds *Discoverability*, an overlay showing the currently available key commands inside an app. This small change suddenly makes key commands far more viable on the iPad and, with it, makes `UIKeyCommand` a necessary addition to your app.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Adding a new feature to a product is always a tradeoff. Will the added utility of a new feature be enough to offset the added complexity? Shortcuts would seem to side-step this issue—after all, they're simply a quicker alternative for features already in your app. But that creates another dilemma: what if a new feature is added and no one knows it's there?</p>

<p>When key commands for external keyboards debuted in iOS 7, there was no intrinsic way to learn of their existence. Unlike in OS X, where a user can gradually discover shortcuts for the menu items they use most often, an iOS app had few ways to communicate what key commands are available. Initial tours flash by and fade from memory; help screens are hidden out of sight. Without a way to make shortcuts visible in a timely and relevant manner, users were sure to miss out on useful features that developers had taken the time to implement.</p>

<p>No longer. As part of the push for greater productivity on the iPad, iOS 9 adds <em>Discoverability</em>, an overlay showing the currently available key commands inside an app. This small change suddenly makes key commands far more viable on the iPad and, with it, makes <code>UIKeyCommand</code> a necessary addition to your app.</p>

<hr>

<h2><a id="user-content-uikeycommand" class="anchor" href="#uikeycommand" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>UIKeyCommand</code></h2>

<p>The <code>UIKeyCommand</code> class is in fact quite simple, with only four properties to configure:</p>

<ul>
<li><p><code>input</code>: The character of the key you'd like to recognize, or the correct constant for the arrow and escape keys, which do not have characters themselves. The available constants are:</p>

<ul>
<li><code>UIKeyInputUpArrow</code></li>
<li><code>UIKeyInputDownArrow</code></li>
<li><code>UIKeyInputLeftArrow</code></li>
<li><code>UIKeyInputRightArrow</code></li>
<li><code>UIKeyInputEscape</code></li>
</ul></li>
<li><p><code>modifierFlags</code>: One or more <code>UIKeyModifierFlags</code>, describing the modifier keys that should be pressed in combination with <code>input</code>:</p>

<ul>
<li><code>.Command</code>, <code>.Alternate</code>, <code>.Shift</code>, <code>.Control</code>: The Command, Option, Shift, and Control keys, respectively.</li>
<li><code>.NumericPad</code>: Indicates that <code>input</code> should come from the numeric keypad rather than the top row of the standard keyboard.</li>
<li><code>.AlphaShift</code>: Indicates that the CapsLock key should be <em>pressed</em> as part of the combination, rather than just engaged.</li>
</ul></li>
<li><p><code>action</code>: The selector to call when the key command is invoked, called with a <code>UIKeyCommand</code> as its only argument. The key event will travel up the responder chain until a matching selector is found.</p></li>
<li><p><code>discoverabilityTitle</code> <em>(iOS 9 only)</em>: An optional label to display for the key command in the Discoverability layover. Only key commands with a title set will be listed.</p></li>
</ul>

<h2><a id="user-content-responding-to-key-commands" class="anchor" href="#responding-to-key-commands" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Responding to Key Commands</h2>

<p>Enabling key commands is as simple as providing an array of <code>UIKeyCommand</code> instances somewhere in the responder chain. Text inputs are automatically first responders, but perhaps more usefully, a view controller can respond to key commands by implementing <code>canBecomeFirstResponder()</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">canBecomeFirstResponder</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
    <span class="pl-k">return</span> <span class="pl-c1">true</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">BOOL</span>)canBecomeFirstResponder {
    <span class="pl-k">return</span> <span class="pl-c1">YES</span>;
}</pre></div>

<p>Next, provide a list of available key commands via the <code>keyCommands</code> property:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">override</span> <span class="pl-k">var</span> keyCommands: [UIKeyCommand]? {
    <span class="pl-k">return</span> [
        UIKeyCommand(input: <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, modifierFlags: <span class="pl-k">.</span>Command, action: <span class="pl-s"><span class="pl-pds">"</span>selectTab:<span class="pl-pds">"</span></span>, discoverabilityTitle: <span class="pl-s"><span class="pl-pds">"</span>Types<span class="pl-pds">"</span></span>),
        UIKeyCommand(input: <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>, modifierFlags: <span class="pl-k">.</span>Command, action: <span class="pl-s"><span class="pl-pds">"</span>selectTab:<span class="pl-pds">"</span></span>, discoverabilityTitle: <span class="pl-s"><span class="pl-pds">"</span>Protocols<span class="pl-pds">"</span></span>),
        UIKeyCommand(input: <span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>, modifierFlags: <span class="pl-k">.</span>Command, action: <span class="pl-s"><span class="pl-pds">"</span>selectTab:<span class="pl-pds">"</span></span>, discoverabilityTitle: <span class="pl-s"><span class="pl-pds">"</span>Functions<span class="pl-pds">"</span></span>),
        UIKeyCommand(input: <span class="pl-s"><span class="pl-pds">"</span>4<span class="pl-pds">"</span></span>, modifierFlags: <span class="pl-k">.</span>Command, action: <span class="pl-s"><span class="pl-pds">"</span>selectTab:<span class="pl-pds">"</span></span>, discoverabilityTitle: <span class="pl-s"><span class="pl-pds">"</span>Operators<span class="pl-pds">"</span></span>),

        UIKeyCommand(input: <span class="pl-s"><span class="pl-pds">"</span>f<span class="pl-pds">"</span></span>, modifierFlags: [<span class="pl-k">.</span>Command, <span class="pl-k">.</span>Alternate], action: <span class="pl-s"><span class="pl-pds">"</span>search:<span class="pl-pds">"</span></span>, discoverabilityTitle: <span class="pl-s"><span class="pl-pds">"</span>Find…<span class="pl-pds">"</span></span>),
    ]
}

<span class="pl-c">// ...</span>

<span class="pl-k">func</span> <span class="pl-en">selectTab</span>(sender: UIKeyCommand) {
    <span class="pl-k">let</span> selectedTab <span class="pl-k">=</span> sender<span class="pl-k">.</span>input
    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">NSArray</span>&lt;UIKeyCommand *&gt;*)keyCommands {
    <span class="pl-k">return</span> @[
        [UIKeyCommand <span class="pl-c1">keyCommandWithInput:</span><span class="pl-s"><span class="pl-pds">@"</span>1<span class="pl-pds">"</span></span> <span class="pl-c1">modifierFlags:</span>UIKeyModifierCommand <span class="pl-c1">action:</span><span class="pl-k">@selector</span>(<span class="pl-c1">selectTab:</span>) <span class="pl-c1">discoverabilityTitle:</span><span class="pl-s"><span class="pl-pds">@"</span>Types<span class="pl-pds">"</span></span>],
        [UIKeyCommand <span class="pl-c1">keyCommandWithInput:</span><span class="pl-s"><span class="pl-pds">@"</span>2<span class="pl-pds">"</span></span> <span class="pl-c1">modifierFlags:</span>UIKeyModifierCommand <span class="pl-c1">action:</span><span class="pl-k">@selector</span>(<span class="pl-c1">selectTab:</span>) <span class="pl-c1">discoverabilityTitle:</span><span class="pl-s"><span class="pl-pds">@"</span>Protocols<span class="pl-pds">"</span></span>],
        [UIKeyCommand <span class="pl-c1">keyCommandWithInput:</span><span class="pl-s"><span class="pl-pds">@"</span>3<span class="pl-pds">"</span></span> <span class="pl-c1">modifierFlags:</span>UIKeyModifierCommand <span class="pl-c1">action:</span><span class="pl-k">@selector</span>(<span class="pl-c1">selectTab:</span>) <span class="pl-c1">discoverabilityTitle:</span><span class="pl-s"><span class="pl-pds">@"</span>Functions<span class="pl-pds">"</span></span>],
        [UIKeyCommand <span class="pl-c1">keyCommandWithInput:</span><span class="pl-s"><span class="pl-pds">@"</span>4<span class="pl-pds">"</span></span> <span class="pl-c1">modifierFlags:</span>UIKeyModifierCommand <span class="pl-c1">action:</span><span class="pl-k">@selector</span>(<span class="pl-c1">selectTab:</span>) <span class="pl-c1">discoverabilityTitle:</span><span class="pl-s"><span class="pl-pds">@"</span>Operators<span class="pl-pds">"</span></span>],

        [UIKeyCommand <span class="pl-c1">keyCommandWithInput:</span><span class="pl-s"><span class="pl-pds">@"</span>f<span class="pl-pds">"</span></span> 
                            <span class="pl-c1">modifierFlags:</span>UIKeyModifierCommand | UIKeyModifierAlternate 
                                   <span class="pl-c1">action:</span><span class="pl-k">@selector</span>(<span class="pl-c1">search:</span>) 
                     <span class="pl-c1">discoverabilityTitle:</span><span class="pl-s"><span class="pl-pds">@"</span>Find…<span class="pl-pds">"</span></span>]
    ];
}

<span class="pl-c">// ...</span>

- (<span class="pl-k">void</span>)selectTab:(UIKeyCommand *)sender {
    <span class="pl-c1">NSString</span> *selectedTab = sender.<span class="pl-smi">input</span>;
    <span class="pl-c">// ...</span>
}</pre></div>

<p>In the Discoverability layover, accessed by holding down the Command key, key commands are listed in the order you specified:</p>

<p><a href="%7B%7B%20site.asseturl%20%7D%7D/uikeycommand-discoverability.png" target="_blank"><img src="%7B%7B%20site.asseturl%20%7D%7D/uikeycommand-discoverability.png" alt="Discoverability Layover" style="max-width:100%;"></a></p>

<p><em>Voila!</em> Secrets, revealed!</p>

<h3><a id="user-content-context-sensitivity" class="anchor" href="#context-sensitivity" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Context Sensitivity</h3>

<p>The <code>keyCommands</code> property is accessed whenever a key is pressed, making it possible to provide context-sensitive responses depending on the state of your application. While this is similar to the way a menu item and its active/inactive state are configured in OS X, the recommendation for iOS is to omit inactive commands completely—that is, there are no grayed out commands in the Discoverability layover.</p>

<p>Here, a set of commands that are available to logged in users of an app are included only when appropriate:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> globalKeyCommands <span class="pl-k">=</span> [UIKeyCommand(input:<span class="pl-k">...</span>), <span class="pl-k">...</span>]
<span class="pl-k">let</span> loggedInUserKeyCommands <span class="pl-k">=</span> [UIKeyCommand(input:<span class="pl-k">...</span>), <span class="pl-k">...</span>]

<span class="pl-k">override</span> <span class="pl-k">var</span> keyCommands: [UIKeyCommand]? {
    <span class="pl-k">if</span> isLoggedInUser() {
        <span class="pl-k">return</span> globalKeyCommands <span class="pl-k">+</span> loggedInUserKeyCommands
    } <span class="pl-k">else</span> {
        <span class="pl-k">return</span> globalKeyCommands
    }
}</pre></div>

<hr>

<p>Although we don't take shortcuts when creating our apps, that doesn't mean our users won't find shortcuts useful. Adding key commands lets control of your app shift from the screen to the keyboard—your users will love the option.</p>
</article></div>