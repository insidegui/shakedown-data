<div class="announce instapaper_body md" data-path="2015-10-05-guard-and-defer.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>guard &amp; defer</div></td>

  <td><div>Nate Cook</div></td>

  <td><div>Swift</div></td>

  <td><div>Recently, Swift 2.0 introduced two new control statements that aim to simplify and streamline the programs we write: `guard` and `defer`. While the first by its nature makes our code more linear, the other defers execution of its contents. How should we approach these new control statements? How can `guard` and `defer` help us clarify the correspondence between the program and the process?</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<blockquote>
<p>"We should do (as wise programmers aware of our limitations) our utmost best to … make the correspondence between the program (spread out in text space) and the process (spread out in time) as trivial as possible."</p>

<p>—<a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger W. Dijkstra</a>, "Go To Considered Harmful"</p>
</blockquote>

<p>Recently, Swift 2.0 introduced two new control statements that aim to simplify and streamline the programs we write: <code>guard</code> and <code>defer</code>. While the first by its nature makes our code more linear, the other defers execution of its contents. How should we approach these new control statements? How can <code>guard</code> and <code>defer</code> help us clarify the correspondence between the program and the process?</p>

<p>Let's defer <code>defer</code> and first take on <code>guard</code>.</p>

<hr>

<h2><a id="user-content-guard" class="anchor" href="#guard" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>guard</h2>

<p>If the multiple optional bindings syntax introduced in <a href="/swift-1.2/">Swift 1.2</a> heralded a renovation of the <a href="http://www.scottlogic.com/blog/2014/12/08/swift-optional-pyramids-of-doom.html">pyramid of doom</a>, <code>guard</code> statements tear it down altogether.</p>

<p><code>guard</code> is a new conditional statement that requires execution to exit the current block if the condition isn't met. Any new optional bindings created in a <code>guard</code> statement's condition are available for the rest of the function or block, and the mandatory <code>else</code> must exit the current scope, by using <code>return</code> to leave a function, <code>continue</code> or <code>break</code> within a loop, or a <code>@noreturn</code> function like <code>fatalError()</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">for</span> imageName <span class="pl-k">in</span> imageNamesList {
    <span class="pl-k">guard</span> <span class="pl-k">let</span> image <span class="pl-k">=</span> UIImage(named: imageName) 
        <span class="pl-k">else</span> { <span class="pl-k">continue</span> }

    <span class="pl-c">// do something with image</span>
}</pre></div>

<p>Let's take a before-and-after look at how <code>guard</code> can improve our code and help prevent errors. As an example, we'll build a new string-to-<code>UInt8</code> initializer. <code>UInt8</code> already declares a failable initializer that takes a <code>String</code>, but if the conversion fails we don't learn the reason—was the format invalid or was the value out of bounds for the numeric type? Our new initializer throws a <code>ConversionError</code> that provides more information.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">enum</span> ConversionError <span class="pl-k">:</span> <span class="pl-c1">ErrorType</span> {
    <span class="pl-k">case</span> InvalidFormat, OutOfBounds, Unknown
}

<span class="pl-k">extension</span> <span class="pl-c1">UInt8</span> {
    <span class="pl-k">init</span>(fromString string: <span class="pl-c1">String</span>) <span class="pl-k">throws</span> {
        <span class="pl-c">// check the string's format</span>
        <span class="pl-k">if</span> <span class="pl-k">let</span> _ <span class="pl-k">=</span> string<span class="pl-k">.</span>rangeOfString(<span class="pl-s"><span class="pl-pds">"</span>^<span class="pl-cce">\\</span>d+$<span class="pl-pds">"</span></span>, options: [<span class="pl-k">.</span>RegularExpressionSearch]) {

            <span class="pl-c">// make sure the value is in bounds</span>
            <span class="pl-k">if</span> string<span class="pl-k">.</span>compare(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1"><span class="pl-c1">UInt8</span><span class="pl-k">.</span><span class="pl-c1">max</span></span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>, options: [<span class="pl-k">.</span>NumericSearch]) <span class="pl-k">!=</span> NSComparisonResult<span class="pl-k">.</span>OrderedAscending {
                <span class="pl-k">throw</span> ConversionError<span class="pl-k">.</span>OutOfBounds
            }

            <span class="pl-c">// do the built-in conversion</span>
            <span class="pl-k">if</span> <span class="pl-k">let</span> value <span class="pl-k">=</span> <span class="pl-c1">UInt8</span>(string) {
                <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-k">init</span>(value)
            } <span class="pl-k">else</span> {
                <span class="pl-k">throw</span> ConversionError<span class="pl-k">.</span>Unknown
            }
        }

        <span class="pl-k">throw</span> ConversionError<span class="pl-k">.</span>InvalidFormat
    }
}</pre></div>

<p>Note how far apart the format check and the invalid format <code>throw</code> are in this example. Not ideal. Moreover, the actual initialization happens two levels deep, inside a nested <code>if</code> statement. And if that isn't enough, there's a bug in the logic of this initializer that isn't immediately apparent. Can you spot the flaw? What's really going to bake your noodle later on is, would you still have noticed it if I hadn't said anything?</p>

<p>Next, let's take a look at how using <code>guard</code> transforms this initializer:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> <span class="pl-c1">UInt8</span> {
    <span class="pl-k">init</span>(fromString string: <span class="pl-c1">String</span>) <span class="pl-k">throws</span> {
        <span class="pl-c">// check the string's format</span>
        <span class="pl-k">guard</span> <span class="pl-k">let</span> _ <span class="pl-k">=</span> string<span class="pl-k">.</span>rangeOfString(<span class="pl-s"><span class="pl-pds">"</span>^<span class="pl-cce">\\</span>d+$<span class="pl-pds">"</span></span>, options: [<span class="pl-k">.</span>RegularExpressionSearch]) 
            <span class="pl-k">else</span> { <span class="pl-k">throw</span> ConversionError<span class="pl-k">.</span>InvalidFormat }

        <span class="pl-c">// make sure the value is in bounds</span>
        <span class="pl-k">guard</span> string<span class="pl-k">.</span>compare(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1"><span class="pl-c1">UInt8</span><span class="pl-k">.</span><span class="pl-c1">max</span></span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>, options: [<span class="pl-k">.</span>NumericSearch]) <span class="pl-k">!=</span> NSComparisonResult<span class="pl-k">.</span>OrderedDescending 
            <span class="pl-k">else</span> { <span class="pl-k">throw</span> ConversionError<span class="pl-k">.</span>OutOfBounds }

        <span class="pl-c">// do the built-in conversion</span>
        <span class="pl-k">guard</span> <span class="pl-k">let</span> value <span class="pl-k">=</span> <span class="pl-c1">UInt</span>(string) 
            <span class="pl-k">else</span> { <span class="pl-k">throw</span> ConversionError<span class="pl-k">.</span>Unknown }

        <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-k">init</span>(value)
    }
}</pre></div>

<p>Much better. Each error case is handled as soon as it has been checked, so we can follow the flow of execution straight down the left-hand side. </p>

<p>Even more importantly, using <code>guard</code> prevents the logic flaw in our first attempt: that final <code>throw</code> is called every time because it isn't enclosed in an <code>else</code> statement. With <code>guard</code>, the compiler forces us to break scope inside the else-block, guaranteeing the execution of that particular <code>throw</code> only at the right times.</p>

<p>Also note that the middle <code>guard</code> statement isn't strictly necessary. Since it doesn't unwrap an optional value, an <code>if</code> statement would work perfectly well. Using <code>guard</code> in this case simply provides an extra layer of safety—the compiler ensures that you leave the initializer if the test fails, leaving no way to accidentally comment out the <code>throw</code> or introduce another error that would lose part of the initializer's logic.</p>

<h2><a id="user-content-defer" class="anchor" href="#defer" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>defer</h2>

<p>Between <code>guard</code> and the new <code>throw</code> statement for error handling, Swift 2.0 certainly seems to be encouraging a style of early return (an NSHipster favorite) rather than nested <code>if</code> statements. Returning early poses a distinct challenge, however, when resources that have been initialized (and may still be in use) must be cleaned up before returning.</p>

<p>The new <code>defer</code> keyword provides a safe and easy way to handle this challenge by declaring a block that will be executed only when execution leaves the current scope. Consider this snippet of a function working with <code>vImage</code> from the Accelerate framework, taken from the newly-updated article on <a href="/image-resizing/">image resizing</a>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">resizeImage</span>(url: NSURL) <span class="pl-k">-&gt;</span> UIImage? {
    <span class="pl-c">// ...</span>
    <span class="pl-k">let</span> dataSize: <span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-k">...</span>
    <span class="pl-k">let</span> destData <span class="pl-k">=</span> <span class="pl-c1">UnsafeMutablePointer</span><span class="pl-k">&lt;</span><span class="pl-c1">UInt8</span><span class="pl-k">&gt;.</span>alloc(dataSize)
    <span class="pl-k">var</span> destBuffer <span class="pl-k">=</span> vImage_Buffer(data: destData, <span class="pl-k">...</span>)

    <span class="pl-c">// scale the image from sourceBuffer to destBuffer</span>
    <span class="pl-k">var</span> error <span class="pl-k">=</span> vImageScale_ARGB8888(<span class="pl-k">&amp;</span>sourceBuffer, <span class="pl-k">&amp;</span>destBuffer, <span class="pl-k">...</span>)
    <span class="pl-k">guard</span> error <span class="pl-k">==</span> kvImageNoError
        <span class="pl-k">else</span> {
            destData<span class="pl-k">.</span><span class="pl-c1">dealloc</span>(dataSize)  <span class="pl-c">// 1</span>
            <span class="pl-k">return</span> <span class="pl-c1">nil</span>
        }

    <span class="pl-c">// create a CGImage from the destBuffer</span>
    <span class="pl-k">guard</span> <span class="pl-k">let</span> destCGImage <span class="pl-k">=</span> vImageCreateCGImageFromBuffer(<span class="pl-k">&amp;</span>destBuffer, <span class="pl-k">&amp;</span>format, <span class="pl-k">...</span>) 
        <span class="pl-k">else</span> {
            destData<span class="pl-k">.</span><span class="pl-c1">dealloc</span>(dataSize)  <span class="pl-c">// 2</span>
            <span class="pl-k">return</span> <span class="pl-c1">nil</span>
        }
    destData<span class="pl-k">.</span><span class="pl-c1">dealloc</span>(dataSize)          <span class="pl-c">// 3</span>
    <span class="pl-c">// ...</span>
}</pre></div>

<p>Here an <code>UnsafeMutablePointer&lt;UInt8&gt;</code> is allocated for the destination data early on, but we need to remember to deallocate at both failure points <em>and</em> once we no longer need the pointer.</p>

<p>Error prone? Yes. Frustratingly repetitive? Check.</p>

<p>A <code>defer</code> statement removes any chance of forgetting to clean up after ourselves while also simplifying our code. Even though the <code>defer</code> block comes immediately after the call to <code>alloc()</code>, its execution is delayed until the end of the current scope:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">resizeImage</span>(url: NSURL) <span class="pl-k">-&gt;</span> UIImage? {
    <span class="pl-c">// ...</span>
    <span class="pl-k">let</span> dataSize: <span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-k">...</span>
    <span class="pl-k">let</span> destData <span class="pl-k">=</span> <span class="pl-c1">UnsafeMutablePointer</span><span class="pl-k">&lt;</span><span class="pl-c1">UInt8</span><span class="pl-k">&gt;.</span>alloc(dataSize)
    <span class="pl-k">defer</span> {
        destData<span class="pl-k">.</span><span class="pl-c1">dealloc</span>(dataSize)
    }

    <span class="pl-k">var</span> destBuffer <span class="pl-k">=</span> vImage_Buffer(data: destData, <span class="pl-k">...</span>)

    <span class="pl-c">// scale the image from sourceBuffer to destBuffer</span>
    <span class="pl-k">var</span> error <span class="pl-k">=</span> vImageScale_ARGB8888(<span class="pl-k">&amp;</span>sourceBuffer, <span class="pl-k">&amp;</span>destBuffer, <span class="pl-k">...</span>)
    <span class="pl-k">guard</span> error <span class="pl-k">==</span> kvImageNoError 
        <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }

    <span class="pl-c">// create a CGImage from the destBuffer</span>
    <span class="pl-k">guard</span> <span class="pl-k">let</span> destCGImage <span class="pl-k">=</span> vImageCreateCGImageFromBuffer(<span class="pl-k">&amp;</span>destBuffer, <span class="pl-k">&amp;</span>format, <span class="pl-k">...</span>) 
        <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }
    <span class="pl-c">// ...</span>
}</pre></div>

<p>Thanks to <code>defer</code>, <code>destData</code> will be properly deallocated no matter which exit point is used to return from the function.</p>

<p>Safe and clean. Swift at its best.</p>

<blockquote>
<p><code>defer</code> blocks are executed in the reverse order of their appearance. This reverse order is a vital detail, ensuring everything that was in scope when a deferred block was created will still be in scope when the block is executed.</p>
</blockquote>

<h3><a id="user-content-any-other-defer-considered-harmful" class="anchor" href="#any-other-defer-considered-harmful" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>(Any Other) Defer Considered Harmful</h3>

<p>As handy as the <code>defer</code> statement is, be aware of how its capabilities can lead to confusing, untraceable code. It may be tempting to use <code>defer</code> in cases where a function needs to return a value that should also be modified, as in this typical implementation of the postfix <code>++</code> operator:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">postfix</span> <span class="pl-k">func</span> <span class="pl-en">++</span>(<span class="pl-en">inout</span> <span class="pl-smi">x</span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
    <span class="pl-k">let</span> current <span class="pl-k">=</span> x
    x <span class="pl-k">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">return</span> current
}</pre></div>

<p>In this case, <code>defer</code> offers a clever alternative. Why create a temporary variable when we can just defer the increment? </p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">postfix</span> <span class="pl-k">func</span> <span class="pl-en">++</span>(<span class="pl-en">inout</span> <span class="pl-smi">x</span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
    <span class="pl-k">defer</span> { x <span class="pl-k">+=</span> <span class="pl-c1">1</span> }
    <span class="pl-k">return</span> x
}</pre></div>

<p>Clever indeed, yet this inversion of the function's flow harms readability. Using <code>defer</code> to explicitly alter a program's flow, rather than to clean up allocated resources, will lead to a twisted and tangled execution process.</p>

<hr>

<p>"As wise programmers aware of our limitations," we must weigh the benefits of each language feature against its costs. A new statement like <code>guard</code> leads to a more linear, more readable program; apply it as widely as possible. Likewise, <code>defer</code> solves a significant challenge but forces us to keep track of its declaration as it scrolls out of sight; reserve it for its minimum intended purpose to guard against confusion and obscurity.</p>
</article></div>