<div class="announce instapaper_body md" data-path="2014-08-18-swift-literal-convertible.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>Swift Literal Convertibles</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Swift</div></td>

  <td><div>swift</div></td>

  <td><div>Last week, we wrote about overloading and creating custom operators in Swift, a language feature that is as powerful as it is controversial. By all accounts, this week's issue threatens to be equally polarizing, as it covers a feature of Swift that is pervasive, yet invisible: literal convertibles.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.2</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Last week, we wrote about <a href="http://nshipster.com/swift-operators/">overloading and creating custom operators</a> in Swift, a language feature that is as powerful as it is controversial.</p>

<p>By all accounts, this week's issue threatens to be equally polarizing, as it covers a feature of Swift that is pervasive, yet invisible: literal convertibles.</p>

<hr>

<p>In code, a <em>literal</em> is notation representing a fixed value. Most languages define literals for logical values, numbers, strings, and often arrays and dictionaries.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> int <span class="pl-k">=</span> <span class="pl-c1">57</span>
<span class="pl-k">let</span> float <span class="pl-k">=</span> <span class="pl-c1">6</span><span class="pl-k">.</span><span class="pl-c1">02</span>
<span class="pl-k">let</span> string <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span></pre></div>

<p>Literals are so ingrained in a developer's mental model of programming that most of us don't actively consider what the compiler is actually doing (thereby remaining blissfully unaware of neat tricks like <a href="http://en.wikipedia.org/wiki/String_interning">string interning</a>).</p>

<p>Having a shorthand for these essential building blocks makes code easier to both read and write.</p>

<p>In Swift, developers are provided a hook into how values are constructed from literals, called <em>literal convertible protocols</em>.</p>

<p>The standard library defines 10 such protocols:</p>

<ul>
<li><code>ArrayLiteralConvertible</code></li>
<li><code>BooleanLiteralConvertible</code></li>
<li><code>DictionaryLiteralConvertible</code></li>
<li><code>ExtendedGraphemeClusterLiteralConvertible</code></li>
<li><code>FloatLiteralConvertible</code></li>
<li><code>NilLiteralConvertible</code></li>
<li><code>IntegerLiteralConvertible</code></li>
<li><code>StringLiteralConvertible</code></li>
<li><code>StringInterpolationConvertible</code></li>
<li><code>UnicodeScalarLiteralConvertible</code></li>
</ul>

<p>Any <code>class</code> or <code>struct</code> conforming to one of these protocols will be eligible to have an instance of itself statically initialized from the corresponding literal.</p>

<p>It's what allows literal values to "just work" across the language.</p>

<p>Take optionals, for example.</p>

<h2><a id="user-content-nilliteralconvertible-and-optionals" class="anchor" href="#nilliteralconvertible-and-optionals" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NilLiteralConvertible and Optionals</h2>

<p>One of the best parts of optionals in Swift is that the underlying mechanism is actually defined in the language itself:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">enum</span> <span class="pl-c1">Optional</span><span class="pl-k">&lt;</span>T<span class="pl-k">&gt;</span> <span class="pl-k">:</span> Reflectable, <span class="pl-c1">NilLiteralConvertible</span> {
    <span class="pl-k">case</span> None
    <span class="pl-k">case</span> Some(T)
    <span class="pl-k">init</span>()
    <span class="pl-k">init</span>(_ some: T)
    <span class="pl-k">init</span>(nilLiteral: ())

    <span class="pl-k">func</span> <span class="pl-en">map</span>&lt;U&gt;(f: (T) <span class="pl-k">-&gt;</span> U) -&gt; U?
    <span class="pl-k">func</span> <span class="pl-en">getMirror</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">MirrorType</span>
}</pre></div>

<p>Notice that <code>Optional</code> conforms to the <code>NilLiteralConvertible</code> protocol:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">protocol</span> <span class="pl-c1">NilLiteralConvertible</span> {
    <span class="pl-k">init</span>(nilLiteral: ())
}</pre></div>

<p>Now consider the two statements:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> a: <span class="pl-c1">AnyObject</span> <span class="pl-k">=</span> <span class="pl-c1">nil</span> <span class="pl-c">// !</span>
<span class="pl-k">var</span> b: <span class="pl-c1">AnyObject</span>? <span class="pl-k">=</span> <span class="pl-c1">nil</span></pre></div>

<p>The declaration of <code>var a</code> generates the compiler warning <code>Type 'AnyObject' does not conform to the protocol 'NilLiteralConvertible</code>, while the declaration <code>var b</code> works as expected.</p>

<p>Under the hood, when a literal value is assigned, the Swift compiler consults the corresponding <code>protocol</code> (in this case <code>NilLiteralConvertible</code>), and calls the associated initializer (<code>init(nilLiteral: ())</code>).</p>

<p>Although the implementation of <code>init(nilLiteral: ())</code> is private, the end result is that an <code>Optional</code> set to <code>nil</code> becomes <code>.None</code>.</p>

<h2><a id="user-content-stringliteralconvertible-and-regular-expressions" class="anchor" href="#stringliteralconvertible-and-regular-expressions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>StringLiteralConvertible and Regular Expressions</h2>

<p>Swift literal convertibles can be used to provide convenient shorthand initializers for custom objects.</p>

<p>Recall our <a href="http://nshipster.com/swift-operators/"><code>Regex</code></a> example from last week:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> Regex {
    <span class="pl-k">let</span> pattern: <span class="pl-c1">String</span>
    <span class="pl-k">let</span> options: NSRegularExpressionOptions<span class="pl-k">!</span>

    <span class="pl-k">private</span> <span class="pl-k">var</span> matcher: NSRegularExpression {
        <span class="pl-k">return</span> NSRegularExpression(pattern: <span class="pl-k">self</span><span class="pl-k">.</span>pattern, options: <span class="pl-k">self</span><span class="pl-k">.</span>options, error: <span class="pl-c1">nil</span>)
    }

    <span class="pl-k">init</span>(pattern: <span class="pl-c1">String</span>, options: NSRegularExpressionOptions <span class="pl-k">=</span> <span class="pl-c1">nil</span>) {
        <span class="pl-k">self</span><span class="pl-k">.</span>pattern <span class="pl-k">=</span> pattern
        <span class="pl-k">self</span><span class="pl-k">.</span>options <span class="pl-k">=</span> options
    }

    <span class="pl-k">func</span> <span class="pl-en">match</span>(string: <span class="pl-c1">String</span>, options: NSMatchingOptions <span class="pl-k">=</span> <span class="pl-c1">nil</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
        <span class="pl-k">return</span> <span class="pl-k">self</span><span class="pl-k">.</span>matcher<span class="pl-k">.</span>numberOfMatchesInString(string, options: options, range: NSMakeRange(<span class="pl-c1">0</span>, string<span class="pl-k">.</span>utf16Count)) <span class="pl-k">!=</span> <span class="pl-c1">0</span>
    }
}</pre></div>

<p>Developers coming from a Ruby or Perl background may be disappointed by Swift's lack of support for regular expression literals, but this can be retcon'd in using the <code>StringLiteralConvertible</code> protocol:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> Regex: <span class="pl-c1">StringLiteralConvertible</span> {
    <span class="pl-k">typealias</span> ExtendedGraphemeClusterLiteralType <span class="pl-k">=</span> <span class="pl-c1">StringLiteralType</span>

    <span class="pl-k">init</span>(unicodeScalarLiteral value: UnicodeScalarLiteralType) {
        <span class="pl-k">self</span><span class="pl-k">.</span>pattern <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">value</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>
    }

    <span class="pl-k">init</span>(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType) {
        <span class="pl-k">self</span><span class="pl-k">.</span>pattern <span class="pl-k">=</span> value
    }

    <span class="pl-k">init</span>(stringLiteral value: <span class="pl-c1">StringLiteralType</span>) {
        <span class="pl-k">self</span><span class="pl-k">.</span>pattern <span class="pl-k">=</span> value
    }
}</pre></div>

<blockquote>
<p><code>StringLiteralConvertible</code> itself inherits from the <code>ExtendedGraphemeClusterLiteralConvertible</code> protocol, which in turn inherits from <code>UnicodeScalarLiteralConvertible</code>. <code>ExtendedGraphemeClusterLiteralType</code> is an internal type representing a <code>String</code> of length 1, while <code>UnicodeScalarLiteralType</code> is an internal type representing a <code>Character</code>. In order to implement the required <code>init</code>s, <code>ExtendedGraphemeClusterLiteralType</code> and <code>UnicodeScalarLiteralType</code> can be <code>typealias</code>'d to <code>StringLiteralType</code> and <code>Character</code>, respectively.</p>
</blockquote>

<p>Now, we can do this:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> string: <span class="pl-c1">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo bar baz<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> regex: Regex <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>

regex<span class="pl-k">.</span>match(string) <span class="pl-c">// true</span></pre></div>

<p>...or more simply:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span><span class="pl-k">.</span>match(string) <span class="pl-c">// true</span></pre></div>

<p>Combined with the <a href="http://nshipster.com/swift-operators">custom operator <code>=~</code></a>, this can be made even more idiomatic:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-s"><span class="pl-pds">"</span>foo bar baz<span class="pl-pds">"</span></span> <span class="pl-k">=~</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-c">// true</span></pre></div>

<hr>

<p>Some might bemoan this as the end of comprehensibility, while others will see this merely as filling in one of the missing parts of this new language.</p>

<p>It's all just a matter of what you're used to, and whether you think a developer is entitled to add features to a language in order for it to better suit their purposes.</p>

<blockquote>
<p>Either way, I hope we can all agree that this language feature is <em>interesting</em>, and worthy of further investigation. So in that spirit, let's venture forth and illustrate a few more use cases.</p>
</blockquote>

<hr>

<h2><a id="user-content-arrayliteralconvertible-and-sets" class="anchor" href="#arrayliteralconvertible-and-sets" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ArrayLiteralConvertible and Sets</h2>

<p>For a language with such a deep regard for immutability and safety, it's somewhat odd that there is no built-in support for sets in the standard library.</p>

<p>Arrays are nice and all, but the <code>O(1)</code> lookup and idempotence of sets... <em>*whistful sigh*</em></p>

<p>So here's a simple example of how <code>Set</code> might be implemented in Swift, using the built-in <code>Dictionary</code> type:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> <span class="pl-c1">Set</span><span class="pl-k">&lt;</span>T: <span class="pl-c1">Hashable</span><span class="pl-k">&gt;</span> {
    <span class="pl-k">typealias</span> Index <span class="pl-k">=</span> T
    <span class="pl-k">private</span> <span class="pl-k">var</span> dictionary: [T: <span class="pl-c1">Bool</span>] <span class="pl-k">=</span> [<span class="pl-k">:</span>]

    <span class="pl-k">var</span> count: <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> <span class="pl-k">self</span><span class="pl-k">.</span>dictionary<span class="pl-k">.</span><span class="pl-c1">count</span>
    }

    <span class="pl-k">var</span> isEmpty: <span class="pl-c1">Bool</span> {
        <span class="pl-k">return</span> <span class="pl-k">self</span><span class="pl-k">.</span>dictionary<span class="pl-k">.</span><span class="pl-c1">isEmpty</span>
    }

    <span class="pl-k">func</span> <span class="pl-en">contains</span>(element: T) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
        <span class="pl-k">return</span> <span class="pl-k">self</span><span class="pl-k">.</span>dictionary[element] <span class="pl-k">??</span> <span class="pl-c1">false</span>
    }

    <span class="pl-k">mutating</span> <span class="pl-k">func</span> <span class="pl-en">put</span>(element: T) {
        <span class="pl-k">self</span><span class="pl-k">.</span>dictionary[element] <span class="pl-k">=</span> <span class="pl-c1">true</span>
    }

    <span class="pl-k">mutating</span> <span class="pl-k">func</span> <span class="pl-en">remove</span>(element: T) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
        <span class="pl-k">if</span> <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-c1">contains</span>(element) {
            <span class="pl-k">self</span><span class="pl-k">.</span>dictionary<span class="pl-k">.</span>removeValueForKey(element)
            <span class="pl-k">return</span> <span class="pl-c1">true</span>
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>
        }
    }
}</pre></div>

<blockquote>
<p>A real, standard library-calibre implementation of <code>Set</code> would involve a <em>lot</em> more Swift-isms, like generators, sequences, and all manner of miscellaneous protocols. It's enough to write an entirely separate article about.</p>
</blockquote>

<p>Of course, a standard collection class is only as useful as it is convenient to use. <code>NSSet</code> wasn't so lucky to receive the first-class treatment when array and dictionary literal syntax was introduced with the <a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">Apple LLVM Compiler 4.0</a>, but we can right the wrongs of the past with the <code>ArrayLiteralConvertible</code> protocol:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">protocol</span> <span class="pl-c1">ArrayLiteralConvertible</span> {
    <span class="pl-k">typealias</span> Element
    <span class="pl-k">init</span>(arrayLiteral elements: Element<span class="pl-k">...</span>)
}</pre></div>

<p>Extending <code>Set</code> to adopt this protocol is relatively straightforward:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> <span class="pl-c1">Set</span>: <span class="pl-c1">ArrayLiteralConvertible</span> {
    <span class="pl-k">public</span> <span class="pl-k">init</span>(arrayLiteral elements: T<span class="pl-k">...</span>) {
        <span class="pl-k">for</span> element <span class="pl-k">in</span> elements {
            put(element)
        }
    }
}</pre></div>

<p>But that's all it takes to achieve our desired results:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> <span class="pl-k">set</span>: <span class="pl-c1">Set</span> <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]
<span class="pl-k">set</span><span class="pl-k">.</span><span class="pl-c1">contains</span>(<span class="pl-c1">1</span>) <span class="pl-c">// true</span>
<span class="pl-k">set</span><span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-c">// 3</span></pre></div>

<blockquote>
<p>This example does, however, highlight a legitimate concern for literal convertibles: <strong>type inference ambiguity</strong>. Because of the significant API overlap between collection classes like <code>Array</code> and <code>Set</code>, one could ostensibly write code that would behave differently depending on how the type was resolved (e.g. set addition is idempotent, whereas arrays accumulate, so the count after adding two equivalent elements would differ)</p>
</blockquote>

<h2><a id="user-content-stringliteralconvertible-and-urls" class="anchor" href="#stringliteralconvertible-and-urls" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>StringLiteralConvertible and URLs</h2>

<p>Alright, one last example creative use of literal convertibles: URL literals.</p>

<p><code>NSURL</code> is the fiat currency of the URL Loading System, with the nice feature of introspection of its component parts according to <a href="https://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>. Unfortunately, it's so inconvenient to instantiate, that third-party framework authors often decide to ditch them in favor of worse-but-more-convenient strings for method parameters.</p>

<p>With a simple extension on <code>NSURL</code>, one can get the best of both worlds:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> NSURL: <span class="pl-c1">StringLiteralConvertible</span> {
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-k">func</span> <span class="pl-en">convertFromExtendedGraphemeClusterLiteral</span>(value: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> Self {
        <span class="pl-k">return</span> <span class="pl-k">self</span>(string: value)
    }

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-k">func</span> <span class="pl-en">convertFromStringLiteral</span>(value: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> Self {
        <span class="pl-k">return</span> <span class="pl-k">self</span>(string: value)
    }
}</pre></div>

<p>One neat feature of literal convertibles is that the type inference works even without a variable declaration:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-s"><span class="pl-pds">"</span>http://nshipster.com/<span class="pl-pds">"</span></span><span class="pl-k">.</span>host <span class="pl-c">// nshipster.com</span></pre></div>

<hr>

<p>As a community, it's up to us to decide what capabilities of Swift are features and what are bugs. We'll be the ones to distinguish pattern from anti-pattern; convention from red flag.</p>

<p>So it's unclear, at the present moment, how things like literal convertibles, custom operators, and all of the other capabilities of Swift will be reconciled. This publication has, at times, been more or less prescriptive on how things should be, but in this case, that's not the case here.</p>

<p>All there is to be done is to experiment and learn.</p>
</article></div>