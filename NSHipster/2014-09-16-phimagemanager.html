<div class="announce instapaper_body md" data-path="2014-09-16-phimagemanager.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>PHImageManager</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>Yesterday's article described various techniques for resizing images using APIs from the UIKit, Core Graphics, Core Image, and Image I/O frameworks. However, that article failed to mention some rather extraordinary functionality baked into the new Photos framework which takes care of all of this for you.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>September 15, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p><a href="http://nshipster.com/image-resizing/">Yesterday's article</a> described various techniques for resizing images using APIs from the UIKit, Core Graphics, Core Image, and Image I/O frameworks. However, that article failed to mention some rather extraordinary functionality baked into the new Photos framework which takes care of all of this for you.</p>

<p>For anyone developing apps that manage photos or videos, meet your new best friend: <code>PHImageManager</code>.</p>

<hr>

<p>New in iOS 8, the Photos framework is something of a triumph for the platform. Photography is one of the key verticals for the iPhone: in addition to being the <a href="https://www.flickr.com/cameras">most popular cameras in the world</a>, photo &amp; video apps are regularly featured on the App Store. This framework goes a long way to empower apps to do even more, with a shared set of tools and primitives.</p>

<p>A great example of this is <code>PHImageManager</code>, which acts as a centralized coordinator for image assets. Previously, each app was responsible for creating and caching their own image thumbnails. In addition to requiring extra work on the part of developers, redundant image caches could potentially add up to <em>gigabytes</em> of data across the system. But with <code>PHImageManager</code>, apps don't have to worry about resizing or caching logistics, and can instead focus on building out features.</p>

<h2><a id="user-content-requesting-asset-images" class="anchor" href="#requesting-asset-images" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Requesting Asset Images</h2>

<p><code>PHImageManager</code> provides several APIs for asynchronously fetching image and video data for assets. For a given asset, a <code>PHImageManager</code> can request an image at a particular size and content mode, with a high degree of configurability in terms of quality and delivery options.</p>

<p>But first, here's a simple example of how a table view might asynchronously load cell images with asset thumbnails:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">import</span> <span class="pl-c1">Photos</span>

<span class="pl-k">var</span> assets: [PHAsset]

<span class="pl-k">func</span> <span class="pl-en">tableView</span>(tableView: UITableView, <span class="pl-en">cellForRowAtIndexPath</span> <span class="pl-smi">indexPath</span>: NSIndexPath) <span class="pl-k">-&gt;</span> UITableViewCell {
    <span class="pl-k">let</span> cell <span class="pl-k">=</span> tableView<span class="pl-k">.</span>dequeueReusableCellWithIdentifier(<span class="pl-s"><span class="pl-pds">"</span>Cell<span class="pl-pds">"</span></span>, forIndexPath: indexPath)

    <span class="pl-k">let</span> manager <span class="pl-k">=</span> PHImageManager<span class="pl-k">.</span>defaultManager()

    <span class="pl-k">if</span> cell<span class="pl-k">.</span>tag <span class="pl-k">!=</span> <span class="pl-c1">0</span> {
        manager<span class="pl-k">.</span>cancelImageRequest(PHImageRequestID(cell<span class="pl-k">.</span>tag))
    }

    <span class="pl-k">let</span> asset <span class="pl-k">=</span> assets[indexPath<span class="pl-k">.</span>row]

    <span class="pl-k">if</span> <span class="pl-k">let</span> creationDate <span class="pl-k">=</span> asset<span class="pl-k">.</span>creationDate {
        cell<span class="pl-k">.</span>textLabel?<span class="pl-k">.</span>text <span class="pl-k">=</span> NSDateFormatter<span class="pl-k">.</span>localizedStringFromDate(creationDate,
            dateStyle: <span class="pl-k">.</span>MediumStyle,
            timeStyle: <span class="pl-k">.</span>MediumStyle
        )
    } <span class="pl-k">else</span> {
        cell<span class="pl-k">.</span>textLabel?<span class="pl-k">.</span>text <span class="pl-k">=</span> <span class="pl-c1">nil</span>
    }

    cell<span class="pl-k">.</span>tag <span class="pl-k">=</span> <span class="pl-c1">Int</span>(manager<span class="pl-k">.</span>requestImageForAsset(asset,
        targetSize: CGSize(width: <span class="pl-c1">100</span><span class="pl-k">.</span><span class="pl-c1">0</span>, height: <span class="pl-c1">100</span><span class="pl-k">.</span><span class="pl-c1">0</span>),
        contentMode: <span class="pl-k">.</span>AspectFill,
        options: <span class="pl-c1">nil</span>) { (result, _) <span class="pl-k">in</span>
            cell<span class="pl-k">.</span>imageView?<span class="pl-k">.</span>image <span class="pl-k">=</span> result
    })

    <span class="pl-k">return</span> cell
}</pre></div>

<div class="highlight highlight-source-objc"><pre>@import Photos;

@property (nonatomic, strong) <span class="pl-c1">NSArray</span>&lt;PHAsset *&gt; *assets;

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(<span class="pl-c1">NSIndexPath</span> *)indexPath {
    UITableViewCell *cell = [tableView <span class="pl-c1">dequeueReusableCellWithIdentifier:</span><span class="pl-s"><span class="pl-pds">@"</span>Cell<span class="pl-pds">"</span></span>
                                                            <span class="pl-c1">forIndexPath:</span>indexPath];

    PHImageManager *manager = [PHImageManager <span class="pl-c1">defaultManager</span>];

    <span class="pl-k">if</span> (cell.<span class="pl-smi">tag</span>) {
        [manager <span class="pl-c1">cancelImageRequest:</span>(PHImageRequestID)cell.tag];
    }

    PHAsset *asset = self.<span class="pl-smi">assets</span>[indexPath.row];

    <span class="pl-k">if</span> (asset.<span class="pl-smi">creationDate</span>) {
        cell.<span class="pl-smi">textLabel</span>.<span class="pl-smi">text</span> = [<span class="pl-c1">NSDateFormatter</span> <span class="pl-c1">localizedStringFromDate:</span>asset.creationDate
                                                             <span class="pl-c1">dateStyle:</span>NSDateFormatterMediumStyle
                                                             <span class="pl-c1">timeStyle:</span>NSDateFormatterMediumStyle];
    } <span class="pl-k">else</span> {
        cell.<span class="pl-smi">textLabel</span>.<span class="pl-smi">text</span> = <span class="pl-c1">nil</span>;
    }

    cell.<span class="pl-smi">tag</span> = [manager <span class="pl-c1">requestImageForAsset:</span>asset
                                  <span class="pl-c1">targetSize:</span><span class="pl-c1">CGSizeMake</span>(<span class="pl-c1">100.0</span>, <span class="pl-c1">100.0</span>)
                                 <span class="pl-c1">contentMode:</span>PHImageContentModeAspectFill
                                     <span class="pl-c1">options:</span><span class="pl-c1">nil</span>
                               <span class="pl-c1">resultHandler:</span>^(UIImage * _Nullable result, <span class="pl-c1">NSDictionary</span> * _Nullable info) {
                                   cell.<span class="pl-smi">imageView</span>.<span class="pl-smi">image</span> = result;
                               }];

    <span class="pl-k">return</span> cell;
}</pre></div>

<p>API usage is pretty straightforward: the <code>defaultManager</code> asynchronously requests an image for the asset corresponding to the cell at a particular index path, and the cell image view is set whenever the result comes back. The only tricky part is handling cell reuseâ€”(1) before assigning the resulting image to the cell's image view, we call <code>cellForRowAtIndexPath</code> to be sure we're working with the right cell, and (2) we use the cell's <code>tag</code> to keep track of image requests, in order to cancel any pending requests when a cell is reused.</p>

<h2><a id="user-content-batch-pre-caching-asset-images" class="anchor" href="#batch-pre-caching-asset-images" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Batch Pre-Caching Asset Images</h2>

<p>If there's reasonable assurance that most of a set of assets will be viewed at some point, it may make sense to pre-cache those images. <code>PHCachingImageManager</code> is a subclass of <code>PHImageManager</code> designed to do just that.</p>

<p>For example, here's how the results of a <code>PHAsset</code> fetch operation can be pre-cached in order to optimize image availability:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> cachingImageManager <span class="pl-k">=</span> PHCachingImageManager()

<span class="pl-k">let</span> options <span class="pl-k">=</span> PHFetchOptions()
options<span class="pl-k">.</span>predicate <span class="pl-k">=</span> NSPredicate(format: <span class="pl-s"><span class="pl-pds">"</span>favorite == YES<span class="pl-pds">"</span></span>)
options<span class="pl-k">.</span>sortDescriptors <span class="pl-k">=</span> [
    NSSortDescriptor(key: <span class="pl-s"><span class="pl-pds">"</span>creationDate<span class="pl-pds">"</span></span>, ascending: <span class="pl-c1">true</span>)
]

<span class="pl-k">let</span> results <span class="pl-k">=</span> PHAsset<span class="pl-k">.</span>fetchAssetsWithMediaType(<span class="pl-k">.</span>Image, options: options)
<span class="pl-k">var</span> assets: [PHAsset] <span class="pl-k">=</span> []
results<span class="pl-k">.</span>enumerateObjectsUsingBlock { (object, _, _) <span class="pl-k">in</span>
    <span class="pl-k">if</span> <span class="pl-k">let</span> asset <span class="pl-k">=</span> object <span class="pl-k">as?</span> PHAsset {
        assets<span class="pl-k">.</span>append(asset)
    }
}

cachingImageManager<span class="pl-k">.</span>startCachingImagesForAssets(assets,
    targetSize: PHImageManagerMaximumSize,
    contentMode: <span class="pl-k">.</span>AspectFit,
    options: <span class="pl-c1">nil</span>
)</pre></div>

<div class="highlight highlight-source-objc"><pre>PHCachingImageManager *cachingImageManager = [[PHCachingImageManager <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];

PHFetchOptions *options = [[PHFetchOptions <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
options.predicate = [<span class="pl-c1">NSPredicate</span> <span class="pl-c1">predicateWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>favorite == <span class="pl-c1">YES</span><span class="pl-pds">"</span></span>];
options.sortDescriptors = @[[<span class="pl-c1">NSSortDescriptor</span> <span class="pl-c1">sortDescriptorWithKey:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-pds">"</span></span> <span class="pl-c1">ascending:</span><span class="pl-c1">YES</span>]];

PHFetchResult *results = [PHAsset <span class="pl-c1">fetchAssetsWithMediaType:</span>PHAssetMediaTypeImage
                                                  <span class="pl-c1">options:</span><span class="pl-c1">nil</span>];

<span class="pl-c1">NSMutableArray</span>&lt;PHAsset *&gt; *assets = [[<span class="pl-c1">NSMutableArray</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
[results <span class="pl-c1">enumerateObjectsUsingBlock:</span>^(<span class="pl-c1">id</span>  _Nonnull object, <span class="pl-c1">NSUInteger</span> idx, <span class="pl-c1">BOOL</span> * _Nonnull stop) {
    <span class="pl-k">if</span> ([object <span class="pl-c1">isKindOfClass:</span>[PHAsset <span class="pl-c1">class</span>]]) {
        [assets <span class="pl-c1">addObject:</span>object];
    }
}];

[cachingImageManager <span class="pl-c1">startCachingImagesForAssets:</span>assets
                                      <span class="pl-c1">targetSize:</span>PHImageManagerMaximumSize
                                     <span class="pl-c1">contentMode:</span>PHImageContentModeAspectFit
                                         <span class="pl-c1">options:</span><span class="pl-c1">nil</span>];</pre></div>

<p>Alternatively, Swift <code>willSet</code> / <code>didSet</code> hooks offer a convenient way to automatically start pre-caching assets as they are loaded:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> cachingImageManager <span class="pl-k">=</span> PHCachingImageManager()
<span class="pl-k">var</span> assets: [PHAsset] <span class="pl-k">=</span> [] {
    <span class="pl-k">willSet</span> {
        cachingImageManager<span class="pl-k">.</span>stopCachingImagesForAllAssets()
    }

    <span class="pl-k">didSet</span> {
        cachingImageManager<span class="pl-k">.</span>startCachingImagesForAssets(<span class="pl-k">self</span><span class="pl-k">.</span>assets,
            targetSize: PHImageManagerMaximumSize,
            contentMode: <span class="pl-k">.</span>AspectFit,
            options: <span class="pl-c1">nil</span>
        )
    }
}</pre></div>

<h2><a id="user-content-phimagerequestoptions" class="anchor" href="#phimagerequestoptions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PHImageRequestOptions</h2>

<p>In the previous examples, the <code>options</code> parameter of <code>requestImageForAsset()</code> &amp; <code>startCachingImagesForAssets()</code> have been set to <code>nil</code>. Passing an instance of <code>PHImageRequestOptions</code> allows for fine-grained control over what gets loaded and how.</p>

<p><code>PHImageRequestOptions</code> has the following properties:</p>

<blockquote>
<ul>
<li><code>deliveryMode</code> <em><code>PHImageRequestOptionsDeliveryMode</code></em>: (<em>Described Below</em>)</li>
<li><code>networkAccessAllowed</code> <em><code>Bool</code></em>: Will download the image from iCloud, if necessary.</li>
<li><code>normalizedCropRect</code> <em><code>CGRect</code></em>: Specify a crop rectangle in unit coordinates of the original image.</li>
<li><code>progressHandler</code>: Provide caller a way to be told how much progress has been made prior to delivering the data when it comes from iCloud. Defaults to nil, shall be set by caller</li>
<li><code>resizeMode</code> <em><code>PHImageRequestOptionsResizeMode</code></em>: <code>.None</code>, <code>.Fast</code>, or <code>.Exact</code>. Does not apply when size is <code>PHImageManagerMaximumSize</code>.</li>
<li><code>synchronous</code> <em><code>Bool</code></em>: Return only a single result, blocking until available (or failure). Defaults to NO</li>
<li><code>version</code> <em><code>PHImageRequestOptionsVersion</code></em>: <code>.Current</code>, <code>.Unadjusted</code>, or <code>.Original</code></li>
</ul>
</blockquote>

<p>Several of these properties take a specific <code>enum</code> type, which are all pretty self explanatory, save for <code>PHImageRequestOptionsDeliveryMode</code>, which encapsulates some pretty complex behavior:</p>

<h3><a id="user-content-phimagerequestoptionsdeliverymode" class="anchor" href="#phimagerequestoptionsdeliverymode" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PHImageRequestOptionsDeliveryMode</h3>

<blockquote>
<ul>
<li><code>.Opportunistic</code>: Photos automatically provides one or more results in order to balance image quality and responsiveness. Photos may call the resultHandler block method more than once, such as to provide a low-quality image suitable for displaying temporarily while it prepares a high-quality image. If the image manager has already cached the requested image, Photos calls your result handler only once. This option is not available if the synchronous property is <code>false</code>.</li>
<li><code>.HighQualityFormat</code>: Photos provides only the highest-quality image available, regardless of how much time it takes to load. If the synchronous property is <code>true</code> or if using the <code>requestImageDataForAsset:options:resultHandler:</code> method, this behavior is the default and only option.</li>
<li><code>.FastFormat</code>: Photos provides only a fast-loading image, possibly sacrificing image quality. If a high-quality image cannot be loaded quickly, the result handler provides a low-quality image. Check the <code>PHImageResultIsDegradedKey</code> key in the <code>info</code> dictionary to determine the quality of image provided to the result handler.</li>
</ul>
</blockquote>

<h2><a id="user-content-cropping-asset-to-detected-faces-using-2-phase-image-request" class="anchor" href="#cropping-asset-to-detected-faces-using-2-phase-image-request" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cropping Asset To Detected Faces Using 2-Phase Image Request</h2>

<p>Using <code>PHImageManager</code> and <code>PHImageRequestOptions</code> to their full capacity allows for rather sophisticated functionality. One could, for example, use successive image requests to crop full-quality assets to any faces detected in the image.</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> asset: PHAsset

<span class="pl-k">@IBOutlet</span> <span class="pl-k">weak</span> <span class="pl-k">var</span> imageView: UIImageView<span class="pl-k">!</span>
<span class="pl-k">@IBOutlet</span> <span class="pl-k">weak</span> <span class="pl-k">var</span> progressView: UIProgressView<span class="pl-k">!</span>

<span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">viewDidLoad</span>() {
    <span class="pl-k">super</span><span class="pl-k">.</span>viewDidLoad()

    <span class="pl-k">let</span> manager <span class="pl-k">=</span> PHImageManager<span class="pl-k">.</span>defaultManager()

    <span class="pl-k">let</span> initialRequestOptions <span class="pl-k">=</span> PHImageRequestOptions()
    initialRequestOptions<span class="pl-k">.</span>synchronous <span class="pl-k">=</span> <span class="pl-c1">true</span>
    initialRequestOptions<span class="pl-k">.</span>resizeMode <span class="pl-k">=</span> <span class="pl-k">.</span>Fast
    initialRequestOptions<span class="pl-k">.</span>deliveryMode <span class="pl-k">=</span> <span class="pl-k">.</span>FastFormat

    manager<span class="pl-k">.</span>requestImageForAsset(asset,
        targetSize: CGSize(width: <span class="pl-c1">250</span><span class="pl-k">.</span><span class="pl-c1">0</span>, height: <span class="pl-c1">250</span><span class="pl-k">.</span><span class="pl-c1">0</span>),
        contentMode: <span class="pl-k">.</span>AspectFit,
        options: initialRequestOptions) { (initialResult, _) <span class="pl-k">in</span>
            <span class="pl-k">guard</span> <span class="pl-k">let</span> ciImage <span class="pl-k">=</span> initialResult?<span class="pl-k">.</span>CIImage <span class="pl-k">else</span> {
                <span class="pl-k">return</span>
            }

            <span class="pl-k">let</span> finalRequestOptions <span class="pl-k">=</span> PHImageRequestOptions()
            finalRequestOptions<span class="pl-k">.</span>progressHandler <span class="pl-k">=</span> { (progress, _, _, _) <span class="pl-k">in</span>
                <span class="pl-k">self</span><span class="pl-k">.</span>progressView<span class="pl-k">.</span>progress <span class="pl-k">=</span> <span class="pl-c1">Float</span>(progress)
            }

            <span class="pl-k">let</span> detector <span class="pl-k">=</span> CIDetector(
                ofType: CIDetectorTypeFace,
                context: <span class="pl-c1">nil</span>,
                options: [CIDetectorAccuracy: CIDetectorAccuracyLow]
            )

            <span class="pl-k">let</span> features <span class="pl-k">=</span> detector<span class="pl-k">.</span>featuresInImage(ciImage)
            <span class="pl-k">if</span> features<span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> {
                <span class="pl-k">var</span> rect <span class="pl-k">=</span> CGRectZero
                features<span class="pl-k">.</span>forEach {
                    rect<span class="pl-k">.</span>unionInPlace($<span class="pl-c1">0</span><span class="pl-k">.</span>bounds)
                }

                <span class="pl-k">let</span> transform <span class="pl-k">=</span> CGAffineTransformMakeScale(<span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">0</span> <span class="pl-k">/</span> initialResult<span class="pl-k">!.</span>size<span class="pl-k">.</span>width, <span class="pl-c1">1</span><span class="pl-k">.</span><span class="pl-c1">0</span> <span class="pl-k">/</span> initialResult<span class="pl-k">!.</span>size<span class="pl-k">.</span>height)
                finalRequestOptions<span class="pl-k">.</span>normalizedCropRect <span class="pl-k">=</span> CGRectApplyAffineTransform(rect, transform)
            }

            manager<span class="pl-k">.</span>requestImageForAsset(<span class="pl-k">self</span><span class="pl-k">.</span>asset,
                targetSize: PHImageManagerMaximumSize,
                contentMode: <span class="pl-k">.</span>AspectFit,
                options: finalRequestOptions) { (finalResult, _) <span class="pl-k">in</span>
                    <span class="pl-k">self</span><span class="pl-k">.</span>imageView<span class="pl-k">.</span>image <span class="pl-k">=</span> finalResult
            }
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre>@property (nonatomic, strong) PHAsset *asset;
@property (nonatomic, weak) <span class="pl-k">IBOutlet</span> UIImageView *imageView;
@property (nonatomic, weak) <span class="pl-k">IBOutlet</span> UIProgressView *progressView;

- (<span class="pl-k">void</span>)viewDidLoad {
    [<span class="pl-v">super</span> <span class="pl-c1">viewDidLoad</span>];

    PHImageManager *manager = [PHImageManager <span class="pl-c1">defaultManager</span>];

    PHImageRequestOptions *initialRequestOptions = [[PHImageRequestOptions <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
    initialRequestOptions.<span class="pl-smi">synchronous</span> = <span class="pl-c1">true</span>;
    initialRequestOptions.<span class="pl-smi">resizeMode</span> = PHImageRequestOptionsResizeModeFast;
    initialRequestOptions.<span class="pl-smi">deliveryMode</span> = PHImageRequestOptionsDeliveryModeFastFormat;

    <span class="pl-c1">void</span> (^resultHandler)(UIImage *, <span class="pl-c1">NSDictionary</span> *) = ^(UIImage * _Nullable initialResult, <span class="pl-c1">NSDictionary</span> * _Nullable info) {
        <span class="pl-k">if</span> (!initialResult.<span class="pl-smi">CIImage</span>) {
            <span class="pl-k">return</span>;
        }

        PHImageRequestOptions *finalRequestOptions = [[PHImageRequestOptions <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>];
        finalRequestOptions.<span class="pl-smi">progressHandler</span> = ^(<span class="pl-k">double</span> progress, <span class="pl-c1">NSError</span> *error, <span class="pl-c1">BOOL</span> *stop, <span class="pl-c1">NSDictionary</span> *info) {
            self.<span class="pl-smi">progressView</span>.<span class="pl-smi">progress</span> = progress;
        };

        CIDetector *detector = [CIDetector <span class="pl-c1">detectorOfType:</span>CIDetectorTypeFace
                                                  <span class="pl-c1">context:</span><span class="pl-c1">nil</span>
                                                  <span class="pl-c1">options:</span>@{CIDetectorAccuracy : CIDetectorAccuracyLow}];
        <span class="pl-c1">NSArray</span>&lt;CIFeature *&gt; *features = [detector <span class="pl-c1">featuresInImage:</span>initialResult.CIImage];
        <span class="pl-k">if</span> (features.<span class="pl-smi">count</span>) {
            <span class="pl-c1">CGRect</span> rect;
            <span class="pl-k">for</span> (CIFeature *feature in features) {
                <span class="pl-c1">CGRectUnion</span>(rect, feature.<span class="pl-smi">bounds</span>);
            }

            <span class="pl-c1">CGAffineTransform</span> transform = <span class="pl-c1">CGAffineTransformMakeScale</span>(<span class="pl-c1">1.0</span> / initialResult.<span class="pl-smi">size</span>.<span class="pl-smi">width</span>, <span class="pl-c1">1.0</span> / initialResult.<span class="pl-smi">size</span>.<span class="pl-smi">height</span>);
            finalRequestOptions.<span class="pl-smi">normalizedCropRect</span> = <span class="pl-c1">CGRectApplyAffineTransform</span>(rect, transform);
        }

        [manager <span class="pl-c1">requestImageForAsset:</span><span class="pl-v">self</span>.asset
                           <span class="pl-c1">targetSize:</span>PHImageManagerMaximumSize
                          <span class="pl-c1">contentMode:</span>PHImageContentModeAspectFit
                              <span class="pl-c1">options:</span>finalRequestOptions
                        <span class="pl-c1">resultHandler:</span>^(UIImage * _Nullable finalResult, <span class="pl-c1">NSDictionary</span> * _Nullable info) {
                            self.<span class="pl-smi">imageView</span>.<span class="pl-smi">image</span> = finalResult;
                        }];
    };
    <span class="pl-c">// typedef void (^ PHAssetImageProgressHandler)(double progress, NSError *__nullable error, BOOL *stop, NSDictionary *__nullable info) NS_AVAILABLE_IOS(8_0);</span>

    [manager <span class="pl-c1">requestImageForAsset:</span><span class="pl-v">self</span>.asset
                       <span class="pl-c1">targetSize:</span>PHImageManagerMaximumSize
                      <span class="pl-c1">contentMode:</span>PHImageContentModeAspectFit
                          <span class="pl-c1">options:</span>initialRequestOptions
                    <span class="pl-c1">resultHandler:</span>resultHandler];

}</pre></div>

<p>The initial request attempts to get the most readily available representation of an asset to pass into a <code>CIDetector</code> for facial recognition. If any features were detected, the final request would be cropped to them, by specifying the <code>normalizedCropRect</code> on the final <code>PHImageRequestOptions</code>.</p>

<blockquote>
<p><code>normalizedCropRect</code> is normalized for <code>origin</code> and <code>size</code> components within the inclusive range <code>0.0</code> to <code>1.0</code>. An affine transformation scaling on the inverse of the original frame makes for an easy calculation.</p>
</blockquote>

<hr>

<p>From its very inception, iOS has been a balancing act between functionality and integrity. And with every release, a combination of thoughtful affordances and powerful APIs have managed to expand the role third-party applications without compromising security or performance.</p>

<p>By unifying functionality for fetching, managing, and manipulating photos, the Photos framework will dramatically raise the standards for existing apps, while simultaneously lowering the bar for developing apps, and is a stunning example of why developers tend to prefer iOS as a platform.</p>
</article></div>