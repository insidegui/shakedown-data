<div class="announce instapaper_body md" data-path="2012-11-12-nsvaluetransformer.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>NSValueTransformer</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Cocoa</div></td>

  <td><div>nshipster</div></td>

  <td><div>Of all the Foundation classes, NSValueTransformer is perhaps the one that fared the worst in the shift from OS X to iOS. But you know what? It's ripe for a comeback. With a little bit of re-tooling and some recontextualization, this blast from the past could be the next big thing in your application.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>

  <th>reviewed</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>2.0</div></td>

  <td><div>September 8, 2015</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>Of all the Foundation classes, <code>NSValueTransformer</code> is perhaps the one that fared the worst in the shift from OS X to iOS.</p>

<p>Why? Well, there are two reasons:</p>

<p>The first and most obvious reason is that <code>NSValueTransformer</code> was mainly used in AppKit with Cocoa bindings. Here, they could automatically transform values from one property to another without the need of intermediary glue code, like for negating a boolean, or checking whether a value was <code>nil</code>. iOS, of course, doesn't have bindings.</p>

<p>The second reason has less to do with iOS than the Objective-C runtime itself. With the introduction of blocks, it got a whole lot easier to pass behavior between objects--significantly easier than, say <code>NSValueTransformer</code> or <code>NSInvocation</code>. So even if iOS were to get bindings tomorrow, it's uncertain as to whether <code>NSValueTransformer</code> would play as significant a role this time around.</p>

<p>But you know what? <code>NSValueTransformer</code> is ripe for a comeback. With a little bit of re-tooling and some recontextualization, this blast from the past could be the next big thing in your application.</p>

<hr>

<p><code>NSValueTransformer</code> is an abstract class that transforms one value into another. A transformation specifies what kinds of input values can be handled, and can even supports reversible transformations, where applicable.</p>

<p>A typical implementation would look something like this:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> ClassNameTransformer: NSValueTransformer {

    <span class="pl-k">override</span> <span class="pl-k">class</span> <span class="pl-k">func</span> <span class="pl-en">transformedValueClass</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">AnyClass</span> {
        <span class="pl-k">return</span> NSString<span class="pl-k">.</span><span class="pl-k">self</span>
    }

    <span class="pl-k">override</span> <span class="pl-k">class</span> <span class="pl-k">func</span> <span class="pl-en">allowsReverseTransformation</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {
        <span class="pl-k">return</span> <span class="pl-c1">false</span>
    }

    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">transformedValue</span>(value: <span class="pl-c1">AnyObject</span>?) <span class="pl-k">-&gt;</span> <span class="pl-c1">AnyObject</span>? {
        <span class="pl-k">guard</span> <span class="pl-k">let</span> type <span class="pl-k">=</span> value <span class="pl-k">as?</span> <span class="pl-c1">AnyClass</span> <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }
        <span class="pl-k">return</span> NSStringFromClass(type)
    }
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">@interface</span> <span class="pl-en">ClassNameTransformer</span>: <span class="pl-e">NSValueTransformer</span> {}
<span class="pl-k">@end</span>

#<span class="pl-k">pragma mark</span> -

<span class="pl-k">@implementation</span> <span class="pl-en">ClassNameTransformer</span>
+ (<span class="pl-c1">Class</span>)<span class="pl-en">transformedValueClass</span> {
  <span class="pl-k">return</span> [<span class="pl-c1">NSString</span> <span class="pl-c1">class</span>];
}

+ (<span class="pl-c1">BOOL</span>)<span class="pl-en">allowsReverseTransformation</span> {
    <span class="pl-k">return</span> <span class="pl-c1">NO</span>;
}

- (<span class="pl-c1">id</span>)<span class="pl-en">transformedValue</span><span class="pl-en">:</span>(<span class="pl-c1">id</span>)<span class="pl-smi">value</span> {
    <span class="pl-k">return</span> (value == <span class="pl-c1">nil</span>) ? <span class="pl-c1">nil</span> : <span class="pl-c1">NSStringFromClass</span>([value <span class="pl-c1">class</span>]);
}
<span class="pl-k">@end</span></pre></div>

<p><code>NSValueTransformer</code> is rarely initialized directly. Instead, it follows a pattern familiar to fans of <code>NSPersistentStore</code> or <code>NSURLProtocol</code>, where a class is registered, and instances are created from a manager--except in this case, you register the <em>instance</em> to act as a singleton (with a particular name):</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> ClassNameTransformerName <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ClassNameTransformer<span class="pl-pds">"</span></span>

<span class="pl-c">// Set the value transformer</span>
NSValueTransformer<span class="pl-k">.</span>setValueTransformer(ClassNameTransformer(), forName: ClassNameTransformerName)

<span class="pl-c">// Get the value transformer</span>
<span class="pl-k">let</span> valueTransformer <span class="pl-k">=</span> NSValueTransformer(forName: ClassNameTransformerName)</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> * <span class="pl-k">const</span> ClassNameTransformerName = <span class="pl-s"><span class="pl-pds">@"</span>ClassNameTransformer<span class="pl-pds">"</span></span>;

<span class="pl-c">// Set the value transformer</span>
[<span class="pl-c1">NSValueTransformer</span> <span class="pl-c1">setValueTransformer:</span>[[ClassNameTransformer <span class="pl-c1">alloc</span>] <span class="pl-c1">init</span>] <span class="pl-c1">forName:</span>ClassNameTransformerName];

<span class="pl-c">// Get the value transformer</span>
<span class="pl-c1">NSValueTransformer</span> *valueTransformer = [<span class="pl-c1">NSValueTransformer</span> <span class="pl-c1">valueTransformerForName:</span>ClassNameTransformerName];</pre></div>

<p>Typically, the singleton instance would be registered in the <code>+initialize</code> method of the value transformer subclass, so it could be used without further setup.</p>

<p>Now, at this point, you probably realize <code>NSValueTransformer</code>'s fatal flaw: it's a pain in the ass to set up! Create a class, implement a handful of simple methods, define a constant, <em>and</em> register it in an <code>+initialize</code> method? No thanks.</p>

<p>In this age of blocks, we want--nay, <em>demand</em>--a way to declare functionality in one (albeit gigantic) line of code.</p>

<p>Nothing <a href="https://github.com/mattt/TransformerKit/blob/master/TransformerKit/NSValueTransformer%2BTransformerKit.m#L36">a little metaprogramming</a> can't fix. Behold:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> TKCapitalizedStringTransformerName <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>TKCapitalizedStringTransformerName<span class="pl-pds">"</span></span>

NSValueTransformer<span class="pl-k">.</span>registerValueTransformerWithName(TKCapitalizedStringTransformerName,
    transformedValueClass:NSString<span class="pl-k">.</span><span class="pl-k">self</span>) { obj <span class="pl-k">in</span>
        <span class="pl-k">guard</span> <span class="pl-k">let</span> str <span class="pl-k">=</span> obj <span class="pl-k">as?</span> <span class="pl-c1">String</span> <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-c1">nil</span> }
        <span class="pl-k">return</span> str<span class="pl-k">.</span>capitalizedString
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSString</span> * <span class="pl-k">const</span> TKCapitalizedStringTransformerName = <span class="pl-s"><span class="pl-pds">@"</span>TKCapitalizedStringTransformerName<span class="pl-pds">"</span></span>;

[<span class="pl-c1">NSValueTransformer</span> <span class="pl-c1">registerValueTransformerWithName:</span>TKCapitalizedStringTransformerName
           <span class="pl-c1">transformedValueClass:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">class</span>]
<span class="pl-c1">returningTransformedValueWithBlock:</span>^<span class="pl-c1">id</span>(<span class="pl-c1">id</span> value) {
  <span class="pl-k">return</span> [value <span class="pl-c1">capitalizedString</span>];
}];</pre></div>

<p>Not to break the 4th wall or anything, but in the middle of writing this article, I was compelled to see what could be done to improve the experience of <code>NSValueTransformer</code>. What I came up with was <a href="https://github.com/mattt/TransformerKit">TransformerKit</a>.</p>

<p>The entire library is based on some objc runtime hackery in an <code>NSValueTransformer</code> category. Also included with this category are a number of convenient examples, like string case transformers (i.e. <code>CamelCase</code>, <code>llamaCase</code>, <code>snake_case</code>, and <code>train-case</code>).</p>

<p>Now with its sexy new getup, we start to form a better understanding of where this could be useful:</p>

<ul>
<li><code>NSValueTransformers</code> are the ideal way to represent an ordered chain of fixed transformations. For instance, an app interfacing with a legacy system might transform user input through a succession of string transformations (trim whitespace, remove diacritics, and then capitalize letters) before sending it off to the mainframe.</li>
<li>Unlike blocks, <code>NSValueTransformer</code> encapsulates reversible transformations. Let's say you were wanted to map keys from a REST API representation into a Model object; you could create a reversible transformation that converted <code>snake_case</code> to <code>llamaCase</code> when initializing, and <code>llamaCase</code> to <code>snake_case</code> when serializing back to the server.</li>
<li>Another advantage over blocks is that <code>NSValueTransformer</code> subclasses can expose new properties that could be used to configure behavior in a particular way. Access to <code>ivars</code> also make it easier to cleanly memoize results, or do any necessary book-keeping along the way.</li>
<li>Lest we forget, <code>NSValueTransformer</code> can be used with Core Data, as a way to encode and decode compound data types from blob fields. It seems to have fallen out of fashion over the years, but serializing simple collections in this way, for example, is an excellent strategy for information that isn't well-modeled as its own entity. Just don't serialize images to a database this way--that's generally a Bad Idea™.</li>
</ul>

<p>And the list goes on.</p>

<hr>

<p><code>NSValueTransformer</code>, far from a vestige of AppKit, remains Foundation's purest connection to that fundamental concept of computation: input goes in, output comes out.</p>

<p>Although it hasn't aged very well on its own, a little modernization restores <code>NSValueTransformer</code> to that highest esteem of NSHipsterdom: the solution that we didn't know we needed, but was there all along.</p>
</article></div>