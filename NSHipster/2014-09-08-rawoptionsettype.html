<div class="announce instapaper_body md" data-path="2014-09-08-rawoptionsettype.md" id="file"><article class="markdown-body entry-content" itemprop="text"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>title</th>

  <th>author</th>

  <th>category</th>

  <th>tags</th>

  <th>excerpt</th>

  <th>status</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>RawOptionSetType</div></td>

  <td><div>Mattt Thompson</div></td>

  <td><div>Swift</div></td>

  <td><div>swift</div></td>

  <td><div>Swift enumerations are a marked improvement over the `NS_ENUM` macro in Objective-C. Unfortunately, `NS_OPTIONS` does not compare as favorably.</div></td>

  <td><div><table>
  <thead>
  <tr>
  <th>swift</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>1.2</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table>

<p>In Objective-C, <a href="http://nshipster.com/ns_enum-ns_options/"><code>NS_ENUM</code> &amp; <code>NS_OPTIONS</code></a> are used to annotate C <code>enum</code>s in such a way that sets clear expectations for both the compiler and developer. Since being introduced to Objective-C with Xcode 4.5, these macros have become a standard convention in system frameworks, and a best practice within the community.</p>

<p>In Swift, enumerations are codified as a first-class language construct as fundamental as a <code>struct</code> or <code>class</code>, and include a number of features that make them even more expressive, like raw types and associated values. They're so perfectly-suited to encapsulating closed sets of fixed values, that developers would do well to actively seek out opportunities to use them.</p>

<p>When interacting with frameworks like Foundation in Swift, all of those <code>NS_ENUM</code> declarations are automatically converted into an <code>enum</code>—often improving on the original Objective-C declaration by eliminating naming redundancies:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">enum</span> UITableViewCellStyle <span class="pl-k">:</span> <span class="pl-c1">Int</span> {
    <span class="pl-k">case</span> Default
    <span class="pl-k">case</span> Value1
    <span class="pl-k">case</span> Value2
    <span class="pl-k">case</span> Subtitle
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-en">NS_ENUM</span>(<span class="pl-c1">NSInteger</span>, UITableViewCellStyle) {
   UITableViewCellStyleDefault,
   UITableViewCellStyleValue1,
   UITableViewCellStyleValue2,
   UITableViewCellStyleSubtitle
};</pre></div>

<p>Unfortunately, for <code>NS_OPTIONS</code>, the Swift equivalent is arguably worse:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> UIViewAutoresizing <span class="pl-k">:</span> RawOptionSetType {
    <span class="pl-k">init</span>(_ value: <span class="pl-c1">UInt</span>)
    <span class="pl-k">var</span> value: <span class="pl-c1">UInt</span>
    <span class="pl-k">static</span> <span class="pl-k">var</span> None: UIViewAutoresizing { <span class="pl-k">get</span> }
    <span class="pl-k">static</span> <span class="pl-k">var</span> FlexibleLeftMargin: UIViewAutoresizing { <span class="pl-k">get</span> }
    <span class="pl-k">static</span> <span class="pl-k">var</span> FlexibleWidth: UIViewAutoresizing { <span class="pl-k">get</span> }
    <span class="pl-k">static</span> <span class="pl-k">var</span> FlexibleRightMargin: UIViewAutoresizing { <span class="pl-k">get</span> }
    <span class="pl-k">static</span> <span class="pl-k">var</span> FlexibleTopMargin: UIViewAutoresizing { <span class="pl-k">get</span> }
    <span class="pl-k">static</span> <span class="pl-k">var</span> FlexibleHeight: UIViewAutoresizing { <span class="pl-k">get</span> }
    <span class="pl-k">static</span> <span class="pl-k">var</span> FlexibleBottomMargin: UIViewAutoresizing { <span class="pl-k">get</span> }
}</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">typedef</span> <span class="pl-en">NS_OPTIONS</span>(<span class="pl-c1">NSUInteger</span>, UIViewAutoresizing) {
   UIViewAutoresizingNone                 = <span class="pl-c1">0</span>,
   UIViewAutoresizingFlexibleLeftMargin   = <span class="pl-c1">1</span> &lt;&lt; <span class="pl-c1">0</span>,
   UIViewAutoresizingFlexibleWidth        = <span class="pl-c1">1</span> &lt;&lt; <span class="pl-c1">1</span>,
   UIViewAutoresizingFlexibleRightMargin  = <span class="pl-c1">1</span> &lt;&lt; <span class="pl-c1">2</span>,
   UIViewAutoresizingFlexibleTopMargin    = <span class="pl-c1">1</span> &lt;&lt; <span class="pl-c1">3</span>,
   UIViewAutoresizingFlexibleHeight       = <span class="pl-c1">1</span> &lt;&lt; <span class="pl-c1">4</span>,
   UIViewAutoresizingFlexibleBottomMargin = <span class="pl-c1">1</span> &lt;&lt; <span class="pl-c1">5</span>
};</pre></div>

<hr>

<p><code>RawOptionsSetType</code> is the Swift equivalent of <code>NS_OPTIONS</code> (or at least as close as it gets). It is a protocol that adopts the <code>RawRepresentable</code>, <code>Equatable</code>, <code>BitwiseOperationsType</code>, and <code>NilLiteralConvertible</code> protocols. An option type can be represented by a <code>struct</code> conforming to <code>RawOptionsSetType</code>.</p>

<p>Why does this suck so much? Well, the same integer bitmasking tricks in C don't work for enumerated types in Swift. An <code>enum</code> represents a type with a closed set of valid options, without a built-in mechanism for representing a conjunction of options for that type. An <code>enum</code> could, ostensibly, define a case for all possible combinations of values, but for <code>n &gt; 3</code>, the combinatorics make this approach untenable. There are a few different ways <code>NS_OPTIONS</code> could be implemented in Swift, but <code>RawOptionSetType</code> is probably the least bad.</p>

<p>Compared to the syntactically concise <code>enum</code> declaration, <code>RawOptionsSetType</code> is awkward and cumbersome, requiring over a dozen lines of boilerplate for computed properties:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> Toppings <span class="pl-k">:</span> RawOptionSetType, <span class="pl-c1">BooleanType</span> {
    <span class="pl-k">private</span> <span class="pl-k">var</span> value: <span class="pl-c1">UInt</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>

    <span class="pl-k">init</span>(_ value: <span class="pl-c1">UInt</span>) {
        <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-c1">value</span> <span class="pl-k">=</span> value
    }

    <span class="pl-c">// MARK: RawOptionSetType</span>

    <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">fromMask</span>(raw: <span class="pl-c1">UInt</span>) <span class="pl-k">-&gt;</span> Toppings {
        <span class="pl-k">return</span> <span class="pl-k">self</span>(raw)
    }

    <span class="pl-c">// MARK: RawRepresentable</span>

    <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">fromRaw</span>(raw: <span class="pl-c1">UInt</span>) <span class="pl-k">-&gt;</span> Toppings? {
        <span class="pl-k">return</span> <span class="pl-k">self</span>(raw)
    }

    <span class="pl-k">func</span> <span class="pl-en">toRaw</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">UInt</span> {
        <span class="pl-k">return</span> value
    }

    <span class="pl-c">// MARK: BooleanType</span>

    <span class="pl-k">var</span> boolValue: <span class="pl-c1">Bool</span> {
        <span class="pl-k">return</span> value <span class="pl-k">!=</span> <span class="pl-c1">0</span>
    }


    <span class="pl-c">// MARK: BitwiseOperationsType</span>

    <span class="pl-k">static</span> <span class="pl-k">var</span> allZeros: Toppings {
        <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0</span>)
    }

    <span class="pl-c">// MARK: NilLiteralConvertible</span>

    <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">convertFromNilLiteral</span>() <span class="pl-k">-&gt;</span> Toppings {
        <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0</span>)
    }

    <span class="pl-c">// MARK: -</span>

    <span class="pl-k">static</span> <span class="pl-k">var</span> None: Toppings           { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0b0000</span>) }
    <span class="pl-k">static</span> <span class="pl-k">var</span> ExtraCheese: Toppings    { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0b0001</span>) }
    <span class="pl-k">static</span> <span class="pl-k">var</span> Pepperoni: Toppings      { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0b0010</span>) }
    <span class="pl-k">static</span> <span class="pl-k">var</span> GreenPepper: Toppings    { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0b0100</span>) }
    <span class="pl-k">static</span> <span class="pl-k">var</span> Pineapple: Toppings      { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0b1000</span>) }
}</pre></div>

<blockquote>
<p>As of Xcode 6 Beta 6, <code>RawOptionSetType</code> no longer conforms to <code>BooleanType</code>, which is required for performing bitwise checks.</p>
</blockquote>

<p>One nice thing about doing this in Swift is its built-in binary integer literal notation, which allows the bitmask to be computed visually. And once the options type is declared, the usage syntax is not too bad.</p>

<p>Taken into a larger example for context:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> Pizza {
    <span class="pl-k">enum</span> Style {
        <span class="pl-k">case</span> Neopolitan, Sicilian, NewHaven, DeepDish
    }

    <span class="pl-k">struct</span> Toppings <span class="pl-k">:</span> RawOptionSetType { <span class="pl-k">...</span> }

    <span class="pl-k">let</span> diameter: <span class="pl-c1">Int</span>
    <span class="pl-k">let</span> style: Style
    <span class="pl-k">let</span> toppings: Toppings

    <span class="pl-k">init</span>(inchesInDiameter diameter: <span class="pl-c1">Int</span>, style: Style, toppings: Toppings <span class="pl-k">=</span> <span class="pl-k">.</span>None) {
        <span class="pl-k">self</span><span class="pl-k">.</span>diameter <span class="pl-k">=</span> diameter
        <span class="pl-k">self</span><span class="pl-k">.</span>style <span class="pl-k">=</span> style
        <span class="pl-k">self</span><span class="pl-k">.</span>toppings <span class="pl-k">=</span> toppings
    }
}

<span class="pl-k">let</span> dinner <span class="pl-k">=</span> Pizza(inchesInDiameter: <span class="pl-c1">12</span>, style: <span class="pl-k">.</span>Neopolitan, toppings: <span class="pl-k">.</span>Pepperoni <span class="pl-k">|</span> <span class="pl-k">.</span>GreenPepper)</pre></div>

<p>A value membership check can be performed with the <code>&amp;</code> operator, just like with unsigned integers in C:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> Pizza {
    <span class="pl-k">var</span> isVegetarian: <span class="pl-c1">Bool</span> {
        <span class="pl-k">return</span> toppings <span class="pl-k">&amp;</span> Toppings<span class="pl-k">.</span>Pepperoni <span class="pl-k">?</span> <span class="pl-c1">false</span> <span class="pl-k">:</span> <span class="pl-c1">true</span>
    }
}

dinner<span class="pl-k">.</span>isVegetarian <span class="pl-c">// false</span></pre></div>

<hr>

<p>In all fairness, it may be too early to really appreciate what role option types will have in the new language. It could very well be that Swift's other constructs, like tuples or pattern matching—or indeed, even <code>enum</code>s—make options little more than a vestige of the past.</p>

<p>Either way, if you're looking to implement an <code>NS_OPTIONS</code> equivalent in your code base, here's an <a href="http://nshipster.com/xcode-snippets/">Xcode snippet</a>-friendly example of how to go about it:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">struct</span> <span class="pl-k">&lt;</span># Options #<span class="pl-k">&gt;</span> <span class="pl-k">:</span> RawOptionSetType, <span class="pl-c1">BooleanType</span> {
    <span class="pl-k">let</span> rawValue: <span class="pl-c1">UInt</span>
    <span class="pl-k">init</span>(nilLiteral: ()) { <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-c1">value</span> <span class="pl-k">=</span> <span class="pl-c1">0</span> }
    <span class="pl-k">init</span>(_ value: <span class="pl-c1">UInt</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>) { <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-c1">value</span> <span class="pl-k">=</span> value }
    <span class="pl-k">init</span>(rawValue value: <span class="pl-c1">UInt</span>) { <span class="pl-k">self</span><span class="pl-k">.</span><span class="pl-c1">value</span> <span class="pl-k">=</span> value }
    <span class="pl-k">var</span> boolValue: <span class="pl-c1">Bool</span> { <span class="pl-k">return</span> value <span class="pl-k">!=</span> <span class="pl-c1">0</span> }
    <span class="pl-k">var</span> rawValue: <span class="pl-c1">UInt</span> { <span class="pl-k">return</span> value }
    <span class="pl-k">static</span> <span class="pl-k">var</span> allZeros: <span class="pl-k">&lt;</span># Options #<span class="pl-k">&gt;</span> { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0</span>) }

    <span class="pl-k">static</span> <span class="pl-k">var</span> None: <span class="pl-k">&lt;</span># Options #<span class="pl-k">&gt;</span>         { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0b0000</span>) }
    <span class="pl-k">static</span> <span class="pl-k">var</span> <span class="pl-k">&lt;</span># Option #<span class="pl-k">&gt;</span>: <span class="pl-k">&lt;</span># Options #<span class="pl-k">&gt;</span>     { <span class="pl-k">return</span> <span class="pl-k">self</span>(<span class="pl-c1">0b0001</span>) }
    <span class="pl-c">// ...</span>
}</pre></div>
</article></div>